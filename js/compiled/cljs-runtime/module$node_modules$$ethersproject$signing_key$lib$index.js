shadow$provide.module$node_modules$$ethersproject$signing_key$lib$index=function(global,require,module,exports){function getCurve(){_curve||(_curve=new elliptic_1.EC("secp256k1"));return _curve}function computePublicKey(key,compressed){key=bytes_1.arrayify(key);if(32===key.length){var signingKey=new SigningKey(key);return compressed?"0x"+getCurve().keyFromPrivate(key).getPublic(!0,"hex"):signingKey.publicKey}return 33===key.length?compressed?bytes_1.hexlify(key):"0x"+getCurve().keyFromPublic(key).getPublic(!1,
"hex"):65===key.length?compressed?"0x"+getCurve().keyFromPublic(key).getPublic(!0,"hex"):bytes_1.hexlify(key):logger.throwArgumentError("invalid public or private key","key","[REDACTED]")}Object.defineProperty(exports,"__esModule",{value:!0});exports.computePublicKey=exports.recoverPublicKey=exports.SigningKey=void 0;var elliptic_1=require("module$node_modules$$ethersproject$signing_key$lib$elliptic"),bytes_1=require("module$node_modules$$ethersproject$bytes$lib$index"),properties_1=require("module$node_modules$$ethersproject$properties$lib$index");
global=require("module$node_modules$$ethersproject$logger$lib$index");require=require("module$node_modules$$ethersproject$signing_key$lib$_version");var logger=new global.Logger(require.version),_curve=null,SigningKey=function(){function SigningKey(privateKey){properties_1.defineReadOnly(this,"curve","secp256k1");properties_1.defineReadOnly(this,"privateKey",bytes_1.hexlify(privateKey));privateKey=getCurve().keyFromPrivate(bytes_1.arrayify(this.privateKey));properties_1.defineReadOnly(this,"publicKey",
"0x"+privateKey.getPublic(!1,"hex"));properties_1.defineReadOnly(this,"compressedPublicKey","0x"+privateKey.getPublic(!0,"hex"));properties_1.defineReadOnly(this,"_isSigningKey",!0)}SigningKey.prototype._addPoint=function(other){var p0=getCurve().keyFromPublic(bytes_1.arrayify(this.publicKey));other=getCurve().keyFromPublic(bytes_1.arrayify(other));return"0x"+p0.pub.add(other.pub).encodeCompressed("hex")};SigningKey.prototype.signDigest=function(digest){var keyPair=getCurve().keyFromPrivate(bytes_1.arrayify(this.privateKey)),
digestBytes=bytes_1.arrayify(digest);32!==digestBytes.length&&logger.throwArgumentError("bad digest length","digest",digest);digest=keyPair.sign(digestBytes,{canonical:!0});return bytes_1.splitSignature({recoveryParam:digest.recoveryParam,r:bytes_1.hexZeroPad("0x"+digest.r.toString(16),32),s:bytes_1.hexZeroPad("0x"+digest.s.toString(16),32)})};SigningKey.prototype.computeSharedSecret=function(otherKey){var keyPair=getCurve().keyFromPrivate(bytes_1.arrayify(this.privateKey));otherKey=getCurve().keyFromPublic(bytes_1.arrayify(computePublicKey(otherKey)));
return bytes_1.hexZeroPad("0x"+keyPair.derive(otherKey.getPublic()).toString(16),32)};SigningKey.isSigningKey=function(value){return!(!value||!value._isSigningKey)};return SigningKey}();exports.SigningKey=SigningKey;exports.recoverPublicKey=function(digest,signature){signature=bytes_1.splitSignature(signature);var rs={r:bytes_1.arrayify(signature.r),s:bytes_1.arrayify(signature.s)};return"0x"+getCurve().recoverPubKey(bytes_1.arrayify(digest),rs,signature.recoveryParam).encode("hex",!1)};exports.computePublicKey=
computePublicKey}
//# sourceMappingURL=module$node_modules$$ethersproject$signing_key$lib$index.js.map
