shadow$provide.module$node_modules$ethereumjs_util$dist$secp256k1_adapter=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";var secp256k1=require("module$node_modules$ethereum_cryptography$secp256k1"),secp256k1v3=require("module$node_modules$ethereumjs_util$dist$secp256k1_lib$index"),der=require("module$node_modules$ethereumjs_util$dist$secp256k1_lib$der"),privateKeyVerify=function(privateKey){return 32!==privateKey.length?!1:secp256k1.privateKeyVerify(Uint8Array.from(privateKey))};
module.exports={privateKeyVerify,privateKeyExport:function(privateKey,compressed){if(32!==privateKey.length)throw new RangeError("private key length is invalid");var publicKey=secp256k1v3.privateKeyExport(privateKey,compressed);return der.privateKeyExport(privateKey,publicKey,compressed)},privateKeyImport:function(privateKey){privateKey=der.privateKeyImport(privateKey);if(null!==privateKey&&32===privateKey.length&&privateKeyVerify(privateKey))return privateKey;throw Error("couldn't import from DER format");
},privateKeyNegate:function(privateKey){return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)))},privateKeyModInverse:function(privateKey){if(32!==privateKey.length)throw Error("private key length is invalid");return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)))},privateKeyTweakAdd:function(privateKey,tweak){return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey),tweak))},privateKeyTweakMul:function(privateKey,tweak){return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey),
Uint8Array.from(tweak)))},publicKeyCreate:function(privateKey,compressed){return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey),compressed))},publicKeyConvert:function(publicKey,compressed){return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey),compressed))},publicKeyVerify:function(publicKey){return 33!==publicKey.length&&65!==publicKey.length?!1:secp256k1.publicKeyVerify(Uint8Array.from(publicKey))},publicKeyTweakAdd:function(publicKey,tweak,compressed){return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey),
Uint8Array.from(tweak),compressed))},publicKeyTweakMul:function(publicKey,tweak,compressed){return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey),Uint8Array.from(tweak),compressed))},publicKeyCombine:function(publicKeys,compressed){var keys=[];publicKeys.forEach(function(publicKey){keys.push(Uint8Array.from(publicKey))});return Buffer.from(secp256k1.publicKeyCombine(keys,compressed))},signatureNormalize:function(signature){return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)))},
signatureExport:function(signature){return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)))},signatureImport:function(signature){return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)))},signatureImportLax:function(signature){if(0===signature.length)throw new RangeError("signature length is invalid");signature=der.signatureImportLax(signature);if(null===signature)throw Error("couldn't parse DER signature");return secp256k1v3.signatureImport(signature)},sign:function(message$jscomp$0,
privateKey$jscomp$0,options){if(null===options)throw new TypeError("options should be an Object");var signOptions=void 0;if(options){signOptions={};if(null===options.data)throw new TypeError("options.data should be a Buffer");if(options.data){if(32!==options.data.length)throw new RangeError("options.data length is invalid");signOptions.data=new Uint8Array(options.data)}if(null===options.noncefn)throw new TypeError("options.noncefn should be a Function");options.noncefn&&(signOptions.noncefn=function(message,
privateKey,algo,data,attempt){algo=null!=algo?Buffer.from(algo):null;data=null!=data?Buffer.from(data):null;var buffer=Buffer.from("");options.noncefn&&(buffer=options.noncefn(Buffer.from(message),Buffer.from(privateKey),algo,data,attempt));return Uint8Array.from(buffer)})}message$jscomp$0=secp256k1.ecdsaSign(Uint8Array.from(message$jscomp$0),Uint8Array.from(privateKey$jscomp$0),signOptions);return{signature:Buffer.from(message$jscomp$0.signature),recovery:message$jscomp$0.recid}},verify:function(message,
signature,publicKey){return secp256k1.ecdsaVerify(Uint8Array.from(signature),Uint8Array.from(message),publicKey)},recover:function(message,signature,recid,compressed){return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature),recid,Uint8Array.from(message),compressed))},ecdh:function(publicKey,privateKey){return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey),Uint8Array.from(privateKey),{}))},ecdhUnsafe:function(publicKey,privateKey,compressed){if(33!==publicKey.length&&65!==publicKey.length)throw new RangeError("public key length is invalid");
if(32!==privateKey.length)throw new RangeError("private key length is invalid");return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey),Uint8Array.from(privateKey),compressed))}}}
//# sourceMappingURL=module$node_modules$ethereumjs_util$dist$secp256k1_adapter.js.map
