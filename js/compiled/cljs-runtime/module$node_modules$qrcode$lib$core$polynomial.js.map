{
"version":3,
"file":"module$node_modules$qrcode$lib$core$polynomial.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAe,8CAAf,CAAmE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAC3G,IAAIC,WAAaH,OAAA,CAAQ,wDAAR,CAAjB,CACII,GAAKJ,OAAA,CAAQ,kDAAR,CASTE,QAAA,CAAQG,GAAR,CAAcC,QAAa,CAACC,EAAD,CAAKC,EAAL,CAAS,CAGlC,IAFA,IAAIC,MAAQN,UAAA,CAAWO,KAAX,CAAiBH,EAAjB,CAAoBI,MAApB,CAA6BH,EAA7B,CAAgCG,MAAhC,CAAyC,CAAzC,CAAZ,CAESC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBL,EAApB,CAAuBI,MAAvB,CAA+BC,CAAA,EAA/B,CACE,IAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBL,EAApB,CAAuBG,MAAvB,CAA+BE,CAAA,EAA/B,CACEJ,KAAA,CAAMG,CAAN,CAAUC,CAAV,CAAA,EAAgBT,EAAA,CAAGC,GAAH,CAAOE,EAAA,CAAGK,CAAH,CAAP,CAAcJ,EAAA,CAAGK,CAAH,CAAd,CAIpB,OAAOJ,MAT2B,CAmBpCP,QAAA,CAAQY,GAAR,CAAcC,QAAa,CAACC,QAAD,CAAWC,OAAX,CAAoB,CAG7C,IAFIC,QAEJ,CAFaf,UAAA,CAAWgB,IAAX,CAAgBH,QAAhB,CAEb,CAA2C,CAA3C;AAAQE,QAAR,CAAeP,MAAf,CAAwBM,OAAxB,CAAgCN,MAAhC,CAAA,CAA8C,CAG5C,IAFA,IAAIF,MAAQS,QAAA,CAAO,CAAP,CAAZ,CAESN,EAAI,CAAb,CAAgBA,CAAhB,CAAoBK,OAApB,CAA4BN,MAA5B,CAAoCC,CAAA,EAApC,CACEM,QAAA,CAAON,CAAP,CAAA,EAAaR,EAAA,CAAGC,GAAH,CAAOY,OAAA,CAAQL,CAAR,CAAP,CAAmBH,KAAnB,CAKf,KADIW,KACJ,CADa,CACb,CAAOA,KAAP,CAAgBF,QAAhB,CAAuBP,MAAvB,EAAoD,CAApD,GAAiCO,QAAA,CAAOE,KAAP,CAAjC,CAAA,CAAuDA,KAAA,EACvDF,SAAA,CAASA,QAAA,CAAOG,KAAP,CAAaD,KAAb,CAVmC,CAa9C,MAAOF,SAhBsC,CA0B/ChB,QAAA,CAAQoB,oBAAR,CAA+BC,QAA8B,CAACC,MAAD,CAAS,CAEpE,IADA,IAAIC,KAAOtB,UAAA,CAAWgB,IAAX,CAAgB,CAAC,CAAD,CAAhB,CAAX,CACSP,EAAI,CAAb,CAAgBA,CAAhB,CAAoBY,MAApB,CAA4BZ,CAAA,EAA5B,CACEa,IAAA,CAAOvB,OAAA,CAAQG,GAAR,CAAYoB,IAAZ,CAAkB,CAAC,CAAD,CAAIrB,EAAA,CAAGsB,GAAH,CAAOd,CAAP,CAAJ,CAAlB,CAGT,OAAOa,KAN6D,CAxDqC;",
"sources":["node_modules/qrcode/lib/core/polynomial.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$polynomial\"] = function(global,require,module,exports) {\nvar BufferUtil = require('../utils/buffer')\nvar GF = require('./galois-field')\n\n/**\n * Multiplies two polynomials inside Galois Field\n *\n * @param  {Buffer} p1 Polynomial\n * @param  {Buffer} p2 Polynomial\n * @return {Buffer}    Product of p1 and p2\n */\nexports.mul = function mul (p1, p2) {\n  var coeff = BufferUtil.alloc(p1.length + p2.length - 1)\n\n  for (var i = 0; i < p1.length; i++) {\n    for (var j = 0; j < p2.length; j++) {\n      coeff[i + j] ^= GF.mul(p1[i], p2[j])\n    }\n  }\n\n  return coeff\n}\n\n/**\n * Calculate the remainder of polynomials division\n *\n * @param  {Buffer} divident Polynomial\n * @param  {Buffer} divisor  Polynomial\n * @return {Buffer}          Remainder\n */\nexports.mod = function mod (divident, divisor) {\n  var result = BufferUtil.from(divident)\n\n  while ((result.length - divisor.length) >= 0) {\n    var coeff = result[0]\n\n    for (var i = 0; i < divisor.length; i++) {\n      result[i] ^= GF.mul(divisor[i], coeff)\n    }\n\n    // remove all zeros from buffer head\n    var offset = 0\n    while (offset < result.length && result[offset] === 0) offset++\n    result = result.slice(offset)\n  }\n\n  return result\n}\n\n/**\n * Generate an irreducible generator polynomial of specified degree\n * (used by Reed-Solomon encoder)\n *\n * @param  {Number} degree Degree of the generator polynomial\n * @return {Buffer}        Buffer containing polynomial coefficients\n */\nexports.generateECPolynomial = function generateECPolynomial (degree) {\n  var poly = BufferUtil.from([1])\n  for (var i = 0; i < degree; i++) {\n    poly = exports.mul(poly, [1, GF.exp(i)])\n  }\n\n  return poly\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","BufferUtil","GF","mul","exports.mul","p1","p2","coeff","alloc","length","i","j","mod","exports.mod","divident","divisor","result","from","offset","slice","generateECPolynomial","exports.generateECPolynomial","degree","poly","exp"]
}
