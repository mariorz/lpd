shadow$provide.module$node_modules$vega_lite$build$vega_lite=function(global$jscomp$0,require,module$jscomp$0,exports$jscomp$0){var Buffer=require("module$node_modules$buffer$index").Buffer;(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module$jscomp$0?factory(exports$jscomp$0):"function"===typeof define&&define.amd?define(["exports"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.vegaLite={}))})(this,function(exports){function accessor$jscomp$0(fn,
fields,name){fn.fields=fields||[];fn.fname=name;return fn}function getter(path){return 1===path.length?get1(path[0]):getN(path)}function splitAccessPath(p){function push(){path.push(s+p.substring(i,j));s="";i=j+1}const path=[],n=p.length;let q=null,b=0,s="",i,j,c;p+="";for(i=j=0;j<n;++j)if(c=p[j],"\\"===c)s+=p.substring(i,j),s+=p.substring(++j,++j),i=j;else if(c===q)push(),q=null,b=-1;else if(!q)if(i===b&&'"'===c)i=j+1,q=c;else if(i===b&&"'"===c)i=j+1,q=c;else if("."===c&&!b)j>i?push():i=j+1;else if("["===
c)j>i&&push(),b=i=j+1;else if("]"===c){if(!b)throw Error("Access path missing open bracket: "+p);0<b&&push();b=0;i=j+1}if(b)throw Error("Access path missing closing bracket: "+p);if(q)throw Error("Access path missing closing quote: "+p);j>i&&(j++,push());return path}function log(method,level,input){level=[level].concat([].slice.call(input));console[method].apply(console,level)}function isObject(_){return _===Object(_)}function mergeConfig(...configs){return configs.reduce((out,source)=>{for(const key in source)"signals"===
key?out.signals=mergeNamed(out.signals,source.signals):writeConfig(out,key,source[key],"legend"===key?{layout:1}:"style"===key?!0:null);return out},{})}function writeConfig(output,key,value,recurse){if("__proto__"!==key){var k;if(isObject(value)&&!isArray(value))for(k in output=isObject(output[key])?output[key]:output[key]={},value)recurse&&(!0===recurse||recurse[k])?writeConfig(output,k,value[k]):"__proto__"!==k&&(output[k]=value[k]);else output[key]=value}}function mergeNamed(a,b){function add(_){map[_.name]||
(map[_.name]=1,out.push(_))}if(null==a)return b;const map={},out=[];b.forEach(add);a.forEach(add);return out}function array$jscomp$0(_){return null!=_?isArray(_)?_:[_]:[]}function isBoolean(_){return"boolean"===typeof _}function isNumber(_){return"number"===typeof _}function isString(_){return"string"===typeof _}function $(x){return isArray(x)?"["+x.map($)+"]":isObject(x)||isString(x)?JSON.stringify(x).replace("\u2028","\\u2028").replace("\u2029","\\u2029"):x}function toSet(_){const s={},n=_.length;
for(let i=0;i<n;++i)s[_[i]]=!0;return s}function forEachLeaf(op,fn){if(op.not)forEachLeaf(op.not,fn);else if(op.and)for(const subop of op.and)forEachLeaf(subop,fn);else if(op.or)for(const subop of op.or)forEachLeaf(subop,fn);else fn(op)}function normalizeLogicalComposition(op,normalizer){return op.not?{not:normalizeLogicalComposition(op.not,normalizer)}:op.and?{and:op.and.map(o=>normalizeLogicalComposition(o,normalizer))}:op.or?{or:op.or.map(o=>normalizeLogicalComposition(o,normalizer))}:normalizer(op)}
function pick(obj,props){const copy={};for(const prop of props)hop.call(obj,prop)&&(copy[prop]=obj[prop]);return copy}function omit(obj,props){obj=Object.assign({},obj);for(const prop of props)delete obj[prop];return obj}function hash(a){if(isNumber(a))return a;a=isString(a)?a:fastJsonStableStringify(a);if(250>a.length)return a;let h=0;for(let i=0;i<a.length;i++){const char=a.charCodeAt(i);h=(h<<5)-h+char;h&=h}return h}function isNullOrFalse(x){return!1===x||null===x}function contains(array,item){return-1<
array.indexOf(item)}function some(arr,f){let i=0;for(const $jscomp$destructuring$var0 of arr.entries()){const [k,a]=$jscomp$destructuring$var0;if(f(a,k,i++))return!0}return!1}function every(arr,f){let i=0;for(const $jscomp$destructuring$var1 of arr.entries()){const [k,a]=$jscomp$destructuring$var1;if(!f(a,k,i++))return!1}return!0}function mergeDeep(dest,...src$jscomp$0){for(const s of src$jscomp$0){src$jscomp$0=dest;var src=null!==s&&void 0!==s?s:{};for(const property of keys$jscomp$0(src))writeConfig(src$jscomp$0,
property,src[property],!0)}return dest}function unique(values,f){const results=[],u={};for(const val of values)values=f(val),values in u||(u[values]=1,results.push(val));return results}function setEqual(a,b){if(a.size!==b.size)return!1;for(const e of a)if(!b.has(e))return!1;return!0}function hasIntersection(a,b){for(const key of a)if(b.has(key))return!0;return!1}function prefixGenerator(a){const prefixes=new Set;for(const x of a){const wrappedWithAccessors=splitAccessPath(x).map((y,i)=>0===i?y:"[".concat(y,
"]"));a=wrappedWithAccessors.map((_,i)=>wrappedWithAccessors.slice(0,i+1).join(""));for(const y of a)prefixes.add(y)}return prefixes}function fieldIntersection(a,b){return void 0===a||void 0===b?!0:hasIntersection(prefixGenerator(a),prefixGenerator(b))}function isEmpty(obj){return 0===keys$jscomp$0(obj).length}function isBoolean$1(b){return!0===b||!1===b}function varName(s){const alphanumericS=s.replace(/\W/g,"_");return(s.match(/^\d+/)?"_":"")+alphanumericS}function logicalExpr(op,cb){return op.not?
"!("+logicalExpr(op.not,cb)+")":op.and?"("+op.and.map(and=>logicalExpr(and,cb)).join(") \x26\x26 (")+")":op.or?"("+op.or.map(or=>logicalExpr(or,cb)).join(") || (")+")":cb(op)}function deleteNestedProperty(obj,orderedProps){if(0===orderedProps.length)return!0;const prop=orderedProps.shift();prop in obj&&deleteNestedProperty(obj[prop],orderedProps)&&delete obj[prop];return isEmpty(obj)}function titleCase(s){return s.charAt(0).toUpperCase()+s.substr(1)}function accessPathWithDatum(path,datum){datum=
void 0===datum?"datum":datum;path=splitAccessPath(path);const prefixes=[];for(let i=1;i<=path.length;i++){const prefix="[".concat(path.slice(0,i).map($).join("]["),"]");prefixes.push("".concat(datum).concat(prefix))}return prefixes.join(" \x26\x26 ")}function flatAccessWithDatum(path,datum){return"".concat(void 0===datum?"datum":datum,"[").concat($(splitAccessPath(path).join(".")),"]")}function escapePathAccess(string){return string.replace(/(\[|\]|\.|'|")/g,"\\$1")}function replacePathInField(path){return"".concat(splitAccessPath(path).map(escapePathAccess).join("\\."))}
function replaceAll(string,find,replacement){return string.replace(new RegExp(find.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$\x26"),"g"),replacement)}function removePathFromField(path){return"".concat(splitAccessPath(path).join("."))}function accessPathDepth(path){return path?splitAccessPath(path).length:0}function getFirstDefined(...args){for(const arg of args)if(void 0!==arg)return arg}function uniqueId(prefix){const id=++idCounter;return prefix?String(prefix)+id:id}function internalField(name){return isInternalField(name)?
name:"__".concat(name)}function isInternalField(name){return 0===name.indexOf("__")}function normalizeAngle(angle){if(void 0!==angle)return(angle%360+360)%360}function isNumeric(value){return isNumber(value)?!0:!isNaN(value)&&!isNaN(parseFloat(value))}function isConditionalAxisValue(v){return v&&v.condition}function isArgminDef(a){return!!a&&!!a.argmin}function isArgmaxDef(a){return!!a&&!!a.argmax}function isAggregateOp(a){return isString(a)&&!!AGGREGATE_OP_INDEX[a]}function isCountingAggregateOp(aggregate){return isString(aggregate)&&
contains(COUNTING_OPS,aggregate)}function getPositionChannelFromLatLong(channel){switch(channel){case "latitude":return"y";case "latitude2":return"y2";case "longitude":return"x";case "longitude2":return"x2"}}function isColorChannel(channel){return"color"===channel||"fill"===channel||"stroke"===channel}function isSecondaryRangeChannel(c){return getMainRangeChannel(c)!==c}function getMainRangeChannel(channel){switch(channel){case "x2":return"x";case "y2":return"y";case "latitude2":return"latitude";
case "longitude2":return"longitude";case "theta2":return"theta";case "radius2":return"radius"}return channel}function getVgPositionChannel(channel){if(channel in POLAR_POSITION_CHANNEL_INDEX)switch(channel){case "theta":return"startAngle";case "theta2":return"endAngle";case "radius":return"outerRadius";case "radius2":return"innerRadius"}return channel}function getSecondaryRangeChannel(channel){switch(channel){case "x":return"x2";case "y":return"y2";case "latitude":return"latitude2";case "longitude":return"longitude2";
case "theta":return"theta2";case "radius":return"radius2"}}function getSizeChannel(channel){switch(channel){case "x":case "x2":return"width";case "y":case "y2":return"height"}}function getOffsetChannel(channel){switch(channel){case "x":return"xOffset";case "y":return"yOffset";case "x2":return"x2Offset";case "y2":return"y2Offset";case "theta":return"thetaOffset";case "radius":return"radiusOffset";case "theta2":return"theta2Offset";case "radius2":return"radius2Offset"}}function getPositionScaleChannel(sizeType){return"width"===
sizeType?"x":"y"}function getSupportedMark(channel){switch(channel){case "color":case "fill":case "stroke":case "description":case "detail":case "key":case "tooltip":case "href":case "order":case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeWidth":case "facet":case "row":case "column":return ALL_MARKS;case "x":case "y":case "latitude":case "longitude":return ALL_MARKS_EXCEPT_GEOSHAPE;case "x2":case "y2":case "latitude2":case "longitude2":return{area:"always",bar:"always",image:"always",
rect:"always",rule:"always",circle:"binned",point:"binned",square:"binned",tick:"binned",line:"binned",trail:"binned"};case "size":return{point:"always",tick:"always",rule:"always",circle:"always",square:"always",bar:"always",text:"always",line:"always",trail:"always"};case "strokeDash":return{line:"always",point:"always",tick:"always",rule:"always",circle:"always",square:"always",bar:"always",geoshape:"always"};case "shape":return{point:"always",geoshape:"always"};case "text":return{text:"always"};
case "angle":return{point:"always",square:"always",text:"always"};case "url":return{image:"always"};case "theta":return{text:"always",arc:"always"};case "radius":return{text:"always",arc:"always"};case "theta2":case "radius2":return{arc:"always"}}}function rangeType(channel){switch(channel){case "facet":case "row":case "column":case "shape":case "strokeDash":case "text":case "tooltip":case "href":case "url":case "description":return"discrete";case "color":case "fill":case "stroke":return"flexible"}}
function binToString(bin){isBoolean(bin)&&(bin=normalizeBin(bin,void 0));return"bin"+keys$jscomp$0(bin).map(p=>isSelectionExtent(bin[p])?varName("_".concat(p,"_").concat(entries(bin[p]))):varName("_".concat(p,"_").concat(bin[p]))).join("")}function isBinning(bin){return!0===bin||isObject(bin)&&!bin.binned}function isBinned(bin){return"binned"===bin||isObject(bin)&&!0===bin.binned}function isSelectionExtent(extent){return null===extent||void 0===extent?void 0:extent.selection}function autoMaxBins(channel){switch(channel){case "row":case "column":case "size":case "color":case "fill":case "stroke":case "strokeWidth":case "opacity":case "fillOpacity":case "strokeOpacity":case "shape":return 6;
case "strokeDash":return 4;default:return 10}}function _defineProperty(obj,key,value){key in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value;return obj}function _classPrivateFieldSet(receiver,privateMap,value){privateMap=privateMap.get(receiver);if(!privateMap)throw new TypeError("attempted to set private field on non-instance");if(privateMap.set)privateMap.set.call(receiver,value);else{if(!privateMap.writable)throw new TypeError("attempted to set read only private field");
privateMap.value=value}return value}function invalidSpec(spec){return"Invalid specification ".concat(JSON.stringify(spec),'. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".')}function containerSizeNonSingle(name){return"".concat("width"==name?"Width":"Height",' "container" only works for single views and layered views.')}function containerSizeNotCompatibleWithAutosize(name){const fitDirection="width"==
name?"x":"y";return"".concat("width"==name?"Width":"Height",' "container" only works well with autosize "fit" or "fit-').concat(fitDirection,'".')}function droppingFit(channel){return channel?'Dropping "fit-'.concat(channel,'" because spec has discrete ').concat(getSizeChannel(channel),"."):'Dropping "fit" because spec has discrete size.'}function unknownField(channel){return"Unknown field for ".concat(channel,". Cannot calculate view size.")}function cannotProjectOnChannelWithoutField(channel){return'Cannot project a selection on encoding channel "'.concat(channel,
'", which has no field.')}function cannotProjectAggregate(channel,aggregate){return'Cannot project a selection on encoding channel "'.concat(channel,'" as it uses an aggregate function ("').concat(aggregate,'").')}function selectionNotSupported(mark){return"Selection not supported for ".concat(mark," yet.")}function columnsNotSupportByRowCol(type){return'The "columns" property cannot be used when "'.concat(type,'" has nested row/column.')}function differentParse(field,local,ancestor){return'An ancestor parsed field "'.concat(field,
'" as ').concat(ancestor," but a child wants to parse the field as ").concat(local,".")}function customFormatTypeNotAllowed(channel){return"Config.customFormatTypes is not true, thus custom format type and format for channel ".concat(channel," are dropped.")}function droppingColor(type,opt){const {fill,stroke}=opt;return"Dropping color ".concat(type," as the plot also has ").concat(fill&&stroke?"fill and stroke":fill?"fill":"stroke",".")}function emptyFieldDef(fieldDef,channel){return"Dropping ".concat(stringify(fieldDef),
' from channel "').concat(channel,'" since it does not contain any data field, datum, value, or signal.')}function incompatibleChannel(channel,markOrFacet,when){return"".concat(channel,' dropped as it is incompatible with "').concat(markOrFacet,'"').concat(when?" when ".concat(when):"",".")}function invalidEncodingChannel(channel){return"".concat(channel,"-encoding is dropped as ").concat(channel," is not a valid encoding channel.")}function discreteChannelCannotEncode(channel,type){return'Using discrete channel "'.concat(channel,
'" to encode "').concat(type,'" field can be misleading as it does not encode ').concat("ordinal"===type?"order":"magnitude",".")}function scalePropertyNotWorkWithScaleType(scaleType,propName,channel){return"".concat(channel,"-scale's \"").concat(propName,'" is dropped as it does not work with ').concat(scaleType," scale.")}function stepDropped(channel){return'The step for "'.concat(channel,'" is dropped because the ').concat("width"===channel?"x":"y"," is continuous.")}function cannotStackRangedMark(channel){return'Cannot stack "'.concat(channel,
'" if there is already "').concat(channel,'2".')}function invalidTimeUnit(unitName,value){return"Invalid ".concat(unitName,": ").concat(stringify(value),".")}function errorBand1DNotSupport(property){return"1D error band does not support ".concat(property,".")}function channelRequiredForBinned(channel){return"Channel ".concat(channel,' is required for "binned" bin.')}function warn(...args){current.warn(...args)}function isDateTime(o){if(o&&isObject(o))for(const part of TIMEUNIT_PARTS)if(part in o)return!0;
return!1}function normalizeMonth(m){isNumeric(m)&&(m=+m);if(isNumber(m))return m-1;{var lowerM=m.toLowerCase();const monthIndex=MONTHS.indexOf(lowerM);if(-1!==monthIndex)return monthIndex;lowerM=lowerM.substr(0,3);lowerM=SHORT_MONTHS.indexOf(lowerM);if(-1!==lowerM)return lowerM;throw Error(invalidTimeUnit("month",m));}}function normalizeDay(d){isNumeric(d)&&(d=+d);if(isNumber(d))return d%7;{var lowerD=d.toLowerCase();const dayIndex=DAYS.indexOf(lowerD);if(-1!==dayIndex)return dayIndex;lowerD=lowerD.substr(0,
3);lowerD=SHORT_DAYS.indexOf(lowerD);if(-1!==lowerD)return lowerD;throw Error(invalidTimeUnit("day",d));}}function dateTimeParts(d,normalize){const parts=[];normalize&&void 0!==d.day&&1<keys$jscomp$0(d).length&&(warn("Dropping day from datetime ".concat(stringify(d)," as day cannot be combined with other units.")),d=duplicate(d),delete d.day);void 0!==d.year?parts.push(d.year):parts.push(2012);if(void 0!==d.month){var month=normalize?normalizeMonth(d.month):d.month;parts.push(month)}else if(void 0!==
d.quarter){if(normalize)if(month=d.quarter,isNumeric(month)&&(month=+month),isNumber(month))4<month&&warn(invalidTimeUnit("quarter",month)),--month;else throw Error(invalidTimeUnit("quarter",month));else month=d.quarter;parts.push(isNumber(month)?3*month:month+"*3")}else parts.push(0);void 0!==d.date?parts.push(d.date):void 0!==d.day?(normalize=normalize?normalizeDay(d.day):d.day,parts.push(isNumber(normalize)?normalize+1:normalize+"+1")):parts.push(1);for(const timeUnit of["hours","minutes","seconds",
"milliseconds"])normalize=d[timeUnit],parts.push("undefined"===typeof normalize?0:normalize);return parts}function dateTimeToExpr(d){const string=dateTimeParts(d,!0).join(", ");return d.utc?"utc(".concat(string,")"):"datetime(".concat(string,")")}function dateTimeToTimestamp(d){const parts=dateTimeParts(d,!0);return d.utc?+new Date(Date.UTC(...parts)):+new Date(...parts)}function getTimeUnitParts(timeUnit){const parts=[];for(const part of TIMEUNIT_PARTS)containsTimeUnit(timeUnit,part)&&parts.push(part);
return parts}function containsTimeUnit(fullTimeUnit,timeUnit){const index=fullTimeUnit.indexOf(timeUnit);return 0>index||0<index&&"seconds"===timeUnit&&"i"===fullTimeUnit.charAt(index-1)||fullTimeUnit.length>index+3&&"day"===timeUnit&&"o"===fullTimeUnit.charAt(index+3)||0<index&&"year"===timeUnit&&"f"===fullTimeUnit.charAt(index-1)?!1:!0}function timeUnitSpecifierExpression(timeUnit){if(timeUnit)return timeUnit=getTimeUnitParts(timeUnit),"timeUnitSpecifier(".concat(fastJsonStableStringify(timeUnit),
", ").concat(fastJsonStableStringify(VEGALITE_TIMEFORMAT),")")}function normalizeTimeUnit(timeUnit){if(timeUnit){var params;isString(timeUnit)?params={unit:timeUnit}:isObject(timeUnit)&&(params=Object.assign({},timeUnit,timeUnit.unit?{unit:timeUnit.unit}:{}));params.unit.startsWith("utc")&&(params.utc=!0,params.unit=params.unit.substr(3));return params}}function timeUnitToString(tu){var $jscomp$destructuring$var13=normalizeTimeUnit(tu);tu=Object.assign({},$jscomp$destructuring$var13);$jscomp$destructuring$var13=
$jscomp$destructuring$var13.utc;const rest=(delete tu.utc,tu);return rest.unit?($jscomp$destructuring$var13?"utc":"")+keys$jscomp$0(rest).map(p=>varName("".concat("unit"===p?"":"_".concat(p,"_")).concat(rest[p]))).join(""):($jscomp$destructuring$var13?"utc":"")+"timeunit"+keys$jscomp$0(rest).map(p=>varName("_".concat(p,"_").concat(rest[p]))).join("")}function isSignalRef(o){return o&&!!o.signal}function isVgRangeStep(range){return!!range.step}function isDataRefDomain(domain){return isArray(domain)?
!1:"field"in domain&&"data"in domain}function isFieldEqualPredicate(predicate){return predicate&&!!predicate.field&&void 0!==predicate.equal}function isFieldLTPredicate(predicate){return predicate&&!!predicate.field&&void 0!==predicate.lt}function isFieldLTEPredicate(predicate){return predicate&&!!predicate.field&&void 0!==predicate.lte}function isFieldGTPredicate(predicate){return predicate&&!!predicate.field&&void 0!==predicate.gt}function isFieldGTEPredicate(predicate){return predicate&&!!predicate.field&&
void 0!==predicate.gte}function isFieldRangePredicate(predicate){return predicate&&predicate.field&&(isArray(predicate.range)&&2===predicate.range.length||isSignalRef(predicate.range))?!0:!1}function isFieldOneOfPredicate(predicate){return predicate&&!!predicate.field&&(isArray(predicate.oneOf)||isArray(predicate.in))}function isFieldPredicate(predicate){return isFieldOneOfPredicate(predicate)||isFieldEqualPredicate(predicate)||isFieldRangePredicate(predicate)||isFieldLTPredicate(predicate)||isFieldGTPredicate(predicate)||
isFieldLTEPredicate(predicate)||isFieldGTEPredicate(predicate)}function predicateValueExpr(v,timeUnit){return valueExpr(v,{timeUnit,wrapTime:!0})}function predicateValuesExpr(vals,timeUnit){return vals.map(v=>predicateValueExpr(v,timeUnit))}function fieldFilterExpression(predicate,useInRange){useInRange=void 0===useInRange?!0:useInRange;var _normalizeTimeUnit,{field}=predicate;const timeUnit=null===(_normalizeTimeUnit=normalizeTimeUnit(predicate.timeUnit))||void 0===_normalizeTimeUnit?void 0:_normalizeTimeUnit.unit;
if(timeUnit){{({end:_normalizeTimeUnit}={end:!1});field=accessPathWithDatum(field);const utc=timeUnit.startsWith("utc")?"utc":"";const dateExpr={};for(JSCompiler_temp of TIMEUNIT_PARTS)if(containsTimeUnit(timeUnit,JSCompiler_temp)){var lastTimeUnit=JSCompiler_temp;lastTimeUnit="quarter"===lastTimeUnit?"(".concat(utc,"quarter(").concat(field,")-1)"):"".concat(utc).concat(lastTimeUnit,"(").concat(field,")");dateExpr[JSCompiler_temp]=lastTimeUnit;lastTimeUnit=JSCompiler_temp}_normalizeTimeUnit&&(dateExpr[lastTimeUnit]+=
"+1");var JSCompiler_temp=dateExpr;_normalizeTimeUnit=dateTimeParts(JSCompiler_temp,!1).join(", ");JSCompiler_temp=JSCompiler_temp.utc?"utc(".concat(_normalizeTimeUnit,")"):"datetime(".concat(_normalizeTimeUnit,")")}JSCompiler_temp="time("+JSCompiler_temp+")"}else JSCompiler_temp=vgField(predicate,{expr:"datum"});if(isFieldEqualPredicate(predicate))return JSCompiler_temp+"\x3d\x3d\x3d"+predicateValueExpr(predicate.equal,timeUnit);if(isFieldLTPredicate(predicate))return useInRange=predicate.lt,"".concat(JSCompiler_temp,
"\x3c").concat(predicateValueExpr(useInRange,timeUnit));if(isFieldGTPredicate(predicate))return useInRange=predicate.gt,"".concat(JSCompiler_temp,"\x3e").concat(predicateValueExpr(useInRange,timeUnit));if(isFieldLTEPredicate(predicate))return useInRange=predicate.lte,"".concat(JSCompiler_temp,"\x3c\x3d").concat(predicateValueExpr(useInRange,timeUnit));if(isFieldGTEPredicate(predicate))return useInRange=predicate.gte,"".concat(JSCompiler_temp,"\x3e\x3d").concat(predicateValueExpr(useInRange,timeUnit));
if(isFieldOneOfPredicate(predicate))return"indexof([".concat(predicateValuesExpr(predicate.oneOf,timeUnit).join(","),"], ").concat(JSCompiler_temp,") !\x3d\x3d -1");if(predicate&&predicate.field&&void 0!==predicate.valid)return fieldValidPredicate(JSCompiler_temp,predicate.valid);if(isFieldRangePredicate(predicate)){({range:_normalizeTimeUnit}=predicate);predicate=isSignalRef(_normalizeTimeUnit)?{signal:"".concat(_normalizeTimeUnit.signal,"[0]")}:_normalizeTimeUnit[0];_normalizeTimeUnit=isSignalRef(_normalizeTimeUnit)?
{signal:"".concat(_normalizeTimeUnit.signal,"[1]")}:_normalizeTimeUnit[1];if(null!==predicate&&null!==_normalizeTimeUnit&&useInRange)return"inrange("+JSCompiler_temp+", ["+predicateValueExpr(predicate,timeUnit)+", "+predicateValueExpr(_normalizeTimeUnit,timeUnit)+"])";useInRange=[];null!==predicate&&useInRange.push("".concat(JSCompiler_temp," \x3e\x3d ").concat(predicateValueExpr(predicate,timeUnit)));null!==_normalizeTimeUnit&&useInRange.push("".concat(JSCompiler_temp," \x3c\x3d ").concat(predicateValueExpr(_normalizeTimeUnit,
timeUnit)));return 0<useInRange.length?useInRange.join(" \x26\x26 "):"true"}throw Error("Invalid field predicate: ".concat(JSON.stringify(predicate)));}function fieldValidPredicate(fieldExpr,valid){return void 0===valid||valid?"isValid(".concat(fieldExpr,") \x26\x26 isFinite(+").concat(fieldExpr,")"):"!isValid(".concat(fieldExpr,") || !isFinite(+").concat(fieldExpr,")")}function normalizePredicate(f){if(isFieldPredicate(f)&&f.timeUnit){var _normalizeTimeUnit2;return Object.assign({},f,{timeUnit:null===
(_normalizeTimeUnit2=normalizeTimeUnit(f.timeUnit))||void 0===_normalizeTimeUnit2?void 0:_normalizeTimeUnit2.unit})}return f}function getFullName(type){if(type)switch(type=type.toLowerCase(),type){case "q":case "quantitative":return"quantitative";case "t":case "temporal":return"temporal";case "o":case "ordinal":return"ordinal";case "n":case "nominal":return"nominal";case "geojson":return"geojson"}}function isSelectionDomain(domain){return null===domain||void 0===domain?void 0:domain.selection}function scaleTypeSupportProperty(scaleType,
propName){switch(propName){case "type":case "domain":case "reverse":case "range":return!0;case "scheme":case "interpolate":return!contains(["point","band","identity"],scaleType);case "bins":return!contains(["point","band","identity","ordinal"],scaleType);case "round":return scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX||"band"===scaleType||"point"===scaleType;case "padding":case "rangeMin":case "rangeMax":return scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX||contains(["point","band"],scaleType);case "paddingOuter":case "align":return contains(["point",
"band"],scaleType);case "paddingInner":return"band"===scaleType;case "domainMax":case "domainMid":case "domainMin":case "clamp":return scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX;case "nice":return scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX||"quantize"===scaleType||"threshold"===scaleType;case "exponent":return"pow"===scaleType;case "base":return"log"===scaleType;case "constant":return"symlog"===scaleType;case "zero":return scaleType in CONTINUOUS_DOMAIN_INDEX&&!contains(["log","time","utc","threshold",
"quantile"],scaleType)}}function channelScalePropertyIncompatability(channel,propName){switch(propName){case "interpolate":case "scheme":case "domainMid":if(!isColorChannel(channel))return'Cannot use the scale property "'.concat(channel,'" with non-color channel.')}}function channelSupportScaleType(channel,scaleType){if(!SCALE_CHANNEL_INDEX[channel])return!1;switch(channel){case "x":case "y":case "theta":case "radius":return scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX||contains(["band","point"],scaleType);
case "size":case "strokeWidth":case "opacity":case "fillOpacity":case "strokeOpacity":case "angle":return scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX||scaleType in CONTINUOUS_TO_DISCRETE_INDEX||contains(["band","point","ordinal"],scaleType);case "color":case "fill":case "stroke":return"band"!==scaleType;case "strokeDash":return"ordinal"===scaleType||scaleType in CONTINUOUS_TO_DISCRETE_INDEX;case "shape":return"ordinal"===scaleType}}function isExprRef(o){return o&&!!o.expr}function replaceExprRefInIndex(index){const props=
keys$jscomp$0(index||{}),newIndex={};for(const prop of props)newIndex[prop]=signalRefOrValue(index[prop]);return newIndex}function isPathMark(m){return contains(["line","area","trail"],m)}function isMarkDef(mark){return mark.type}function midPointRefWithPositionInvalidTest(params){const {channel,channelDef,markDef,scale,config}=params;params=midPoint(params);return isFieldDef(channelDef)&&!isCountingAggregateOp(channelDef.aggregate)&&scale&&scale.get("type")in CONTINUOUS_TO_CONTINUOUS_INDEX&&!1===
scale.get("zero")?wrapPositionInvalidTest({fieldDef:channelDef,channel,markDef,ref:params,config}):params}function wrapPositionInvalidTest($jscomp$destructuring$var17){var {fieldDef,channel,markDef,ref,config}=$jscomp$destructuring$var17;if(isPathMark(markDef.type)||null===getMarkPropOrConfig("invalid",markDef,config))return ref;{$jscomp$destructuring$var17=fieldInvalidPredicate(fieldDef,!0);const zeroValueRef="y"===getMainRangeChannel(channel)?{field:{group:"height"}}:{value:0};$jscomp$destructuring$var17=
Object.assign({},{test:$jscomp$destructuring$var17},zeroValueRef)}return[$jscomp$destructuring$var17,ref]}function fieldInvalidPredicate(field,invalid){invalid=void 0===invalid?!0:invalid;return fieldValidPredicate(isString(field)?field:vgField(field,{expr:"datum"}),!invalid)}function valueRefForFieldOrDatumDef(fieldDef,scaleName,opt,encode){const ref={};scaleName&&(ref.scale=scaleName);isDatumDef(fieldDef)?({datum:fieldDef}=fieldDef,isDateTime(fieldDef)?ref.signal=dateTimeToExpr(fieldDef):isSignalRef(fieldDef)?
ref.signal=fieldDef.signal:isExprRef(fieldDef)?ref.signal=fieldDef.expr:ref.value=fieldDef):ref.field=vgField(fieldDef,opt);if(encode){const {offset,band}=encode;offset&&(ref.offset=offset);band&&(ref.band=band)}return ref}function interpolatedSignalRef($jscomp$destructuring$var18){var {scaleName,fieldOrDatumDef,fieldOrDatumDef2,offset,startSuffix,band=.5}=$jscomp$destructuring$var18,expr=0<band&&1>band?"datum":void 0;$jscomp$destructuring$var18=vgField(fieldOrDatumDef,{expr,suffix:startSuffix});
const end=void 0!==fieldOrDatumDef2?vgField(fieldOrDatumDef2,{expr}):vgField(fieldOrDatumDef,{suffix:"end",expr});expr={};0===band||1===band?(expr.scale=scaleName,expr.field=0===band?$jscomp$destructuring$var18:end):($jscomp$destructuring$var18="".concat(band," * ").concat($jscomp$destructuring$var18," + ").concat(1-band," * ").concat(end),expr.signal='scale("'.concat(scaleName,'", ').concat($jscomp$destructuring$var18,")"));offset&&(expr.offset=offset);return expr}function midPoint($jscomp$destructuring$var19){var {channel,
channelDef,channel2Def,markDef,config,scaleName,scale,stack,offset,defaultRef,band}=$jscomp$destructuring$var19;if(channelDef){if(isFieldOrDatumDef(channelDef)){var _ref,_band2;if(isTypedFieldDef(channelDef)){var _band;band=null!==(_band=band)&&void 0!==_band?_band:getBand({channel,fieldDef:channelDef,fieldDef2:channel2Def,markDef,stack,config,isMidPoint:!0});const {bin,timeUnit,type}=channelDef;if(isBinning(bin)||band&&timeUnit&&"temporal"===type)return stack&&stack.impute?valueRefForFieldOrDatumDef(channelDef,
scaleName,{binSuffix:"mid"},{offset}):band?interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,band,offset}):valueRefForFieldOrDatumDef(channelDef,scaleName,binRequiresRange(channelDef,channel)?{binSuffix:"range"}:{},{offset});if(isBinned(bin)){if(isFieldDef(channel2Def))return interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,fieldOrDatumDef2:channel2Def,band,offset});warn(channelRequiredForBinned("x"===channel?"x2":"y2"))}}$jscomp$destructuring$var19=null===scale||void 0===scale?
void 0:scale.get("type");return valueRefForFieldOrDatumDef(channelDef,scaleName,$jscomp$destructuring$var19 in DISCRETE_DOMAIN_INDEX?{binSuffix:"range"}:{},{offset,band:"band"===$jscomp$destructuring$var19?null!==(_ref=null!==(_band2=band)&&void 0!==_band2?_band2:channelDef.band)&&void 0!==_ref?_ref:.5:void 0})}if(isValueDef(channelDef))return _ref=offset?{offset}:{},Object.assign({},widthHeightValueOrSignalRef(channel,channelDef.value),_ref)}"function"===typeof defaultRef&&(defaultRef=defaultRef());
return defaultRef?Object.assign({},defaultRef,offset?{offset}:{}):defaultRef}function widthHeightValueOrSignalRef(channel,value){return contains(["x","x2"],channel)&&"width"===value?{field:{group:"width"}}:contains(["y","y2"],channel)&&"height"===value?{field:{group:"height"}}:signalOrValueRef(value)}function isCustomFormatType(formatType){return formatType&&"number"!==formatType&&"time"!==formatType}function customFormatExpr(formatType,field,format){return"".concat(formatType,"(").concat(field).concat(format?
", ".concat(JSON.stringify(format)):"",")")}function formatSignalRef($jscomp$destructuring$var20){var {fieldOrDatumDef,format,formatType,expr,normalizeStack,config}=$jscomp$destructuring$var20;if(isCustomFormatType(formatType))return formatCustomType({fieldOrDatumDef,format,formatType,expr,config});$jscomp$destructuring$var20=fieldToFormat(fieldOrDatumDef,expr,normalizeStack);if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)){var _normalizeTimeUnit,_fieldOrDatumDef$scal;var timeUnit=isFieldDef(fieldOrDatumDef)?
null===(_normalizeTimeUnit=normalizeTimeUnit(fieldOrDatumDef.timeUnit))||void 0===_normalizeTimeUnit?void 0:_normalizeTimeUnit.unit:void 0,format$jscomp$0=format,rawTimeFormat=config.timeFormat;_normalizeTimeUnit=isScaleFieldDef(fieldOrDatumDef)&&(null===(_fieldOrDatumDef$scal=fieldOrDatumDef.scale)||void 0===_fieldOrDatumDef$scal?void 0:_fieldOrDatumDef$scal.type)===ScaleType.UTC;!timeUnit||format$jscomp$0?(format$jscomp$0=isString(format$jscomp$0)?format$jscomp$0:rawTimeFormat,$jscomp$destructuring$var20=
"".concat(_normalizeTimeUnit?"utc":"time","Format(").concat($jscomp$destructuring$var20,", '").concat(format$jscomp$0,"')")):timeUnit?(_fieldOrDatumDef$scal=timeUnitSpecifierExpression(timeUnit),timeUnit=_normalizeTimeUnit||timeUnit.startsWith("utc"),$jscomp$destructuring$var20="".concat(timeUnit?"utc":"time","Format(").concat($jscomp$destructuring$var20,", ").concat(_fieldOrDatumDef$scal,")")):$jscomp$destructuring$var20=void 0;return $jscomp$destructuring$var20?{signal:$jscomp$destructuring$var20}:
void 0}format=numberFormat(channelDefType(fieldOrDatumDef),format,config);return isFieldDef(fieldOrDatumDef)&&isBinning(fieldOrDatumDef.bin)?(_fieldOrDatumDef$scal=vgField(fieldOrDatumDef,{expr,binSuffix:"end"}),{signal:binFormatExpression($jscomp$destructuring$var20,_fieldOrDatumDef$scal,format,formatType,config)}):format||"quantitative"===channelDefType(fieldOrDatumDef)?{signal:"".concat(formatExpr($jscomp$destructuring$var20,format))}:{signal:"isValid(".concat($jscomp$destructuring$var20,") ? ").concat($jscomp$destructuring$var20,
' : ""+').concat($jscomp$destructuring$var20)}}function fieldToFormat(fieldOrDatumDef,expr,normalizeStack){if(isFieldDef(fieldOrDatumDef))return normalizeStack?"".concat(vgField(fieldOrDatumDef,{expr,suffix:"end"}),"-").concat(vgField(fieldOrDatumDef,{expr,suffix:"start"})):vgField(fieldOrDatumDef,{expr});({datum:fieldOrDatumDef}=fieldOrDatumDef);fieldOrDatumDef=isDateTime(fieldOrDatumDef)?dateTimeToExpr(fieldOrDatumDef):"".concat(JSON.stringify(fieldOrDatumDef));return fieldOrDatumDef}function formatCustomType($jscomp$destructuring$var21){var {fieldOrDatumDef,
format,formatType,expr,normalizeStack,config,field}=$jscomp$destructuring$var21,_field;field=null!==(_field=field)&&void 0!==_field?_field:fieldToFormat(fieldOrDatumDef,expr,normalizeStack);return isFieldDef(fieldOrDatumDef)&&isBinning(fieldOrDatumDef.bin)?($jscomp$destructuring$var21=vgField(fieldOrDatumDef,{expr,binSuffix:"end"}),{signal:binFormatExpression(field,$jscomp$destructuring$var21,format,formatType,config)}):{signal:customFormatExpr(formatType,field,format)}}function guideFormat(fieldOrDatumDef,
type,format,formatType,config,omitTimeFormatConfig){if(!isCustomFormatType(formatType)){if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)){var _normalizeTimeUnit2;fieldOrDatumDef=isFieldDef(fieldOrDatumDef)?null===(_normalizeTimeUnit2=normalizeTimeUnit(fieldOrDatumDef.timeUnit))||void 0===_normalizeTimeUnit2?void 0:_normalizeTimeUnit2.unit:void 0;format=format?format:fieldOrDatumDef?{signal:timeUnitSpecifierExpression(fieldOrDatumDef)}:omitTimeFormatConfig?void 0:config.timeFormat;return format}return numberFormat(type,
format,config)}}function guideFormatType(formatType,fieldOrDatumDef,scaleType){if(formatType&&(isSignalRef(formatType)||"number"===formatType||"time"===formatType))return formatType;if(isFieldOrDatumDefForTimeFormat(fieldOrDatumDef)&&"time"!==scaleType&&"utc"!==scaleType)return"time"}function numberFormat(type,specifiedFormat,config){if(isString(specifiedFormat))return specifiedFormat;if("quantitative"===type)return config.numberFormat}function formatExpr(field,format){return"format(".concat(field,
', "').concat(format||"",'")')}function binNumberFormatExpr(field,format,formatType,config){var _ref;return isCustomFormatType(formatType)?customFormatExpr(formatType,field,format):formatExpr(field,null!==(_ref=isString(format)?format:void 0)&&void 0!==_ref?_ref:config.numberFormat)}function binFormatExpression(startField,endField,format,formatType,config){const start=binNumberFormatExpr(startField,format,formatType,config);endField=binNumberFormatExpr(endField,format,formatType,config);return"".concat(fieldValidPredicate(startField,
!1),' ? "null" : ').concat(start,' + "').concat(" â€“ ",'" + ').concat(endField)}function isSortField(sort){return!!sort&&("count"===sort.op||!!sort.field)}function isSortArray(sort){return!!sort&&isArray(sort)}function isFacetMapping(f){return"row"in f||"column"in f}function toFieldDefBase(fieldDef){const {field,timeUnit,bin,aggregate}=fieldDef;return Object.assign({},timeUnit?{timeUnit}:{},bin?{bin}:{},aggregate?{aggregate}:{},{field})}function getBand($jscomp$destructuring$var22){var {channel,fieldDef,
fieldDef2,markDef:mark,stack,config,isMidPoint}=$jscomp$destructuring$var22;if(isFieldOrDatumDef(fieldDef)&&void 0!==fieldDef.band)return fieldDef.band;if(isFieldDef(fieldDef)){const {timeUnit,bin}=fieldDef;if(timeUnit&&!fieldDef2)return isMidPoint?getMarkConfig("timeUnitBandPosition",mark,config):contains(["rect","bar","image","arc"],mark.type)?getMarkConfig("timeUnitBand",mark,config):0;if(isBinning(bin))return contains(["rect","bar","image","arc"],mark.type)&&!isMidPoint?1:.5}if((null===stack||
void 0===stack?void 0:stack.fieldChannel)===channel&&isMidPoint)return.5}function hasBand(channel,fieldDef,fieldDef2,stack,markDef,config){return isBinning(fieldDef.bin)||fieldDef.timeUnit&&isTypedFieldDef(fieldDef)&&"temporal"===fieldDef.type?!!getBand({channel,fieldDef,fieldDef2,stack,markDef,config}):!1}function hasConditionalFieldDef(channelDef){channelDef=channelDef&&channelDef.condition;return!!channelDef&&!isArray(channelDef)&&isFieldDef(channelDef)}function hasConditionalFieldOrDatumDef(channelDef){channelDef=
channelDef&&channelDef.condition;return!!channelDef&&!isArray(channelDef)&&isFieldOrDatumDef(channelDef)}function isFieldDef(channelDef){return!!channelDef&&(!!channelDef.field||"count"===channelDef.aggregate)}function channelDefType(channelDef){return channelDef&&channelDef.type}function isDatumDef(channelDef){return!!channelDef&&"datum"in channelDef}function isContinuousFieldOrDatumDef(cd){return isTypedFieldDef(cd)&&!isDiscrete(cd)||isNumericDataDef(cd)}function isNumericDataDef(cd){return isDatumDef(cd)&&
isNumber(cd.datum)}function isFieldOrDatumDef(channelDef){return isFieldDef(channelDef)||isDatumDef(channelDef)}function isTypedFieldDef(channelDef){return!!channelDef&&("field"in channelDef||"count"===channelDef.aggregate)&&"type"in channelDef}function isValueDef(channelDef){return channelDef&&"value"in channelDef&&"value"in channelDef}function isScaleFieldDef(channelDef){return!!channelDef&&("scale"in channelDef||"sort"in channelDef)}function isPositionFieldOrDatumDef(channelDef){return channelDef&&
("axis"in channelDef||"stack"in channelDef||"impute"in channelDef)}function isStringFieldOrDatumDef(channelDef){return!!channelDef&&("format"in channelDef||"formatType"in channelDef)}function toStringFieldDef(fieldDef){return omit(fieldDef,["legend","axis","header","scale"])}function vgField(fieldDef,opt){opt=void 0===opt?{}:opt;let field=fieldDef.field;const prefix=opt.prefix;let suffix=opt.suffix,argAccessor="";if("count"===fieldDef.aggregate)field=internalField("count");else{let fn;if(!opt.nofn)if("op"in
fieldDef)fn=fieldDef.op;else{const {bin,aggregate,timeUnit}=fieldDef;if(isBinning(bin)){var _opt$binSuffix,_opt$suffix;fn=binToString(bin);suffix=(null!==(_opt$binSuffix=opt.binSuffix)&&void 0!==_opt$binSuffix?_opt$binSuffix:"")+(null!==(_opt$suffix=opt.suffix)&&void 0!==_opt$suffix?_opt$suffix:"")}else if(aggregate)isArgmaxDef(aggregate)?(argAccessor='["'.concat(field,'"]'),field="argmax_".concat(aggregate.argmax)):isArgminDef(aggregate)?(argAccessor='["'.concat(field,'"]'),field="argmin_".concat(aggregate.argmin)):
fn=String(aggregate);else if(timeUnit){var _opt$suffix2;fn=timeUnitToString(timeUnit);suffix=(!contains(["range","mid"],opt.binSuffix)&&opt.binSuffix||"")+(null!==(_opt$suffix2=opt.suffix)&&void 0!==_opt$suffix2?_opt$suffix2:"")}}fn&&(field=field?"".concat(fn,"_").concat(field):fn)}suffix&&(field="".concat(field,"_").concat(suffix));prefix&&(field="".concat(prefix,"_").concat(field));return opt.forAs?removePathFromField(field):opt.expr?flatAccessWithDatum(field,opt.expr)+argAccessor:replacePathInField(field)+
argAccessor}function isDiscrete(def){switch(def.type){case "nominal":case "ordinal":case "geojson":return!0;case "quantitative":return isFieldDef(def)&&!!def.bin;case "temporal":return!1}throw Error('Invalid field type "'.concat(def.type,'".'));}function verbalTitleFormatter(fieldDef,config){const {field,bin,timeUnit,aggregate}=fieldDef;if("count"===aggregate)return config.countTitle;if(isBinning(bin))return"".concat(field," (binned)");if(timeUnit){var _normalizeTimeUnit;if(fieldDef=null===(_normalizeTimeUnit=
normalizeTimeUnit(timeUnit))||void 0===_normalizeTimeUnit?void 0:_normalizeTimeUnit.unit)return"".concat(field," (").concat(getTimeUnitParts(fieldDef).join("-"),")")}else if(aggregate)return isArgmaxDef(aggregate)?"".concat(field," for max ").concat(aggregate.argmax):isArgminDef(aggregate)?"".concat(field," for min ").concat(aggregate.argmin):"".concat(titleCase(aggregate)," of ").concat(field);return field}function title$jscomp$0(fieldOrDatumDef,config,$jscomp$destructuring$var23){var {allowDisabling,
includeDefault=!0}=$jscomp$destructuring$var23,_getGuide;$jscomp$destructuring$var23=null===(_getGuide=getGuide(fieldOrDatumDef))||void 0===_getGuide?void 0:_getGuide.title;if(!isFieldDef(fieldOrDatumDef))return $jscomp$destructuring$var23;config=includeDefault?titleFormatter(fieldOrDatumDef,config):void 0;if(allowDisabling)return getFirstDefined($jscomp$destructuring$var23,fieldOrDatumDef.title,config);var _ref;return null!==(_ref=null!==$jscomp$destructuring$var23&&void 0!==$jscomp$destructuring$var23?
$jscomp$destructuring$var23:fieldOrDatumDef.title)&&void 0!==_ref?_ref:config}function getGuide(fieldDef){if(isPositionFieldOrDatumDef(fieldDef)&&fieldDef.axis)return fieldDef.axis;if(fieldDef&&"legend"in fieldDef&&fieldDef.legend)return fieldDef.legend;if(fieldDef&&"header"in fieldDef&&fieldDef.header)return fieldDef.header}function getFormatMixins(fieldDef){if(isStringFieldOrDatumDef(fieldDef)){const {format,formatType}=fieldDef;return{format,formatType}}{var _getGuide2;fieldDef=null!==(_getGuide2=
getGuide(fieldDef))&&void 0!==_getGuide2?_getGuide2:{};const {format,formatType}=fieldDef;return{format,formatType}}}function defaultType(fieldDef,channel){var _fieldDef$scale;switch(channel){case "latitude":case "longitude":return"quantitative";case "row":case "column":case "facet":case "shape":case "strokeDash":return"nominal";case "order":return"ordinal"}if("sort"in fieldDef&&isArray(fieldDef.sort))return"ordinal";const {aggregate,bin,timeUnit}=fieldDef;if(timeUnit)return"temporal";if(bin||aggregate&&
!isArgmaxDef(aggregate)&&!isArgminDef(aggregate))return"quantitative";if(isScaleFieldDef(fieldDef)&&(null===(_fieldDef$scale=fieldDef.scale)||void 0===_fieldDef$scale?0:_fieldDef$scale.type))switch(SCALE_CATEGORY_INDEX[fieldDef.scale.type]){case "numeric":case "discretizing":return"quantitative";case "time":return"temporal"}return"nominal"}function getFieldDef(channelDef){if(isFieldDef(channelDef))return channelDef;if(hasConditionalFieldDef(channelDef))return channelDef.condition}function getFieldOrDatumDef(channelDef){if(isFieldOrDatumDef(channelDef))return channelDef;
if(hasConditionalFieldOrDatumDef(channelDef))return channelDef.condition}function initChannelDef(channelDef,channel,config,opt){opt=void 0===opt?{}:opt;return isString(channelDef)||isNumber(channelDef)||isBoolean(channelDef)?(config=isString(channelDef)?"string":isNumber(channelDef)?"number":"boolean",channel="Channel ".concat(channel," is a ").concat(config,". Converted to {value: ").concat(stringify(channelDef),"}."),warn(channel),{value:channelDef}):isFieldOrDatumDef(channelDef)?initFieldOrDatumDef(channelDef,
channel,config,opt):hasConditionalFieldOrDatumDef(channelDef)?Object.assign({},channelDef,{condition:initFieldOrDatumDef(channelDef.condition,channel,config,opt)}):channelDef}function initFieldOrDatumDef(fd,channel,config,opt){if(isStringFieldOrDatumDef(fd)){var $jscomp$destructuring$var25=Object.assign({},fd),formatType=fd.formatType;$jscomp$destructuring$var25=(delete $jscomp$destructuring$var25.format,delete $jscomp$destructuring$var25.formatType,$jscomp$destructuring$var25);if(isCustomFormatType(formatType)&&
!config.customFormatTypes)return warn(customFormatTypeNotAllowed(channel)),initFieldOrDatumDef($jscomp$destructuring$var25,channel,config,opt)}else if((formatType=isPositionFieldOrDatumDef(fd)?"axis":fd&&"legend"in fd?"legend":fd&&"header"in fd?"header":null)&&fd[formatType]){var $jscomp$destructuring$var26=fd[formatType];$jscomp$destructuring$var25=Object.assign({},$jscomp$destructuring$var26);$jscomp$destructuring$var26=$jscomp$destructuring$var26.formatType;$jscomp$destructuring$var25=(delete $jscomp$destructuring$var25.format,
delete $jscomp$destructuring$var25.formatType,$jscomp$destructuring$var25);if(isCustomFormatType($jscomp$destructuring$var26)&&!config.customFormatTypes)return warn(customFormatTypeNotAllowed(channel)),initFieldOrDatumDef(Object.assign({},fd,{[formatType]:$jscomp$destructuring$var25}),channel,config,opt)}if(isFieldDef(fd))return initFieldDef(fd,channel,opt);channel=fd.type;channel||({datum:channel}=fd,channel=isNumber(channel)?"quantitative":isString(channel)?"nominal":isDateTime(channel)?"temporal":
void 0,fd=Object.assign({},fd,{type:channel}));return fd}function initFieldDef(fd,channel,$jscomp$destructuring$var28){({compositeMark:$jscomp$destructuring$var28=!1}=void 0===$jscomp$destructuring$var28?{}:$jscomp$destructuring$var28);const {aggregate,timeUnit,bin,field}=fd;fd=Object.assign({},fd);$jscomp$destructuring$var28||!aggregate||isAggregateOp(aggregate)||isArgmaxDef(aggregate)||isArgminDef(aggregate)||(warn('Invalid aggregation operator "'.concat(aggregate,'".')),delete fd.aggregate);timeUnit&&
(fd.timeUnit=normalizeTimeUnit(timeUnit));field&&(fd.field="".concat(field));isBinning(bin)&&(fd.bin=normalizeBin(bin,channel));!isBinned(bin)||channel in POSITION_SCALE_CHANNEL_INDEX||warn("Channel ".concat(channel,' should not be used with "binned" bin.'));if(isTypedFieldDef(fd)){({type:$jscomp$destructuring$var28}=fd);var fullType=getFullName($jscomp$destructuring$var28);$jscomp$destructuring$var28!==fullType&&(fd.type=fullType);"quantitative"!==$jscomp$destructuring$var28&&isCountingAggregateOp(aggregate)&&
($jscomp$destructuring$var28='Invalid field type "'.concat($jscomp$destructuring$var28,'" for aggregate: "').concat(aggregate,'", using "quantitative" instead.'),warn($jscomp$destructuring$var28),fd.type="quantitative")}else isSecondaryRangeChannel(channel)||($jscomp$destructuring$var28=defaultType(fd,channel),fd.type=$jscomp$destructuring$var28);if(isTypedFieldDef(fd)){const {compatible,warning}=channelCompatibility(fd,channel)||{};!1===compatible&&warn(warning)}if("sort"in fd&&isString(fd.sort)){({sort:channel}=
fd);if(channel in SORT_BY_CHANNEL_INDEX)return Object.assign({},fd,{sort:{encoding:channel}});$jscomp$destructuring$var28=channel.substr(1);if("-"===channel.charAt(0)&&$jscomp$destructuring$var28 in SORT_BY_CHANNEL_INDEX)return Object.assign({},fd,{sort:{encoding:$jscomp$destructuring$var28,order:"descending"}})}return fd&&"header"in fd&&({header:channel}=fd,fullType=channel,$jscomp$destructuring$var28=Object.assign({},fullType),fullType=fullType.orient,$jscomp$destructuring$var28=(delete $jscomp$destructuring$var28.orient,
$jscomp$destructuring$var28),fullType)?Object.assign({},fd,{header:Object.assign({},$jscomp$destructuring$var28,{labelOrient:channel.labelOrient||fullType,titleOrient:channel.titleOrient||fullType})}):fd}function normalizeBin(bin,channel){return isBoolean(bin)?{maxbins:autoMaxBins(channel)}:"binned"===bin?{binned:!0}:bin.maxbins||bin.step?bin:Object.assign({},bin,{maxbins:autoMaxBins(channel)})}function channelCompatibility(fieldDef,channel){const type=fieldDef.type;if("geojson"===type&&"shape"!==
channel)return{compatible:!1,warning:"Channel ".concat(channel," should not be used with a geojson data.")};switch(channel){case "row":case "column":case "facet":return isDiscrete(fieldDef)?COMPATIBLE:{compatible:!1,warning:"".concat(channel," encoding should be discrete (ordinal / nominal / binned).")};case "x":case "y":case "color":case "fill":case "stroke":case "text":case "detail":case "key":case "tooltip":case "href":case "url":case "angle":case "theta":case "radius":case "description":return COMPATIBLE;
case "longitude":case "longitude2":case "latitude":case "latitude2":return"quantitative"!==type?{compatible:!1,warning:"Channel ".concat(channel," should be used with a quantitative field only, not ").concat(fieldDef.type," field.")}:COMPATIBLE;case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeWidth":case "size":case "theta2":case "radius2":case "x2":case "y2":return"nominal"!==type||fieldDef.sort?COMPATIBLE:{compatible:!1,warning:"Channel ".concat(channel," should not be used with an unsorted discrete field.")};
case "strokeDash":return contains(["ordinal","nominal"],fieldDef.type)?COMPATIBLE:{compatible:!1,warning:"StrokeDash channel should be used with only discrete data."};case "shape":return contains(["ordinal","nominal","geojson"],fieldDef.type)?COMPATIBLE:{compatible:!1,warning:"Shape channel should be used with only either discrete or geojson data."};case "order":return"nominal"!==fieldDef.type||"sort"in fieldDef?COMPATIBLE:{compatible:!1,warning:"Channel order is inappropriate for nominal field, which has no inherent order."}}}
function isFieldOrDatumDefForTimeFormat(fieldOrDatumDef){var {formatType}=getFormatMixins(fieldOrDatumDef),JSCompiler_temp;if(!(JSCompiler_temp="time"===formatType)){if(formatType=!formatType)formatType=fieldOrDatumDef&&("temporal"===fieldOrDatumDef.type||isFieldDef(fieldOrDatumDef)&&!!fieldOrDatumDef.timeUnit);JSCompiler_temp=formatType}return JSCompiler_temp}function valueExpr(v,$jscomp$destructuring$var31){var {timeUnit,type,wrapTime,undefinedIfExprNotRequired}=$jscomp$destructuring$var31;var _normalizeTimeUnit2=
($jscomp$destructuring$var31=timeUnit&&(null===(_normalizeTimeUnit2=normalizeTimeUnit(timeUnit))||void 0===_normalizeTimeUnit2?void 0:_normalizeTimeUnit2.unit))||"temporal"===type;let expr;isExprRef(v)?expr=v.expr:isSignalRef(v)?expr=v.signal:isDateTime(v)?(_normalizeTimeUnit2=!0,expr=dateTimeToExpr(v)):(isString(v)||isNumber(v))&&_normalizeTimeUnit2&&(expr="datetime(".concat(JSON.stringify(v),")"),LOCAL_SINGLE_TIMEUNIT_INDEX[$jscomp$destructuring$var31]&&(isNumber(v)&&1E4>v||isString(v)&&isNaN(Date.parse(v)))&&
(expr=dateTimeToExpr({[$jscomp$destructuring$var31]:v})));return expr?wrapTime&&_normalizeTimeUnit2?"time(".concat(expr,")"):expr:undefinedIfExprNotRequired?void 0:JSON.stringify(v)}function valueArray(fieldOrDatumDef,values){const {type}=fieldOrDatumDef;return values.map(v=>{const expr=valueExpr(v,{timeUnit:isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.timeUnit:void 0,type,undefinedIfExprNotRequired:!0});return void 0!==expr?{signal:expr}:v})}function binRequiresRange(fieldDef,channel){return isBinning(fieldDef.bin)?
!!SCALE_CHANNEL_INDEX[channel]&&contains(["ordinal","nominal"],fieldDef.type):(console.warn("Only call this method for binned field defs."),!1)}function extractTitleConfig(titleConfig){var $jscomp$destructuring$var33=Object.assign({},titleConfig),anchor=titleConfig.anchor;const frame=titleConfig.frame,offset=titleConfig.offset,orient=titleConfig.orient;var color=titleConfig.color,subtitleColor=titleConfig.subtitleColor,subtitleFont=titleConfig.subtitleFont;const subtitleFontSize=titleConfig.subtitleFontSize,
subtitleFontStyle=titleConfig.subtitleFontStyle,subtitleFontWeight=titleConfig.subtitleFontWeight,subtitleLineHeight=titleConfig.subtitleLineHeight;titleConfig=titleConfig.subtitlePadding;$jscomp$destructuring$var33=(delete $jscomp$destructuring$var33.anchor,delete $jscomp$destructuring$var33.frame,delete $jscomp$destructuring$var33.offset,delete $jscomp$destructuring$var33.orient,delete $jscomp$destructuring$var33.color,delete $jscomp$destructuring$var33.subtitleColor,delete $jscomp$destructuring$var33.subtitleFont,
delete $jscomp$destructuring$var33.subtitleFontSize,delete $jscomp$destructuring$var33.subtitleFontStyle,delete $jscomp$destructuring$var33.subtitleFontWeight,delete $jscomp$destructuring$var33.subtitleLineHeight,delete $jscomp$destructuring$var33.subtitlePadding,$jscomp$destructuring$var33);color=Object.assign({},$jscomp$destructuring$var33,color?{fill:color}:{});anchor=Object.assign({},anchor?{anchor}:{},frame?{frame}:{},offset?{offset}:{},orient?{orient}:{});subtitleColor=Object.assign({},subtitleColor?
{subtitleColor}:{},subtitleFont?{subtitleFont}:{},subtitleFontSize?{subtitleFontSize}:{},subtitleFontStyle?{subtitleFontStyle}:{},subtitleFontWeight?{subtitleFontWeight}:{},subtitleLineHeight?{subtitleLineHeight}:{},titleConfig?{subtitlePadding:titleConfig}:{});subtitleFont=pick(color,["align","baseline","dx","dy","limit"]);return{titleMarkConfig:color,subtitleMarkConfig:subtitleFont,nonMark:anchor,subtitle:subtitleColor}}function isText(v){return isString(v)||isArray(v)&&isString(v[0])}function signalOrValueRefWithCondition(val){const condition=
isArray(val.condition)?val.condition.map(conditionalSignalRefOrValue):conditionalSignalRefOrValue(val.condition);return Object.assign({},signalRefOrValue(val),{condition})}function signalRefOrValue(value){if(isExprRef(value)){var $jscomp$destructuring$var35=Object.assign({},value);value=value.expr;$jscomp$destructuring$var35=(delete $jscomp$destructuring$var35.expr,$jscomp$destructuring$var35);return Object.assign({},{signal:value},$jscomp$destructuring$var35)}return value}function conditionalSignalRefOrValue(value){if(isExprRef(value)){var $jscomp$destructuring$var37=
Object.assign({},value);value=value.expr;$jscomp$destructuring$var37=(delete $jscomp$destructuring$var37.expr,$jscomp$destructuring$var37);return Object.assign({},{signal:value},$jscomp$destructuring$var37)}return value}function signalOrValueRef(value){if(isExprRef(value)){var $jscomp$destructuring$var39=Object.assign({},value);value=value.expr;$jscomp$destructuring$var39=(delete $jscomp$destructuring$var39.expr,$jscomp$destructuring$var39);return Object.assign({},{signal:value},$jscomp$destructuring$var39)}return isSignalRef(value)?
value:void 0!==value?{value}:void 0}function exprFromValueOrSignalRef(ref){return isSignalRef(ref)?ref.signal:$(ref.value)}function signalOrStringValue(v){return isSignalRef(v)?v.signal:null==v?null:$(v)}function applyMarkConfig(e,model,propsList){for(const property of propsList)propsList=getMarkConfig(property,model.markDef,model.config),void 0!==propsList&&(e[property]=signalOrValueRef(propsList));return e}function getStyles(mark){var _mark$style;return[].concat(mark.type,null!==(_mark$style=mark.style)&&
void 0!==_mark$style?_mark$style:[])}function getMarkPropOrConfig(channel,mark,config,opt){opt=void 0===opt?{}:opt;const {vgChannel,ignoreVgConfig}=opt;if(vgChannel&&void 0!==mark[vgChannel])return mark[vgChannel];if(void 0!==mark[channel])return mark[channel];if(!ignoreVgConfig||vgChannel&&vgChannel!==channel)return getMarkConfig(channel,mark,config,opt)}function getMarkConfig(channel,mark,config,$jscomp$destructuring$var40){({vgChannel:$jscomp$destructuring$var40}=void 0===$jscomp$destructuring$var40?
{}:$jscomp$destructuring$var40);return getFirstDefined($jscomp$destructuring$var40?getMarkStyleConfig(channel,mark,config.style):void 0,getMarkStyleConfig(channel,mark,config.style),$jscomp$destructuring$var40?config[mark.type][$jscomp$destructuring$var40]:void 0,config[mark.type][channel],$jscomp$destructuring$var40?config.mark[$jscomp$destructuring$var40]:config.mark[channel])}function getMarkStyleConfig(prop,mark,styleConfigIndex){return getStyleConfig(prop,getStyles(mark),styleConfigIndex)}function getStyleConfig(p,
styles,styleConfigIndex){styles=array$jscomp$0(styles);let value;for(const style of styles)(styles=styleConfigIndex[style])&&void 0!==styles[p]&&(value=styles[p]);return value}function sortParams(orderDef,fieldRefOption){return array$jscomp$0(orderDef).reduce((s,orderChannelDef)=>{var _orderChannelDef$sort;s.field.push(vgField(orderChannelDef,fieldRefOption));s.order.push(null!==(_orderChannelDef$sort=orderChannelDef.sort)&&void 0!==_orderChannelDef$sort?_orderChannelDef$sort:"ascending");return s},
{field:[],order:[]})}function mergeTitleFieldDefs(f1,f2){const merged=[...f1];f2.forEach(fdToMerge=>{for(const fieldDef1 of merged)if(deepEqual(fieldDef1,fdToMerge))return;merged.push(fdToMerge)});return merged}function mergeTitle(title1,title2){return deepEqual(title1,title2)||!title2?title1:title1?[...array$jscomp$0(title1),...array$jscomp$0(title2)].join(", "):title2}function mergeTitleComponent(v1,v2){const v1Val=v1.value;v2=v2.value;if(null==v1Val||null===v2)return{explicit:v1.explicit,value:null};
if((isText(v1Val)||isSignalRef(v1Val))&&(isText(v2)||isSignalRef(v2)))return{explicit:v1.explicit,value:mergeTitle(v1Val,v2)};if(isText(v1Val)||isSignalRef(v1Val))return{explicit:v1.explicit,value:v1Val};if(isText(v2)||isSignalRef(v2))return{explicit:v1.explicit,value:v2};if(!(isText(v1Val)||isSignalRef(v1Val)||isText(v2)||isSignalRef(v2)))return{explicit:v1.explicit,value:mergeTitleFieldDefs(v1Val,v2)};throw Error("It should never reach here");}function isUnitSpec(spec){return"mark"in spec}function channelHasField(encoding,
channel){return(encoding=encoding&&encoding[channel])?isArray(encoding)?some(encoding,fieldDef=>!!fieldDef.field):isFieldDef(encoding)||hasConditionalFieldDef(encoding):!1}function isAggregate(encoding){return some(CHANNELS,channel=>channelHasField(encoding,channel)?(channel=encoding[channel],isArray(channel)?some(channel,fieldDef=>!!fieldDef.aggregate):(channel=getFieldDef(channel))&&!!channel.aggregate):!1)}function extractTransformsFromEncoding(oldEncoding,config){const groupby=[],bins=[],timeUnits=
[],aggregate=[],encoding={};forEach(oldEncoding,(channelDef,channel)=>{if(isFieldDef(channelDef)){var $jscomp$destructuring$var42=Object.assign({},channelDef),field=channelDef.field;const aggOp=channelDef.aggregate,bin=channelDef.bin,timeUnit=channelDef.timeUnit;$jscomp$destructuring$var42=(delete $jscomp$destructuring$var42.field,delete $jscomp$destructuring$var42.aggregate,delete $jscomp$destructuring$var42.bin,delete $jscomp$destructuring$var42.timeUnit,$jscomp$destructuring$var42);if(aggOp||timeUnit||
bin){var guide=getGuide(channelDef);const isTitleDefined=guide&&guide.title;guide=vgField(channelDef,{forAs:!0});$jscomp$destructuring$var42=Object.assign({},isTitleDefined?[]:{title:title$jscomp$0(channelDef,config,{allowDisabling:!0})},$jscomp$destructuring$var42,{field:guide});if(aggOp){let op;isArgmaxDef(aggOp)?(op="argmax",guide=vgField({op:"argmax",field:aggOp.argmax},{forAs:!0}),$jscomp$destructuring$var42.field="".concat(guide,".").concat(field)):isArgminDef(aggOp)?(op="argmin",guide=vgField({op:"argmin",
field:aggOp.argmin},{forAs:!0}),$jscomp$destructuring$var42.field="".concat(guide,".").concat(field)):"boxplot"!==aggOp&&"errorbar"!==aggOp&&"errorband"!==aggOp&&(op=aggOp);op&&(channelDef={op,as:guide},field&&(channelDef.field=field),aggregate.push(channelDef))}else groupby.push(guide),isTypedFieldDef(channelDef)&&isBinning(bin)?(bins.push({bin,field,as:guide}),groupby.push(vgField(channelDef,{binSuffix:"end"})),binRequiresRange(channelDef,channel)&&groupby.push(vgField(channelDef,{binSuffix:"range"})),
channel in POSITION_SCALE_CHANNEL_INDEX&&(encoding[channel+"2"]={field:guide+"_end"}),$jscomp$destructuring$var42.bin="binned",isSecondaryRangeChannel(channel)||($jscomp$destructuring$var42.type="quantitative")):timeUnit&&(timeUnits.push({timeUnit,field,as:guide}),(field=isTypedFieldDef(channelDef)&&"temporal"!==channelDef.type&&"time")&&("text"===channel||"tooltip"===channel?$jscomp$destructuring$var42.formatType=field:NONPOSITION_CHANNEL_INDEX[channel]?$jscomp$destructuring$var42.legend=Object.assign({},
{formatType:field},$jscomp$destructuring$var42.legend):channel in POSITION_SCALE_CHANNEL_INDEX&&($jscomp$destructuring$var42.axis=Object.assign({},{formatType:field},$jscomp$destructuring$var42.axis))));encoding[channel]=$jscomp$destructuring$var42}else groupby.push(field),encoding[channel]=oldEncoding[channel]}else encoding[channel]=oldEncoding[channel]});return{bins,timeUnits,aggregate,groupby,encoding}}function markChannelCompatible(encoding,channel,mark){mark=getSupportedMark(channel)[mark];return mark&&
("binned"!==mark||(mark=encoding["x2"===channel?"x":"y"],isFieldDef(mark)&&isFieldDef(encoding[channel])&&isBinned(mark.bin)))?!0:!1}function initEncoding(encoding,mark,filled,config){return keys$jscomp$0(encoding).reduce((normalizedEncoding,channel)=>{if(!CHANNEL_INDEX[channel])return warn(invalidEncodingChannel(channel)),normalizedEncoding;const channelDef=encoding[channel];"angle"!==channel||"arc"!==mark||encoding.theta||(warn("Arc marks uses theta channel rather than angle, replacing angle with theta."),
channel="theta");if(!markChannelCompatible(encoding,channel,mark))return warn(incompatibleChannel(channel,mark)),normalizedEncoding;if("size"===channel&&"line"===mark){const fieldDef=getFieldDef(encoding[channel]);if(null===fieldDef||void 0===fieldDef?0:fieldDef.aggregate)return warn("Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead."),normalizedEncoding}if("color"===channel&&(filled?"fill"in encoding:"stroke"in encoding))return warn(droppingColor("encoding",
{fill:"fill"in encoding,stroke:"stroke"in encoding})),normalizedEncoding;if("detail"===channel||"order"===channel&&!isArray(channelDef)&&!isValueDef(channelDef)||"tooltip"===channel&&isArray(channelDef))channelDef&&(normalizedEncoding[channel]=array$jscomp$0(channelDef).reduce((defs,fieldDef)=>{isFieldDef(fieldDef)?defs.push(initFieldDef(fieldDef,channel)):warn(emptyFieldDef(fieldDef,channel));return defs},[]));else{if("tooltip"===channel&&null===channelDef)normalizedEncoding[channel]=null;else if(!(isFieldDef(channelDef)||
isDatumDef(channelDef)||isValueDef(channelDef)||channelDef&&"condition"in channelDef||isSignalRef(channelDef)))return warn(emptyFieldDef(channelDef,channel)),normalizedEncoding;normalizedEncoding[channel]=initChannelDef(channelDef,channel,config)}return normalizedEncoding},{})}function normalizeEncoding(encoding,config){const normalizedEncoding={};for(const channel of keys$jscomp$0(encoding)){const newChannelDef=initChannelDef(encoding[channel],channel,config,{compositeMark:!0});normalizedEncoding[channel]=
newChannelDef}return normalizedEncoding}function fieldDefs(encoding){const arr=[];for(const channel of keys$jscomp$0(encoding))if(channelHasField(encoding,channel)){const channelDefArray=array$jscomp$0(encoding[channel]);for(const def of channelDefArray)isFieldDef(def)?arr.push(def):hasConditionalFieldDef(def)&&arr.push(def.condition)}return arr}function forEach(mapping,f,thisArg){if(mapping)for(const channel of keys$jscomp$0(mapping)){const el=mapping[channel];if(isArray(el))for(const channelDef of el)f.call(thisArg,
channelDef,channel);else f.call(thisArg,el,channel)}}function reduce(mapping,f,init,thisArg){return mapping?keys$jscomp$0(mapping).reduce((r,channel)=>{const map=mapping[channel];return isArray(map)?map.reduce((r1,channelDef)=>f.call(thisArg,r1,channelDef,channel),r):f.call(thisArg,r,map,channel)},init):init}function pathGroupingFields(mark,encoding){return keys$jscomp$0(encoding).reduce((details,channel)=>{switch(channel){case "x":case "y":case "href":case "description":case "url":case "x2":case "y2":case "theta":case "theta2":case "radius":case "radius2":case "latitude":case "longitude":case "latitude2":case "longitude2":case "text":case "shape":case "angle":case "tooltip":return details;
case "order":if("line"===mark||"trail"===mark)return details;case "detail":case "key":channel=encoding[channel];if(isArray(channel)||isFieldDef(channel))for(var fieldDef of array$jscomp$0(channel))fieldDef.aggregate||details.push(vgField(fieldDef,{}));return details;case "size":if("trail"===mark)return details;case "color":case "fill":case "stroke":case "opacity":case "fillOpacity":case "strokeOpacity":case "strokeDash":case "strokeWidth":return(fieldDef=getFieldDef(encoding[channel]))&&!fieldDef.aggregate&&
details.push(vgField(fieldDef,{})),details}},[])}function getCompositeMarkTooltip(tooltipSummary,continuousAxisChannelDef,encodingWithoutContinuousAxis,withFieldName){withFieldName=void 0===withFieldName?!0:withFieldName;if("tooltip"in encodingWithoutContinuousAxis)return{tooltip:encodingWithoutContinuousAxis.tooltip};tooltipSummary=tooltipSummary.map($jscomp$destructuring$var45=>{var {fieldPrefix,titlePrefix}=$jscomp$destructuring$var45;$jscomp$destructuring$var45=withFieldName?" of ".concat(getTitle(continuousAxisChannelDef)):
"";return{field:fieldPrefix+continuousAxisChannelDef.field,type:continuousAxisChannelDef.type,title:isSignalRef(titlePrefix)?{signal:titlePrefix+'"'.concat(escape($jscomp$destructuring$var45),'"')}:titlePrefix+$jscomp$destructuring$var45}});encodingWithoutContinuousAxis=fieldDefs(encodingWithoutContinuousAxis).map(toStringFieldDef);return{tooltip:[...tooltipSummary,...unique(encodingWithoutContinuousAxis,hash)]}}function getTitle(continuousAxisChannelDef){const {title,field}=continuousAxisChannelDef;
return getFirstDefined(title,field)}function makeCompositeAggregatePartFactory(compositeMarkDef,continuousAxis,continuousAxisChannelDef,sharedEncoding,compositeMarkConfig){const {scale,axis}=continuousAxisChannelDef;return $jscomp$destructuring$var46=>{var {partName,mark,positionPrefix,endPositionPrefix,extraEncoding={}}=$jscomp$destructuring$var46;$jscomp$destructuring$var46=getTitle(continuousAxisChannelDef);return partLayerMixins(compositeMarkDef,partName,compositeMarkConfig,{mark,encoding:Object.assign({},
{[continuousAxis]:Object.assign({},{field:positionPrefix+"_"+continuousAxisChannelDef.field,type:continuousAxisChannelDef.type},void 0!==$jscomp$destructuring$var46?{title:$jscomp$destructuring$var46}:{},void 0!==scale?{scale}:{},void 0!==axis?{axis}:{})},isString(endPositionPrefix)?{[continuousAxis+"2"]:{field:endPositionPrefix+"_"+continuousAxisChannelDef.field}}:{},sharedEncoding,extraEncoding)})}}function partLayerMixins(markDef,part,compositeMarkConfig,partBaseSpec){const {clip,color,opacity}=
markDef,mark=markDef.type;return markDef[part]||void 0===markDef[part]&&compositeMarkConfig[part]?[Object.assign({},partBaseSpec,{mark:Object.assign({},compositeMarkConfig[part],clip?{clip}:{},color?{color}:{},opacity?{opacity}:{},isMarkDef(partBaseSpec.mark)?partBaseSpec.mark:{type:partBaseSpec.mark},{style:"".concat(mark,"-").concat(part)},isBoolean(markDef[part])?{}:markDef[part])})]:[]}function compositeMarkContinuousAxis(spec,orient,compositeMark){({encoding:spec}=spec);orient="vertical"===orient?
"y":"x";const continuousAxisChannelDef2=spec[orient+"2"],continuousAxisChannelDefError=spec[orient+"Error"],continuousAxisChannelDefError2=spec[orient+"Error2"];return{continuousAxisChannelDef:filterAggregateFromChannelDef(spec[orient],compositeMark),continuousAxisChannelDef2:filterAggregateFromChannelDef(continuousAxisChannelDef2,compositeMark),continuousAxisChannelDefError:filterAggregateFromChannelDef(continuousAxisChannelDefError,compositeMark),continuousAxisChannelDefError2:filterAggregateFromChannelDef(continuousAxisChannelDefError2,
compositeMark),continuousAxis:orient}}function filterAggregateFromChannelDef(continuousAxisChannelDef,compositeMark){if(continuousAxisChannelDef&&continuousAxisChannelDef.aggregate){var $jscomp$destructuring$var48=Object.assign({},continuousAxisChannelDef);continuousAxisChannelDef=continuousAxisChannelDef.aggregate;$jscomp$destructuring$var48=(delete $jscomp$destructuring$var48.aggregate,$jscomp$destructuring$var48);continuousAxisChannelDef!==compositeMark&&(compositeMark="Continuous axis should not have customized aggregation function ".concat(continuousAxisChannelDef,
"; ").concat(compositeMark," already agregates the axis."),warn(compositeMark));return $jscomp$destructuring$var48}return continuousAxisChannelDef}function compositeMarkOrient(spec,compositeMark){const {mark,encoding}=spec,{x,y}=encoding;if(isMarkDef(mark)&&mark.orient)return mark.orient;if(isContinuousFieldOrDatumDef(x)){if(isContinuousFieldOrDatumDef(y)){spec=isFieldDef(x)&&x.aggregate;const yAggregate=isFieldDef(y)&&y.aggregate;if(!spec&&yAggregate===compositeMark)return"vertical";if(yAggregate||
spec!==compositeMark){if(spec===compositeMark&&yAggregate===compositeMark)throw Error("Both x and y cannot have aggregate");return isFieldOrDatumDefForTimeFormat(y)&&!isFieldOrDatumDefForTimeFormat(x)?"horizontal":"vertical"}}return"horizontal"}if(isContinuousFieldOrDatumDef(y))return"vertical";throw Error("Need a valid continuous axis for ".concat(compositeMark,"s"));}function getBoxPlotType(extent){return isNumber(extent)?"tukey":extent}function normalizeBoxPlot(spec$jscomp$0,$jscomp$destructuring$var49){var {config}=
$jscomp$destructuring$var49,_markDef$extent,$jscomp$destructuring$var50=spec$jscomp$0=Object.assign({},spec$jscomp$0,{encoding:normalizeEncoding(spec$jscomp$0.encoding,config)});$jscomp$destructuring$var49=Object.assign({},$jscomp$destructuring$var50);var mark=$jscomp$destructuring$var50.mark;$jscomp$destructuring$var50=$jscomp$destructuring$var50.selection;$jscomp$destructuring$var49=(delete $jscomp$destructuring$var49.mark,delete $jscomp$destructuring$var49.encoding,delete $jscomp$destructuring$var49.selection,
delete $jscomp$destructuring$var49.projection,$jscomp$destructuring$var49);mark=isMarkDef(mark)?mark:{type:mark};$jscomp$destructuring$var50&&warn(selectionNotSupported("boxplot"));$jscomp$destructuring$var50=null!==(_markDef$extent=mark.extent)&&void 0!==_markDef$extent?_markDef$extent:config.boxplot.extent;var sizeValue=getMarkPropOrConfig("size",mark,config);_markDef$extent=getBoxPlotType($jscomp$destructuring$var50);var JSCompiler_inline_result;{var spec=spec$jscomp$0;spec$jscomp$0=compositeMarkOrient(spec,
"boxplot");const {continuousAxisChannelDef,continuousAxis}=compositeMarkContinuousAxis(spec,spec$jscomp$0,"boxplot");var continuousFieldName=continuousAxisChannelDef.field,boxPlotType=getBoxPlotType($jscomp$destructuring$var50),boxplotSpecificAggregate=[...boxParamsQuartiles(continuousFieldName),{op:"median",field:continuousFieldName,as:"mid_box_"+continuousFieldName},{op:"min",field:continuousFieldName,as:("min-max"===boxPlotType?"lower_whisker_":"min_")+continuousFieldName},{op:"max",field:continuousFieldName,
as:("min-max"===boxPlotType?"upper_whisker_":"max_")+continuousFieldName}];continuousFieldName="min-max"===boxPlotType||"tukey"===boxPlotType?[]:[{calculate:'datum["upper_box_'.concat(continuousFieldName,'"] - datum["lower_box_').concat(continuousFieldName,'"]'),as:"iqr_"+continuousFieldName},{calculate:'min(datum["upper_box_'.concat(continuousFieldName,'"] + datum["iqr_').concat(continuousFieldName,'"] * ').concat($jscomp$destructuring$var50,', datum["max_').concat(continuousFieldName,'"])'),as:"upper_whisker_"+
continuousFieldName},{calculate:'max(datum["lower_box_'.concat(continuousFieldName,'"] - datum["iqr_').concat(continuousFieldName,'"] * ').concat($jscomp$destructuring$var50,', datum["min_').concat(continuousFieldName,'"])'),as:"lower_whisker_"+continuousFieldName}];spec=Object.assign({},spec.encoding);boxPlotType=(delete spec[continuousAxis],spec);spec=Object.assign({},boxPlotType);boxPlotType=boxPlotType.tooltip;spec=(delete spec.tooltip,spec);if(boxPlotType){var customTooltipWithoutAggregatedField$jscomp$0;
if(isArray(boxPlotType)){for(var t of boxPlotType)t.aggregate?(JSCompiler_inline_result||(JSCompiler_inline_result=[]),JSCompiler_inline_result.push(t)):(customTooltipWithoutAggregatedField$jscomp$0||(customTooltipWithoutAggregatedField$jscomp$0=[]),customTooltipWithoutAggregatedField$jscomp$0.push(t));JSCompiler_inline_result&&(spec.tooltip=JSCompiler_inline_result)}else boxPlotType.aggregate?spec.tooltip=boxPlotType:customTooltipWithoutAggregatedField$jscomp$0=boxPlotType;isArray(customTooltipWithoutAggregatedField$jscomp$0)&&
1===customTooltipWithoutAggregatedField$jscomp$0.length&&(customTooltipWithoutAggregatedField$jscomp$0=customTooltipWithoutAggregatedField$jscomp$0[0]);JSCompiler_inline_result={customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$0,filteredEncoding:spec}}else JSCompiler_inline_result={filteredEncoding:spec};const {customTooltipWithoutAggregatedField,filteredEncoding}=JSCompiler_inline_result,{bins,timeUnits,aggregate,groupby,encoding:encodingWithoutContinuousAxis}=extractTransformsFromEncoding(filteredEncoding,
config);JSCompiler_inline_result=[...bins,...timeUnits,{aggregate:[...aggregate,...boxplotSpecificAggregate],groupby},...continuousFieldName];JSCompiler_inline_result={bins,timeUnits,transform:JSCompiler_inline_result,groupby,aggregate,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,ticksOrient:"vertical"===spec$jscomp$0?"horizontal":"vertical",boxOrient:spec$jscomp$0,customTooltipWithoutAggregatedField}}const {bins:bins$jscomp$0,timeUnits:timeUnits$jscomp$0,transform,continuousAxisChannelDef:continuousAxisChannelDef$jscomp$0,
continuousAxis:continuousAxis$jscomp$0,groupby:groupby$jscomp$0,aggregate:aggregate$jscomp$0,encodingWithoutContinuousAxis:encodingWithoutContinuousAxis$jscomp$0,ticksOrient,boxOrient,customTooltipWithoutAggregatedField:customTooltipWithoutAggregatedField$jscomp$2}=JSCompiler_inline_result;customTooltipWithoutAggregatedField$jscomp$0=Object.assign({},encodingWithoutContinuousAxis$jscomp$0);JSCompiler_inline_result=encodingWithoutContinuousAxis$jscomp$0.color;boxplotSpecificAggregate=encodingWithoutContinuousAxis$jscomp$0.size;
customTooltipWithoutAggregatedField$jscomp$0=(delete customTooltipWithoutAggregatedField$jscomp$0.color,delete customTooltipWithoutAggregatedField$jscomp$0.size,customTooltipWithoutAggregatedField$jscomp$0);t=makeCompositeAggregatePartFactory(mark,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,customTooltipWithoutAggregatedField$jscomp$0,config.boxplot);spec$jscomp$0=makeCompositeAggregatePartFactory(mark,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0,
config.boxplot);boxplotSpecificAggregate=makeCompositeAggregatePartFactory(mark,continuousAxis$jscomp$0,continuousAxisChannelDef$jscomp$0,Object.assign({},customTooltipWithoutAggregatedField$jscomp$0,boxplotSpecificAggregate?{size:boxplotSpecificAggregate}:{}),config.boxplot);continuousFieldName=getCompositeMarkTooltip([{fieldPrefix:"min-max"===_markDef$extent?"upper_whisker_":"max_",titlePrefix:"Max"},{fieldPrefix:"upper_box_",titlePrefix:"Q3"},{fieldPrefix:"mid_box_",titlePrefix:"Median"},{fieldPrefix:"lower_box_",
titlePrefix:"Q1"},{fieldPrefix:"min-max"===_markDef$extent?"lower_whisker_":"min_",titlePrefix:"Min"}],continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0);spec={type:"tick",color:"black",opacity:1,orient:ticksOrient,invalid:null,aria:!1};boxPlotType="min-max"===_markDef$extent?continuousFieldName:getCompositeMarkTooltip([{fieldPrefix:"upper_whisker_",titlePrefix:"Upper Whisker"},{fieldPrefix:"lower_whisker_",titlePrefix:"Lower Whisker"}],continuousAxisChannelDef$jscomp$0,encodingWithoutContinuousAxis$jscomp$0);
t=[...t({partName:"rule",mark:{type:"rule",invalid:null,aria:!1},positionPrefix:"lower_whisker",endPositionPrefix:"lower_box",extraEncoding:boxPlotType}),...t({partName:"rule",mark:{type:"rule",invalid:null,aria:!1},positionPrefix:"upper_box",endPositionPrefix:"upper_whisker",extraEncoding:boxPlotType}),...t({partName:"ticks",mark:spec,positionPrefix:"lower_whisker",extraEncoding:boxPlotType}),...t({partName:"ticks",mark:spec,positionPrefix:"upper_whisker",extraEncoding:boxPlotType})];sizeValue=[..."tukey"!==
_markDef$extent?t:[],...spec$jscomp$0({partName:"box",mark:Object.assign({},{type:"bar"},sizeValue?{size:sizeValue}:{},{orient:boxOrient,invalid:null,ariaRoleDescription:"box"}),positionPrefix:"lower_box",endPositionPrefix:"upper_box",extraEncoding:continuousFieldName}),...boxplotSpecificAggregate({partName:"median",mark:Object.assign({},{type:"tick",invalid:null},isObject(config.boxplot.median)&&config.boxplot.median.color?{color:config.boxplot.median.color}:{},sizeValue?{size:sizeValue}:{},{orient:ticksOrient,
aria:!1}),positionPrefix:"mid_box",extraEncoding:continuousFieldName})];if("min-max"===_markDef$extent){var _outerSpec$transform;return Object.assign({},$jscomp$destructuring$var49,{transform:(null!==(_outerSpec$transform=$jscomp$destructuring$var49.transform)&&void 0!==_outerSpec$transform?_outerSpec$transform:[]).concat(transform),layer:sizeValue})}_outerSpec$transform='datum["lower_box_'.concat(continuousAxisChannelDef$jscomp$0.field,'"]');_markDef$extent='datum["upper_box_'.concat(continuousAxisChannelDef$jscomp$0.field,
'"]');spec$jscomp$0="(".concat(_markDef$extent," - ").concat(_outerSpec$transform,")");_outerSpec$transform="".concat(_outerSpec$transform," - ").concat($jscomp$destructuring$var50," * ").concat(spec$jscomp$0);spec$jscomp$0="".concat(_markDef$extent," + ").concat($jscomp$destructuring$var50," * ").concat(spec$jscomp$0);boxplotSpecificAggregate='datum["'.concat(continuousAxisChannelDef$jscomp$0.field,'"]');$jscomp$destructuring$var50={joinaggregate:boxParamsQuartiles(continuousAxisChannelDef$jscomp$0.field),
groupby:groupby$jscomp$0};_markDef$extent={transform:[{filter:"(".concat(_outerSpec$transform," \x3c\x3d ").concat(boxplotSpecificAggregate,") \x26\x26 (").concat(boxplotSpecificAggregate," \x3c\x3d ").concat(spec$jscomp$0,")")},{aggregate:[{op:"min",field:continuousAxisChannelDef$jscomp$0.field,as:"lower_whisker_"+continuousAxisChannelDef$jscomp$0.field},{op:"max",field:continuousAxisChannelDef$jscomp$0.field,as:"upper_whisker_"+continuousAxisChannelDef$jscomp$0.field},{op:"min",field:"lower_box_"+
continuousAxisChannelDef$jscomp$0.field,as:"lower_box_"+continuousAxisChannelDef$jscomp$0.field},{op:"max",field:"upper_box_"+continuousAxisChannelDef$jscomp$0.field,as:"upper_box_"+continuousAxisChannelDef$jscomp$0.field},...aggregate$jscomp$0],groupby:groupby$jscomp$0}],layer:t};customTooltipWithoutAggregatedField$jscomp$0=Object.assign({},customTooltipWithoutAggregatedField$jscomp$0);customTooltipWithoutAggregatedField$jscomp$0=(delete customTooltipWithoutAggregatedField$jscomp$0.tooltip,customTooltipWithoutAggregatedField$jscomp$0);
const {scale,axis}=continuousAxisChannelDef$jscomp$0;t=getTitle(continuousAxisChannelDef$jscomp$0);continuousFieldName=omit(axis,["title"]);config=partLayerMixins(mark,"outliers",config.boxplot,{transform:[{filter:"(".concat(boxplotSpecificAggregate," \x3c ").concat(_outerSpec$transform,") || (").concat(boxplotSpecificAggregate," \x3e ").concat(spec$jscomp$0,")")}],mark:"point",encoding:Object.assign({},{[continuousAxis$jscomp$0]:Object.assign({},{field:continuousAxisChannelDef$jscomp$0.field,type:continuousAxisChannelDef$jscomp$0.type},
void 0!==t?{title:t}:{},void 0!==scale?{scale}:{},isEmpty(continuousFieldName)?{}:{axis:continuousFieldName})},customTooltipWithoutAggregatedField$jscomp$0,JSCompiler_inline_result?{color:JSCompiler_inline_result}:{},customTooltipWithoutAggregatedField$jscomp$2?{tooltip:customTooltipWithoutAggregatedField$jscomp$2}:{})})[0];mark=[...bins$jscomp$0,...timeUnits$jscomp$0,$jscomp$destructuring$var50];config?config={transform:mark,layer:[config,_markDef$extent]}:(config=_markDef$extent,config.transform.unshift(...mark));
return Object.assign({},$jscomp$destructuring$var49,{layer:[config,{transform,layer:sizeValue}]})}function boxParamsQuartiles(continousAxisField){return[{op:"q1",field:continousAxisField,as:"lower_box_"+continousAxisField},{op:"q3",field:continousAxisField,as:"upper_box_"+continousAxisField}]}function normalizeErrorBar(spec,$jscomp$destructuring$var59){({config:$jscomp$destructuring$var59}=$jscomp$destructuring$var59);spec=Object.assign({},spec,{encoding:normalizeEncoding(spec.encoding,$jscomp$destructuring$var59)});
const {transform,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,ticksOrient,markDef,outerSpec,tooltipEncoding}=errorBarParams(spec,"errorbar",$jscomp$destructuring$var59);delete encodingWithoutContinuousAxis.size;spec=makeCompositeAggregatePartFactory(markDef,continuousAxis,continuousAxisChannelDef,encodingWithoutContinuousAxis,$jscomp$destructuring$var59.errorbar);$jscomp$destructuring$var59=markDef.thickness;var size=markDef.size;size=Object.assign({},{type:"tick",orient:ticksOrient,
aria:!1},void 0!==$jscomp$destructuring$var59?{thickness:$jscomp$destructuring$var59}:{},void 0!==size?{size}:{});spec=[...spec({partName:"ticks",mark:size,positionPrefix:"lower",extraEncoding:tooltipEncoding}),...spec({partName:"ticks",mark:size,positionPrefix:"upper",extraEncoding:tooltipEncoding}),...spec({partName:"rule",mark:Object.assign({},{type:"rule",ariaRoleDescription:"errorbar"},void 0!==$jscomp$destructuring$var59?{size:$jscomp$destructuring$var59}:{}),positionPrefix:"lower",endPositionPrefix:"upper",
extraEncoding:tooltipEncoding})];return Object.assign({},outerSpec,{transform},1<spec.length?{layer:spec}:Object.assign({},spec[0]))}function errorBarOrientAndInputType(spec,compositeMark){var {encoding}=spec;if(!(!isFieldOrDatumDef(encoding.x)&&!isFieldOrDatumDef(encoding.y)||isFieldOrDatumDef(encoding.x2)||isFieldOrDatumDef(encoding.y2)||isFieldOrDatumDef(encoding.xError)||isFieldOrDatumDef(encoding.xError2)||isFieldOrDatumDef(encoding.yError)||isFieldOrDatumDef(encoding.yError2)))return{orient:compositeMarkOrient(spec,
compositeMark),inputType:"raw"};var JSCompiler_inline_result=isFieldOrDatumDef(encoding.x2)||isFieldOrDatumDef(encoding.y2);var JSCompiler_inline_result$jscomp$0=isFieldOrDatumDef(encoding.xError)||isFieldOrDatumDef(encoding.xError2)||isFieldOrDatumDef(encoding.yError)||isFieldOrDatumDef(encoding.yError2);spec=encoding.x;const y=encoding.y;if(JSCompiler_inline_result){if(JSCompiler_inline_result$jscomp$0)throw Error("".concat(compositeMark," cannot be both type aggregated-upper-lower and aggregated-error"));
JSCompiler_inline_result=encoding.x2;encoding=encoding.y2;if(isFieldOrDatumDef(JSCompiler_inline_result)&&isFieldOrDatumDef(encoding))throw Error("".concat(compositeMark," cannot have both x2 and y2"));if(isFieldOrDatumDef(JSCompiler_inline_result)){if(isContinuousFieldOrDatumDef(spec))return{orient:"horizontal",inputType:"aggregated-upper-lower"};throw Error("Both x and x2 have to be quantitative in ".concat(compositeMark));}if(isFieldOrDatumDef(encoding)){if(isContinuousFieldOrDatumDef(y))return{orient:"vertical",
inputType:"aggregated-upper-lower"};throw Error("Both y and y2 have to be quantitative in ".concat(compositeMark));}}else{JSCompiler_inline_result=encoding.xError;JSCompiler_inline_result$jscomp$0=encoding.yError;const yError2=encoding.yError2;if(isFieldOrDatumDef(encoding.xError2)&&!isFieldOrDatumDef(JSCompiler_inline_result))throw Error("".concat(compositeMark," cannot have xError2 without xError"));if(isFieldOrDatumDef(yError2)&&!isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0))throw Error("".concat(compositeMark,
" cannot have yError2 without yError"));if(isFieldOrDatumDef(JSCompiler_inline_result)&&isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0))throw Error("".concat(compositeMark," cannot have both xError and yError with both are quantiative"));if(isFieldOrDatumDef(JSCompiler_inline_result)){if(isContinuousFieldOrDatumDef(spec))return{orient:"horizontal",inputType:"aggregated-error"};throw Error("All x, xError, and xError2 (if exist) have to be quantitative");}if(isFieldOrDatumDef(JSCompiler_inline_result$jscomp$0)){if(isContinuousFieldOrDatumDef(y))return{orient:"vertical",
inputType:"aggregated-error"};throw Error("All y, yError, and yError2 (if exist) have to be quantitative");}}throw Error("No ranged axis");}function errorBarParams(spec,compositeMark,config){var _outerSpec$transform,$jscomp$destructuring$var61=Object.assign({},spec),mark=spec.mark,encoding=spec.encoding,selection=spec.selection;$jscomp$destructuring$var61=(delete $jscomp$destructuring$var61.mark,delete $jscomp$destructuring$var61.encoding,delete $jscomp$destructuring$var61.selection,delete $jscomp$destructuring$var61.projection,
$jscomp$destructuring$var61);mark=isMarkDef(mark)?mark:{type:mark};selection&&warn(selectionNotSupported(compositeMark));const {orient,inputType}=errorBarOrientAndInputType(spec,compositeMark),{continuousAxisChannelDef,continuousAxisChannelDef2,continuousAxisChannelDefError,continuousAxisChannelDefError2,continuousAxis}=compositeMarkContinuousAxis(spec,orient,compositeMark);selection=[];spec=[];var continuousFieldName=continuousAxisChannelDef.field,tooltipTitleWithFieldName$jscomp$0=!1;if("raw"===
inputType){var tooltipSummary=mark.center?mark.center:mark.extent?"iqr"===mark.extent?"median":"mean":config.errorbar.center;var extent=mark.extent?mark.extent:"mean"===tooltipSummary?"stderr":"iqr";"median"===tooltipSummary!==("iqr"===extent)&&(selection=extent,selection="".concat(tooltipSummary," is not usually used with ").concat(selection," for ").concat(compositeMark,"."),warn(selection));"stderr"===extent||"stdev"===extent?(selection=[{op:extent,field:continuousFieldName,as:"extent_"+continuousFieldName},
{op:tooltipSummary,field:continuousFieldName,as:"center_"+continuousFieldName}],spec=[{calculate:'datum["center_'.concat(continuousFieldName,'"] + datum["extent_').concat(continuousFieldName,'"]'),as:"upper_"+continuousFieldName},{calculate:'datum["center_'.concat(continuousFieldName,'"] - datum["extent_').concat(continuousFieldName,'"]'),as:"lower_"+continuousFieldName}],continuousFieldName={fieldPrefix:"center_",titlePrefix:titleCase(tooltipSummary)},tooltipTitleWithFieldName$jscomp$0=extent,tooltipTitleWithFieldName$jscomp$0=
{fieldPrefix:"upper_",titlePrefix:titleCase(tooltipSummary)+" + "+tooltipTitleWithFieldName$jscomp$0},compositeMark=extent,compositeMark=titleCase(tooltipSummary)+" - "+compositeMark,tooltipSummary=[continuousFieldName,tooltipTitleWithFieldName$jscomp$0,{fieldPrefix:"lower_",titlePrefix:compositeMark}],tooltipTitleWithFieldName$jscomp$0=!0):("ci"===extent?(compositeMark="mean",tooltipSummary="ci0",extent="ci1"):(compositeMark="median",tooltipSummary="q1",extent="q3"),selection=[{op:tooltipSummary,
field:continuousFieldName,as:"lower_"+continuousFieldName},{op:extent,field:continuousFieldName,as:"upper_"+continuousFieldName},{op:compositeMark,field:continuousFieldName,as:"center_"+continuousFieldName}],tooltipSummary=[{fieldPrefix:"upper_",titlePrefix:title$jscomp$0({field:continuousFieldName,aggregate:extent,type:"quantitative"},config,{allowDisabling:!1})},{fieldPrefix:"lower_",titlePrefix:title$jscomp$0({field:continuousFieldName,aggregate:tooltipSummary,type:"quantitative"},config,{allowDisabling:!1})},
{fieldPrefix:"center_",titlePrefix:title$jscomp$0({field:continuousFieldName,aggregate:compositeMark,type:"quantitative"},config,{allowDisabling:!1})}])}else{if(mark.center||mark.extent){compositeMark=mark.center;var extent$jscomp$0=mark.extent;compositeMark="".concat(extent$jscomp$0?"extent ":"").concat(extent$jscomp$0&&compositeMark?"and ":"").concat(compositeMark?"center ":"").concat(extent$jscomp$0&&compositeMark?"are ":"is ","not needed when data are aggregated.");warn(compositeMark)}"aggregated-upper-lower"===
inputType?(tooltipSummary=[],spec=[{calculate:'datum["'.concat(continuousAxisChannelDef2.field,'"]'),as:"upper_"+continuousFieldName},{calculate:'datum["'.concat(continuousFieldName,'"]'),as:"lower_"+continuousFieldName}]):"aggregated-error"===inputType&&(tooltipSummary=[{fieldPrefix:"",titlePrefix:continuousFieldName}],spec=[{calculate:'datum["'.concat(continuousFieldName,'"] + datum["').concat(continuousAxisChannelDefError.field,'"]'),as:"upper_"+continuousFieldName}],continuousAxisChannelDefError2?
spec.push({calculate:'datum["'.concat(continuousFieldName,'"] + datum["').concat(continuousAxisChannelDefError2.field,'"]'),as:"lower_"+continuousFieldName}):spec.push({calculate:'datum["'.concat(continuousFieldName,'"] - datum["').concat(continuousAxisChannelDefError.field,'"]'),as:"lower_"+continuousFieldName}));for(extent of spec)tooltipSummary.push({fieldPrefix:extent.as.substring(0,6),titlePrefix:replaceAll(replaceAll(extent.calculate,'datum["',""),'"]',"")})}spec={postAggregateCalculates:spec,
errorBarSpecificAggregate:selection,tooltipSummary,tooltipTitleWithFieldName:tooltipTitleWithFieldName$jscomp$0};const {errorBarSpecificAggregate,postAggregateCalculates,tooltipSummary:tooltipSummary$jscomp$0,tooltipTitleWithFieldName}=spec;encoding=Object.assign({},encoding);spec="x"===continuousAxis?"x2":"y2";selection="x"===continuousAxis?"xError":"yError";continuousFieldName="x"===continuousAxis?"xError2":"yError2";encoding=(delete encoding[continuousAxis],delete encoding[spec],delete encoding[selection],
delete encoding[continuousFieldName],encoding);const {bins,timeUnits,aggregate:oldAggregate,groupby:oldGroupBy,encoding:encodingWithoutContinuousAxis}=extractTransformsFromEncoding(encoding,config);config=[...oldAggregate,...errorBarSpecificAggregate];encoding="raw"!==inputType?[]:oldGroupBy;spec=getCompositeMarkTooltip(tooltipSummary$jscomp$0,continuousAxisChannelDef,encodingWithoutContinuousAxis,tooltipTitleWithFieldName);return{transform:[...null!==(_outerSpec$transform=$jscomp$destructuring$var61.transform)&&
void 0!==_outerSpec$transform?_outerSpec$transform:[],...bins,...timeUnits,...0===config.length?[]:[{aggregate:config,groupby:encoding}],...postAggregateCalculates],groupby:encoding,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,ticksOrient:"vertical"===orient?"horizontal":"vertical",markDef:mark,outerSpec:$jscomp$destructuring$var61,tooltipEncoding:spec}}function normalizeErrorBand(spec,$jscomp$destructuring$var68){({config:$jscomp$destructuring$var68}=$jscomp$destructuring$var68);
spec=Object.assign({},spec,{encoding:normalizeEncoding(spec.encoding,$jscomp$destructuring$var68)});const {transform,continuousAxisChannelDef,continuousAxis,encodingWithoutContinuousAxis,markDef,outerSpec,tooltipEncoding}=errorBarParams(spec,"errorband",$jscomp$destructuring$var68);$jscomp$destructuring$var68=makeCompositeAggregatePartFactory(markDef,continuousAxis,continuousAxisChannelDef,encodingWithoutContinuousAxis,$jscomp$destructuring$var68.errorband);spec=void 0!==spec.encoding.x&&void 0!==
spec.encoding.y;let bandMark={type:spec?"area":"rect"},bordersMark={type:spec?"line":"rule"};const interpolate=Object.assign({},markDef.interpolate?{interpolate:markDef.interpolate}:{},markDef.tension&&markDef.interpolate?{tension:markDef.tension}:{});spec?(bandMark=Object.assign({},bandMark,interpolate,{ariaRoleDescription:"errorband"}),bordersMark=Object.assign({},bordersMark,interpolate,{aria:!1})):markDef.interpolate?warn(errorBand1DNotSupport("interpolate")):markDef.tension&&warn(errorBand1DNotSupport("tension"));
return Object.assign({},outerSpec,{transform,layer:[...$jscomp$destructuring$var68({partName:"band",mark:bandMark,positionPrefix:"lower",endPositionPrefix:"upper",extraEncoding:tooltipEncoding}),...$jscomp$destructuring$var68({partName:"borders",mark:bordersMark,positionPrefix:"lower",extraEncoding:tooltipEncoding}),...$jscomp$destructuring$var68({partName:"borders",mark:bordersMark,positionPrefix:"upper",extraEncoding:tooltipEncoding})]})}function add$jscomp$0(mark,run,parts){run=new CompositeMarkNormalizer(mark,
run);compositeMarkRegistry[mark]={normalizer:run,parts}}function assembleParameterSignals(params){const signals=[];for(const param of params||[]){var $jscomp$destructuring$var69=param,$jscomp$destructuring$var70=Object.assign({},$jscomp$destructuring$var69);params=$jscomp$destructuring$var69.expr;$jscomp$destructuring$var69=$jscomp$destructuring$var69.bind;$jscomp$destructuring$var70=(delete $jscomp$destructuring$var70.expr,delete $jscomp$destructuring$var70.bind,$jscomp$destructuring$var70);$jscomp$destructuring$var69&&
params?(params=Object.assign({},$jscomp$destructuring$var70,{bind:$jscomp$destructuring$var69,init:params}),signals.push(params)):(params=Object.assign({},$jscomp$destructuring$var70,params?{update:params}:{},$jscomp$destructuring$var69?{bind:$jscomp$destructuring$var69}:{}),signals.push(params))}return signals}function isLegendBinding(bind){return!!bind&&("legend"===bind||!!bind.legend)}function isLegendStreamBinding(bind){return isLegendBinding(bind)&&isObject(bind)}function extractTopLevelProperties(t,
includeParams){const o={};for(const p of TOP_LEVEL_PROPERTIES)t&&void 0!==t[p]&&(o[p]=signalRefOrValue(t[p]));includeParams&&(o.params=t.params);return o}function isStep(size){return isObject(size)&&void 0!==size.step}function isFrameMixins(o){return o.view||o.width||o.height}function extractCompositionLayout(spec,specType,config){const layout={},{spacing:spacingConfig,columns}=config[specType];void 0!==spacingConfig&&(layout.spacing=spacingConfig);void 0!==columns&&("facet"in spec&&!isFacetMapping(spec.facet)||
"concat"in spec)&&(layout.columns=columns);"vconcat"in spec&&(layout.columns=1);for(const prop of COMPOSITION_LAYOUT_PROPERTIES)if(void 0!==spec[prop])if("spacing"===prop){var _spacing$row,_spacing$column;specType=spec[prop];layout[prop]=isNumber(specType)?specType:{row:null!==(_spacing$row=specType.row)&&void 0!==_spacing$row?_spacing$row:spacingConfig,column:null!==(_spacing$column=specType.column)&&void 0!==_spacing$column?_spacing$column:spacingConfig}}else layout[prop]=spec[prop];return layout}
function getViewConfigContinuousSize(viewConfig,channel){var _viewConfig$channel;return null!==(_viewConfig$channel=viewConfig[channel])&&void 0!==_viewConfig$channel?_viewConfig$channel:viewConfig["width"===channel?"continuousWidth":"continuousHeight"]}function getViewConfigDiscreteStep(viewConfig,channel){viewConfig=getViewConfigDiscreteSize(viewConfig,channel);return isStep(viewConfig)?viewConfig.step:20}function getViewConfigDiscreteSize(viewConfig,channel){var _viewConfig$channel2;channel=null!==
(_viewConfig$channel2=viewConfig[channel])&&void 0!==_viewConfig$channel2?_viewConfig$channel2:viewConfig["width"===channel?"discreteWidth":"discreteHeight"];return getFirstDefined(channel,{step:viewConfig.step})}function getAxisConfigInternal(axisConfig){var props=keys$jscomp$0(axisConfig||{});const axisConfigInternal={};for(const prop of props)props=axisConfig[prop],axisConfigInternal[prop]=isConditionalAxisValue(props)?signalOrValueRefWithCondition(props):signalRefOrValue(props);return axisConfigInternal}
function initConfig(specifiedConfig){specifiedConfig=void 0===specifiedConfig?{}:specifiedConfig;var $jscomp$destructuring$var72=Object.assign({},specifiedConfig),color=specifiedConfig.color,font=specifiedConfig.font;specifiedConfig=specifiedConfig.fontSize;$jscomp$destructuring$var72=(delete $jscomp$destructuring$var72.color,delete $jscomp$destructuring$var72.font,delete $jscomp$destructuring$var72.fontSize,$jscomp$destructuring$var72);font=font?{text:{font},style:{"guide-label":{font},"guide-title":{font},
"group-title":{font},"group-subtitle":{font}}}:{};color?(color=void 0===color?{}:color,color={signals:[{name:"color",value:isObject(color)?Object.assign({},DEFAULT_COLOR,color):DEFAULT_COLOR}],mark:{color:{signal:"color.blue"}},rule:{color:{signal:"color.gray0"}},text:{color:{signal:"color.gray0"}},style:{"guide-label":{fill:{signal:"color.gray0"}},"guide-title":{fill:{signal:"color.gray0"}},"group-title":{fill:{signal:"color.gray0"}},"group-subtitle":{fill:{signal:"color.gray0"}},cell:{stroke:{signal:"color.gray8"}}},
axis:{domainColor:{signal:"color.gray13"},gridColor:{signal:"color.gray8"},tickColor:{signal:"color.gray13"}},range:{category:[{signal:"color.blue"},{signal:"color.orange"},{signal:"color.red"},{signal:"color.teal"},{signal:"color.green"},{signal:"color.yellow"},{signal:"color.purple"},{signal:"color.pink"},{signal:"color.brown"},{signal:"color.grey8"}]}}):color={};specifiedConfig=specifiedConfig?{signals:[{name:"fontSize",value:isObject(specifiedConfig)?Object.assign({},DEFAULT_FONT_SIZE,specifiedConfig):
DEFAULT_FONT_SIZE}],text:{fontSize:{signal:"fontSize.text"}},style:{"guide-label":{fontSize:{signal:"fontSize.guideLabel"}},"guide-title":{fontSize:{signal:"fontSize.guideTitle"}},"group-title":{fontSize:{signal:"fontSize.groupTitle"}},"group-subtitle":{fontSize:{signal:"fontSize.groupSubtitle"}}}}:{};specifiedConfig=mergeConfig({},defaultConfig$1,font,color,specifiedConfig,$jscomp$destructuring$var72||{});$jscomp$destructuring$var72=omit(specifiedConfig,configPropsWithExpr);for(var prop of["background",
"lineBreak","padding"])specifiedConfig[prop]&&($jscomp$destructuring$var72[prop]=signalRefOrValue(specifiedConfig[prop]));for(var markConfigType of MARK_CONFIGS)specifiedConfig[markConfigType]&&($jscomp$destructuring$var72[markConfigType]=replaceExprRefInIndex(specifiedConfig[markConfigType]));for(var axisConfigType of AXIS_CONFIGS)specifiedConfig[axisConfigType]&&($jscomp$destructuring$var72[axisConfigType]=getAxisConfigInternal(specifiedConfig[axisConfigType]));for(const headerConfigType of HEADER_CONFIGS)specifiedConfig[headerConfigType]&&
($jscomp$destructuring$var72[headerConfigType]=replaceExprRefInIndex(specifiedConfig[headerConfigType]));specifiedConfig.legend&&($jscomp$destructuring$var72.legend=replaceExprRefInIndex(specifiedConfig.legend));specifiedConfig.scale&&($jscomp$destructuring$var72.scale=replaceExprRefInIndex(specifiedConfig.scale));if(specifiedConfig.style){prop=specifiedConfig.style;markConfigType=keys$jscomp$0(prop);axisConfigType={};for(JSCompiler_inline_result of markConfigType)axisConfigType[JSCompiler_inline_result]=
getAxisConfigInternal(prop[JSCompiler_inline_result]);var JSCompiler_inline_result=axisConfigType;$jscomp$destructuring$var72.style=JSCompiler_inline_result}specifiedConfig.title&&($jscomp$destructuring$var72.title=replaceExprRefInIndex(specifiedConfig.title));specifiedConfig.view&&($jscomp$destructuring$var72.view=replaceExprRefInIndex(specifiedConfig.view));return $jscomp$destructuring$var72}function stripAndRedirectConfig(config){config=duplicate(config);for(var prop$jscomp$0 of VL_ONLY_CONFIG_PROPERTIES)delete config[prop$jscomp$0];
if(config.axis)for(var prop$jscomp$1 in config.axis)isConditionalAxisValue(config.axis[prop$jscomp$1])&&delete config.axis[prop$jscomp$1];if(config.legend)for(var prop$jscomp$2 of VL_ONLY_LEGEND_CONFIG)delete config.legend[prop$jscomp$2];if(config.mark){for(var prop$jscomp$3 of VL_ONLY_MARK_CONFIG_PROPERTIES)delete config.mark[prop$jscomp$3];config.mark.tooltip&&isObject(config.mark.tooltip)&&delete config.mark.tooltip}config.params&&(config.signals=(config.signals||[]).concat(assembleParameterSignals(config.params)),
delete config.params);for(var markType of MARK_STYLES){for(const prop of VL_ONLY_MARK_CONFIG_PROPERTIES)delete config[markType][prop];if(prop$jscomp$0=VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType])for(const prop of prop$jscomp$0)delete config[markType][prop];prop$jscomp$1=prop$jscomp$0=void 0;prop$jscomp$2=config;prop$jscomp$3=markType;var toProp=void 0,propConfig=prop$jscomp$2[prop$jscomp$3];"view"===prop$jscomp$3&&(toProp="cell");propConfig=Object.assign({},propConfig,prop$jscomp$2.style[null!==
(prop$jscomp$1=toProp)&&void 0!==prop$jscomp$1?prop$jscomp$1:prop$jscomp$3]);isEmpty(propConfig)||(prop$jscomp$2.style[null!==(prop$jscomp$0=toProp)&&void 0!==prop$jscomp$0?prop$jscomp$0:prop$jscomp$3]=propConfig);delete prop$jscomp$2[prop$jscomp$3]}for(const m of keys$jscomp$0(compositeMarkRegistry))delete config[m];{markType=config;const {titleMarkConfig,subtitleMarkConfig,subtitle}=extractTitleConfig(markType.title);isEmpty(titleMarkConfig)||(markType.style["group-title"]=Object.assign({},markType.style["group-title"],
titleMarkConfig));isEmpty(subtitleMarkConfig)||(markType.style["group-subtitle"]=Object.assign({},markType.style["group-subtitle"],subtitleMarkConfig));isEmpty(subtitle)?delete markType.title:markType.title=subtitle}for(const prop in config)isObject(config[prop])&&isEmpty(config[prop])&&delete config[prop];return isEmpty(config)?void 0:config}function potentialStackedChannel(encoding,x){const y="x"===x?"y":"radius";var xDef=encoding[x];encoding=encoding[y];if(isFieldDef(xDef)&&isFieldDef(encoding))if("quantitative"===
channelDefType(xDef)&&"quantitative"===channelDefType(encoding)){if(xDef.stack)return x;if(encoding.stack)return y;const xAggregate=isFieldDef(xDef)&&!!xDef.aggregate,yAggregate=isFieldDef(encoding)&&!!encoding.aggregate;if(xAggregate!==yAggregate)return xAggregate?x:y;var _xDef$scale,_yDef$scale;xDef=null===(_xDef$scale=xDef.scale)||void 0===_xDef$scale?void 0:_xDef$scale.type;_xDef$scale=null===(_yDef$scale=encoding.scale)||void 0===_yDef$scale?void 0:_yDef$scale.type;if(xDef&&"linear"!==xDef)return y;
if(_xDef$scale&&"linear"!==_xDef$scale)return x}else{if("quantitative"===channelDefType(xDef))return x;if("quantitative"===channelDefType(encoding))return y}else{if("quantitative"===channelDefType(xDef))return x;if("quantitative"===channelDefType(encoding))return y}}function getDimensionChannel(channel){switch(channel){case "x":return"y";case "y":return"x";case "theta":return"radius";case "radius":return"theta"}}function stack$jscomp$1(m,encoding,opt){opt=void 0===opt?{}:opt;m=isMarkDef(m)?m.type:
m;if(!STACKABLE_MARKS.has(m))return null;const fieldChannel=potentialStackedChannel(encoding,"x")||potentialStackedChannel(encoding,"theta");if(!fieldChannel)return null;const stackedFieldDef=encoding[fieldChannel];var stackedField=isFieldDef(stackedFieldDef)?vgField(stackedFieldDef,{}):void 0;let dimensionChannel=getDimensionChannel(fieldChannel),dimensionDef=encoding[dimensionChannel],dimensionField=isFieldDef(dimensionDef)?vgField(dimensionDef,{}):void 0;dimensionField===stackedField&&(dimensionChannel=
dimensionDef=dimensionField=void 0);stackedField=NONPOSITION_CHANNELS.reduce((sc,channel)=>{if("tooltip"!==channel&&channelHasField(encoding,channel)){var channelDef=encoding[channel];for(const cDef of array$jscomp$0(channelDef)){channelDef=getFieldDef(cDef);if(channelDef.aggregate)continue;const f=vgField(channelDef,{});f&&f===dimensionField||sc.push({channel,fieldDef:channelDef})}}return sc},[]);let offset;void 0!==stackedFieldDef.stack?offset=isBoolean(stackedFieldDef.stack)?stackedFieldDef.stack?
"zero":null:stackedFieldDef.stack:0<stackedField.length&&STACK_BY_DEFAULT_MARKS.has(m)&&(offset="zero");if(!(offset&&offset in STACK_OFFSET_INDEX)||isAggregate(encoding)&&0===stackedField.length)return null;if(stackedFieldDef.scale&&stackedFieldDef.scale.type&&stackedFieldDef.scale.type!==ScaleType.LINEAR){if(opt.disallowNonLinearStack)return null;warn("Cannot stack non-linear scale (".concat(stackedFieldDef.scale.type,")."))}if(isFieldOrDatumDef(encoding[getSecondaryRangeChannel(fieldChannel)]))return void 0!==
stackedFieldDef.stack&&warn(cannotStackRangedMark(fieldChannel)),null;isFieldDef(stackedFieldDef)&&stackedFieldDef.aggregate&&!contains(SUM_OPS,stackedFieldDef.aggregate)&&warn('Stacking is applied even though the aggregate function is non-summative ("'.concat(stackedFieldDef.aggregate,'").'));return{groupbyChannel:dimensionDef?dimensionChannel:void 0,groupbyField:dimensionField,fieldChannel,impute:null===stackedFieldDef.impute?!1:isPathMark(m),stackBy:stackedField,offset}}function dropLineAndPoint(markDef){markDef=
Object.assign({},markDef);markDef=(delete markDef.point,delete markDef.line,markDef);return 1<keys$jscomp$0(markDef).length?markDef:markDef.type}function dropLineAndPointFromConfig(config){for(const mark of["line","area","rule","trail"])config[mark]&&(config=Object.assign({},config,{[mark]:omit(config[mark],["point","line"])}));return config}function getPointOverlay(markDef,markConfig,encoding){markConfig=void 0===markConfig?{}:markConfig;if("transparent"===markDef.point)return{opacity:0};if(markDef.point)return isObject(markDef.point)?
markDef.point:{};if(void 0!==markDef.point)return null;if(markConfig.point||encoding.shape)return isObject(markConfig.point)?markConfig.point:{}}function getLineOverlay(markDef,markConfig){markConfig=void 0===markConfig?{}:markConfig;if(markDef.line)return!0===markDef.line?{}:markDef.line;if(void 0!==markDef.line)return null;if(markConfig.line)return!0===markConfig.line?{}:markConfig.line}function replaceRepeaterInEncoding(encoding,repeater){return repeater?replaceRepeaterInMapping(encoding,repeater):
encoding}function replaceRepeatInProp(prop,o,repeater){const val=o[prop];if(val&&!isString(val)&&"repeat"in val){if(val.repeat in repeater)return Object.assign({},o,{[prop]:repeater[val.repeat]});warn('Unknown repeated value "'.concat(val.repeat,'".'))}else return o}function replaceRepeaterInFieldDef(fieldDef,repeater){fieldDef=replaceRepeatInProp("field",fieldDef,repeater);if(void 0!==fieldDef){if(null===fieldDef)return null;"sort"in fieldDef&&isSortField(fieldDef.sort)&&(repeater=replaceRepeatInProp("field",
fieldDef.sort,repeater),fieldDef=Object.assign({},fieldDef,repeater?{sort:repeater}:{}));return fieldDef}}function replaceRepeaterInFieldOrDatumDef(def,repeater){if(isFieldDef(def))return replaceRepeaterInFieldDef(def,repeater);repeater=replaceRepeatInProp("datum",def,repeater);repeater===def||repeater.type||(repeater.type="nominal");return repeater}function replaceRepeaterInChannelDef(channelDef,repeater){if(isFieldOrDatumDef(channelDef)){if(repeater=replaceRepeaterInFieldOrDatumDef(channelDef,repeater))return repeater;
if(channelDef&&"condition"in channelDef)return{condition:channelDef.condition}}else{if(hasConditionalFieldOrDatumDef(channelDef)){if(repeater=replaceRepeaterInFieldOrDatumDef(channelDef.condition,repeater))return Object.assign({},channelDef,{condition:repeater});channelDef=Object.assign({},channelDef);return delete channelDef.condition,channelDef}return channelDef}}function replaceRepeaterInMapping(mapping,repeater){const out={};for(const channel in mapping)if(hop.call(mapping,channel)){var channelDef=
mapping[channel];isArray(channelDef)?out[channel]=channelDef.map(cd=>replaceRepeaterInChannelDef(cd,repeater)).filter(cd=>cd):(channelDef=replaceRepeaterInChannelDef(channelDef,repeater),void 0!==channelDef&&(out[channel]=channelDef))}return out}function mergeEncoding($jscomp$destructuring$var102){var {parentEncoding,encoding={},layer}=$jscomp$destructuring$var102;$jscomp$destructuring$var102={};if(parentEncoding){var channels=new Set([...keys$jscomp$0(parentEncoding),...keys$jscomp$0(encoding)]);
for(const channel of channels){channels=encoding[channel];const parentChannelDef=parentEncoding[channel];if(isFieldOrDatumDef(channels))channels=Object.assign({},parentChannelDef,channels),$jscomp$destructuring$var102[channel]=channels;else if(hasConditionalFieldOrDatumDef(channels))$jscomp$destructuring$var102[channel]=Object.assign({},channels,{condition:Object.assign({},parentChannelDef,channels.condition)});else if(channels||null===channels)$jscomp$destructuring$var102[channel]=channels;else if(layer||
isValueDef(parentChannelDef)||isSignalRef(parentChannelDef)||isFieldOrDatumDef(parentChannelDef)||isArray(parentChannelDef))$jscomp$destructuring$var102[channel]=parentChannelDef}}else $jscomp$destructuring$var102=encoding;return!$jscomp$destructuring$var102||isEmpty($jscomp$destructuring$var102)?void 0:$jscomp$destructuring$var102}function mergeProjection(opt){const {parentProjection:parentProjection$jscomp$0,projection:projection$jscomp$0}=opt;if(parentProjection$jscomp$0&&projection$jscomp$0){{const {parentProjection,
projection}={parentProjection:parentProjection$jscomp$0,projection:projection$jscomp$0};opt="Layer's shared projection ".concat(stringify(parentProjection)," is overridden by a child projection ").concat(stringify(projection),".")}warn(opt)}return null!==projection$jscomp$0&&void 0!==projection$jscomp$0?projection$jscomp$0:parentProjection$jscomp$0}function normalize$jscomp$0(spec,config){void 0===config&&(config=initConfig(spec.config));var JSCompiler_inline_result=config;JSCompiler_inline_result=
void 0===JSCompiler_inline_result?{}:JSCompiler_inline_result;JSCompiler_inline_result=normalizer.map(spec,{config:JSCompiler_inline_result});const {width:width$jscomp$0,height:height$jscomp$0}=spec;{let {width,height}={width:width$jscomp$0,height:height$jscomp$0,autosize:spec.autosize};spec=isUnitSpec(JSCompiler_inline_result)||"layer"in JSCompiler_inline_result;const autosizeDefault={};spec?"container"==width&&"container"==height?(autosizeDefault.type="fit",autosizeDefault.contains="padding"):"container"==
width?(autosizeDefault.type="fit-x",autosizeDefault.contains="padding"):"container"==height&&(autosizeDefault.type="fit-y",autosizeDefault.contains="padding"):("container"==width&&(warn(containerSizeNonSingle("width")),width=void 0),"container"==height&&(warn(containerSizeNonSingle("height")),height=void 0));config=Object.assign({},{type:"pad"},autosizeDefault,config?_normalizeAutoSize(config.autosize):{},_normalizeAutoSize(JSCompiler_inline_result.autosize));"fit"!==config.type||spec||(warn('Autosize "fit" only works for single views and layered views.'),
config.type="pad");"container"==width&&"fit"!=config.type&&"fit-x"!=config.type&&warn(containerSizeNotCompatibleWithAutosize("width"));"container"==height&&"fit"!=config.type&&"fit-y"!=config.type&&warn(containerSizeNotCompatibleWithAutosize("height"));spec=deepEqual(config,{type:"pad"})?void 0:config}return Object.assign({},JSCompiler_inline_result,spec?{autosize:spec}:{})}function _normalizeAutoSize(autosize){return isString(autosize)?{type:autosize}:null!==autosize&&void 0!==autosize?autosize:
{}}function makeExplicit(value){return{explicit:!0,value}}function makeImplicit(value){return{explicit:!1,value}}function tieBreakByComparing(compare){return(v1,v2,property,propertyOf)=>{const diff=compare(v1.value,v2.value);return 0<diff?v1:0>diff?v2:defaultTieBreaker(v1,v2,property,propertyOf)}}function defaultTieBreaker(v1$jscomp$0,v2,property,propertyOf){if(v1$jscomp$0.explicit&&v2.explicit){var v1=v1$jscomp$0.value;v2=v2.value;property="Conflicting ".concat(propertyOf.toString(),' property "').concat(property.toString(),
'" (').concat(stringify(v1)," and ").concat(stringify(v2),"). Using ").concat(stringify(v1),".");warn(property)}return v1$jscomp$0}function mergeValuesWithExplicit(v1,v2,property,propertyOf,tieBreaker){tieBreaker=void 0===tieBreaker?defaultTieBreaker:tieBreaker;return void 0===v1||void 0===v1.value?v2:v1.explicit&&!v2.explicit?v1:v2.explicit&&!v1.explicit?v2:deepEqual(v1.value,v2.value)?v1:tieBreaker(v1,v2,property,propertyOf)}function isNamedData(data){return"name"in data&&!("url"in data)&&!("values"in
data)&&!isGenerator(data)}function isGenerator(data){return data&&("sequence"in data||"sphere"in data||"graticule"in data)}function normalizeTransform(transform){return transform.map(t=>"filter"in t?{filter:normalizeLogicalComposition(t.filter,normalizePredicate)}:t)}function eventSelector(selector,source,marks){DEFAULT_SOURCE=source||"view";MARKS=marks||DEFAULT_MARKS;return parseMerge(selector.trim()).map(parseSelector)}function find$jscomp$0(s,i,endChar,pushChar,popChar){const n=s.length;let count=
0,c;for(;i<n;++i)if(c=s[i],count||c!==endChar)popChar&&0<=popChar.indexOf(c)?--count:pushChar&&0<=pushChar.indexOf(c)&&++count;else break;return i}function parseMerge(s){const output=[],n=s.length;let start=0,i=0;for(;i<n;)i=find$jscomp$0(s,i,",","[{","]}"),output.push(s.substring(start,i).trim()),start=++i;if(0===output.length)throw"Empty event selector: "+s;return output}function parseSelector(s){if("["===s[0]){var JSCompiler_temp=s;var n$jscomp$0=JSCompiler_temp.length;s=find$jscomp$0(JSCompiler_temp,
1,"]","[","]");if(s===n$jscomp$0)throw"Empty between selector: "+JSCompiler_temp;n$jscomp$0=parseMerge(JSCompiler_temp.substring(1,s));if(2!==n$jscomp$0.length)throw"Between selector must have two elements: "+JSCompiler_temp;JSCompiler_temp=JSCompiler_temp.slice(s+1).trim();if("\x3e"!==JSCompiler_temp[0])throw"Expected '\x3e' after between selector: "+JSCompiler_temp;n$jscomp$0=n$jscomp$0.map(parseSelector);JSCompiler_temp=parseSelector(JSCompiler_temp.slice(1).trim());JSCompiler_temp.between?JSCompiler_temp=
{between:n$jscomp$0,stream:JSCompiler_temp}:JSCompiler_temp.between=n$jscomp$0}else{{n$jscomp$0={source:DEFAULT_SOURCE};const source=[];let throttle=[0,0],markname=0,start=0,n=s.length,i=0,j;if("}"===s[n-1]){i=s.lastIndexOf("{");if(0<=i){try{throttle=parseThrottle(s.substring(i+1,n-1))}catch(e){throw"Invalid throttle specification: "+s;}s=s.slice(0,i).trim();n=s.length}else throw"Unmatched right brace: "+s;i=0}if(!n)throw s;"@"===s[0]&&(markname=++i);j=find$jscomp$0(s,i,":");j<n&&(source.push(s.substring(start,
j).trim()),start=i=++j);i=find$jscomp$0(s,i,"[");if(i===n)source.push(s.substring(start,n).trim());else if(source.push(s.substring(start,i).trim()),JSCompiler_temp=[],start=++i,start===n)throw"Unmatched left bracket: "+s;for(;i<n;){i=find$jscomp$0(s,i,"]");if(i===n)throw"Unmatched left bracket: "+s;JSCompiler_temp.push(s.substring(start,i).trim());if(i<n-1&&"["!==s[++i])throw"Expected left bracket: "+s;start=++i}if(!(n=source.length)||ILLEGAL.test(source[n-1]))throw"Invalid event selector: "+s;1<
n?(n$jscomp$0.type=source[1],markname?n$jscomp$0.markname=source[0].slice(1):MARKS[source[0]]?n$jscomp$0.marktype=source[0]:n$jscomp$0.source=source[0]):n$jscomp$0.type=source[0];"!"===n$jscomp$0.type.slice(-1)&&(n$jscomp$0.consume=!0,n$jscomp$0.type=n$jscomp$0.type.slice(0,-1));null!=JSCompiler_temp&&(n$jscomp$0.filter=JSCompiler_temp);throttle[0]&&(n$jscomp$0.throttle=throttle[0]);throttle[1]&&(n$jscomp$0.debounce=throttle[1]);JSCompiler_temp=n$jscomp$0}}return JSCompiler_temp}function parseThrottle(s){const a=
s.split(",");if(!s.length||2<a.length)throw s;return a.map(_=>{_=+_;if(_!==_)throw s;return _})}function wrapCondition(model,channelDef,vgChannel,refFn){var condition=!!channelDef&&"condition"in channelDef&&channelDef.condition;channelDef=refFn(channelDef);return condition?(condition=array$jscomp$0(condition).map(c=>{const conditionValueRef=refFn(c);c=c.selection?parseSelectionPredicate(model,c.selection):expression$jscomp$0(model,c.test);return Object.assign({},{test:c},conditionValueRef)}),{[vgChannel]:[...condition,
...void 0!==channelDef?[channelDef]:[]]}):void 0!==channelDef?{[vgChannel]:channelDef}:{}}function text$jscomp$0(model,channel){channel=void 0===channel?"text":channel;return wrapCondition(model,model.encoding[channel],channel,cDef=>textRef(cDef,model.config))}function textRef(channelDef,config,expr){expr=void 0===expr?"datum":expr;if(channelDef){if(isValueDef(channelDef))return signalOrValueRef(channelDef.value);if(isFieldOrDatumDef(channelDef)){const {format,formatType}=getFormatMixins(channelDef);
return formatSignalRef({fieldOrDatumDef:channelDef,format,formatType,expr,config})}}}function tooltip(model,opt){opt=void 0===opt?{}:opt;const {encoding,markDef,config,stack}=model,channelDef=encoding.tooltip;if(isArray(channelDef))return{tooltip:tooltipRefForEncoding({tooltip:channelDef},stack,config,opt)};{const datum=opt.reactiveGeom?"datum.datum":"datum";return wrapCondition(model,channelDef,"tooltip",cDef=>{const tooltipRefFromChannelDef=textRef(cDef,config,datum);if(tooltipRefFromChannelDef)return tooltipRefFromChannelDef;
if(null!==cDef){cDef=getMarkPropOrConfig("tooltip",markDef,config);!0===cDef&&(cDef={content:"encoding"});if(isString(cDef))return{value:cDef};if(isObject(cDef))return isSignalRef(cDef)?cDef:"encoding"===cDef.content?tooltipRefForEncoding(encoding,stack,config,opt):{signal:datum}}})}}function tooltipData(encoding,stack,config,$jscomp$destructuring$var103){function add(fDef,channel){var _value,mainChannel=getMainRangeChannel(channel);fDef=isTypedFieldDef(fDef)?fDef:Object.assign({},fDef,{type:encoding[mainChannel].type});
mainChannel=fDef.title||titleFormatter(fDef,config);mainChannel=array$jscomp$0(mainChannel).join(", ");if(channel in POSITION_SCALE_CHANNEL_INDEX){const channel2="x"===channel?"x2":"y2";var fieldDef2=getFieldDef(encoding[channel2]);if(isBinned(fDef.bin)&&fieldDef2){var value=vgField(fDef,{expr});fieldDef2=vgField(fieldDef2,{expr});const {format,formatType}=getFormatMixins(fDef);value=binFormatExpression(value,fieldDef2,format,formatType,config);toSkip[channel2]=!0}else if(stack&&stack.fieldChannel===
channel&&"normalize"===stack.offset){const {format,formatType}=getFormatMixins(fDef);value=formatSignalRef({fieldOrDatumDef:fDef,format,formatType,expr,config,normalizeStack:!0}).signal}}value=null!==(_value=value)&&void 0!==_value?_value:textRef(fDef,config,expr).signal;tuples.push({channel,key:mainChannel,value})}({reactiveGeom:$jscomp$destructuring$var103}=void 0===$jscomp$destructuring$var103?{}:$jscomp$destructuring$var103);const toSkip={},expr=$jscomp$destructuring$var103?"datum.datum":"datum",
tuples=[];forEach(encoding,(channelDef,channel)=>{isFieldDef(channelDef)?add(channelDef,channel):hasConditionalFieldDef(channelDef)&&add(channelDef.condition,channel)});$jscomp$destructuring$var103={};for(const $jscomp$destructuring$var104 of tuples){const {channel,key,value}=$jscomp$destructuring$var104;toSkip[channel]||$jscomp$destructuring$var103[key]||($jscomp$destructuring$var103[key]=value)}return $jscomp$destructuring$var103}function tooltipRefForEncoding(encoding,stack,config,$jscomp$destructuring$var105){({reactiveGeom:$jscomp$destructuring$var105}=
void 0===$jscomp$destructuring$var105?{}:$jscomp$destructuring$var105);encoding=tooltipData(encoding,stack,config,{reactiveGeom:$jscomp$destructuring$var105});encoding=entries(encoding).map($jscomp$destructuring$var106=>{var [key,value]=$jscomp$destructuring$var106;return'"'.concat(key,'": ').concat(value)});return 0<encoding.length?{signal:"{".concat(encoding.join(", "),"}")}:void 0}function aria(model){const {markDef,config}=model,enableAria=getMarkPropOrConfig("aria",markDef,config);return!1===
enableAria?{}:Object.assign({},enableAria?{aria:enableAria}:{},ariaRoleDescription(model),description(model))}function ariaRoleDescription(model){const {mark,markDef,config}=model;if(!1===config.aria)return{};model=getMarkPropOrConfig("ariaRoleDescription",markDef,config);return null!=model?{ariaRoleDescription:{value:model}}:mark in VG_MARK_INDEX?{}:{ariaRoleDescription:{value:mark}}}function description(model){const {encoding,markDef,config,stack}=model;var channelDef=encoding.description;if(channelDef)return wrapCondition(model,
channelDef,"description",cDef=>textRef(cDef,model.config));channelDef=getMarkPropOrConfig("description",markDef,config);if(null!=channelDef)return{description:signalOrValueRef(channelDef)};if(!1===config.aria)return{};channelDef=tooltipData(encoding,stack,config);if(!isEmpty(channelDef))return{description:{signal:entries(channelDef).map(($jscomp$destructuring$var107,index)=>{var [key,value]=$jscomp$destructuring$var107;return'"'.concat(0<index?"; ":"").concat(key,': " + (').concat(value,")")}).join(" + ")}}}
function nonPosition(channel,model,opt){opt=void 0===opt?{}:opt;const {markDef,encoding,config}=model,{vgChannel}=opt;let {defaultRef,defaultValue}=opt;if(void 0===defaultRef){var _defaultValue;defaultValue=null!==(_defaultValue=defaultValue)&&void 0!==_defaultValue?_defaultValue:getMarkPropOrConfig(channel,markDef,config,{vgChannel,ignoreVgConfig:!0});void 0!==defaultValue&&(defaultRef=signalOrValueRef(defaultValue))}return wrapCondition(model,encoding[channel],null!==vgChannel&&void 0!==vgChannel?
vgChannel:channel,cDef=>midPoint({channel,channelDef:cDef,markDef,config,scaleName:model.scaleName(channel),scale:model.getScaleComponent(channel),stack:null,defaultRef}))}function color$jscomp$0(model,opt){opt=void 0===opt?{filled:void 0}:opt;var _opt$filled,_ref,_getMarkPropOrConfig,_getMarkPropOrConfig2;const {markDef,encoding,config}=model,{type:markType}=markDef;opt=null!==(_opt$filled=opt.filled)&&void 0!==_opt$filled?_opt$filled:getMarkPropOrConfig("filled",markDef,config);_opt$filled=contains(["bar",
"point","circle","square","geoshape"],markType)?"transparent":void 0;_opt$filled=null!==(_ref=null!==(_getMarkPropOrConfig=getMarkPropOrConfig(!0===opt?"color":void 0,markDef,config,{vgChannel:"fill"}))&&void 0!==_getMarkPropOrConfig?_getMarkPropOrConfig:config.mark[!0===opt&&"color"])&&void 0!==_ref?_ref:_opt$filled;_ref=null!==(_getMarkPropOrConfig2=getMarkPropOrConfig(!1===opt?"color":void 0,markDef,config,{vgChannel:"stroke"}))&&void 0!==_getMarkPropOrConfig2?_getMarkPropOrConfig2:config.mark[!1===
opt&&"color"];_getMarkPropOrConfig2=opt?"fill":"stroke";_getMarkPropOrConfig=Object.assign({},_opt$filled?{fill:signalOrValueRef(_opt$filled)}:{},_ref?{stroke:signalOrValueRef(_ref)}:{});markDef.color&&(opt?markDef.fill:markDef.stroke)&&warn(droppingColor("property",{fill:"fill"in markDef,stroke:"stroke"in markDef}));return Object.assign({},_getMarkPropOrConfig,nonPosition("color",model,{vgChannel:_getMarkPropOrConfig2,defaultValue:opt?_opt$filled:_ref}),nonPosition("fill",model,{defaultValue:encoding.fill?
_opt$filled:void 0}),nonPosition("stroke",model,{defaultValue:encoding.stroke?_ref:void 0}))}function zindex(model){const {encoding,mark}=model,order=encoding.order;return!isPathMark(mark)&&isValueDef(order)?wrapCondition(model,order,"zindex",cd=>signalOrValueRef(cd.value)):{}}function getOffset(channel,markDef){channel=getOffsetChannel(channel);if(markDef=markDef[channel])return markDef}function pointPosition(channel$jscomp$0,model,$jscomp$destructuring$var108){var {defaultPos,vgChannel,isMidPoint:isMidPoint$jscomp$0}=
$jscomp$destructuring$var108;const {encoding,markDef:markDef$jscomp$0,config:config$jscomp$0,stack:stack$jscomp$0}=model;$jscomp$destructuring$var108=encoding[channel$jscomp$0];const channel2Def=encoding[getSecondaryRangeChannel(channel$jscomp$0)],scaleName$jscomp$0=model.scaleName(channel$jscomp$0),scale=model.getScaleComponent(channel$jscomp$0),offset$jscomp$0=getOffset(channel$jscomp$0,markDef$jscomp$0),defaultRef=pointPositionDefaultRef({model,defaultPos,channel:channel$jscomp$0,scaleName:scaleName$jscomp$0,
scale});if(!$jscomp$destructuring$var108&&channel$jscomp$0 in POSITION_SCALE_CHANNEL_INDEX&&(encoding.latitude||encoding.longitude))model={field:model.getName(channel$jscomp$0)};else a:{model={channel:channel$jscomp$0,channelDef:$jscomp$destructuring$var108,channel2Def,markDef:markDef$jscomp$0,config:config$jscomp$0,isMidPoint:isMidPoint$jscomp$0,scaleName:scaleName$jscomp$0,scale,stack:stack$jscomp$0,offset:offset$jscomp$0,defaultRef};const {channel,channelDef,isMidPoint,scaleName,stack,offset,markDef,
config}=model;if(isFieldOrDatumDef(channelDef)&&stack&&channel===stack.fieldChannel){if(isFieldDef(channelDef)&&(model=getBand({channel,fieldDef:channelDef,isMidPoint,markDef,stack,config}),void 0!==model)){model=interpolatedSignalRef({scaleName,fieldOrDatumDef:channelDef,startSuffix:"start",band:model,offset});break a}model=valueRefForFieldOrDatumDef(channelDef,scaleName,{suffix:"end"},{offset})}else model=midPointRefWithPositionInvalidTest(model)}return model?{[vgChannel||channel$jscomp$0]:model}:
void 0}function pointPositionDefaultRef($jscomp$destructuring$var109){var {model,defaultPos,channel,scaleName,scale}=$jscomp$destructuring$var109;const {markDef,config}=model;return()=>{var mainChannel=getMainRangeChannel(channel),vgChannel=getVgPositionChannel(channel);vgChannel=getMarkPropOrConfig(channel,markDef,config,{vgChannel});if(void 0!==vgChannel)return widthHeightValueOrSignalRef(channel,vgChannel);switch(defaultPos){case "zeroOrMin":case "zeroOrMax":if(scaleName&&(vgChannel=scale.get("type"),
!contains([ScaleType.LOG,ScaleType.TIME,ScaleType.UTC],vgChannel)&&scale.domainDefinitelyIncludesZero()))return{scale:scaleName,value:0};if("zeroOrMin"===defaultPos)return"y"===mainChannel?{field:{group:"height"}}:{value:0};switch(mainChannel){case "radius":return{signal:"min(".concat(model.width.signal,",").concat(model.height.signal,")/2")};case "theta":return{signal:"2*PI"};case "x":return{field:{group:"width"}};case "y":return{value:0}}break;case "mid":return mainChannel=model[getSizeChannel(channel)],
Object.assign({},mainChannel,{mult:.5})}}}function vgAlignedPositionChannel(channel,markDef,config,defaultAlign){defaultAlign=void 0===defaultAlign?"middle":defaultAlign;if("radius"===channel||"theta"===channel)return getVgPositionChannel(channel);var alignChannel="x"===channel?"align":"baseline";markDef=getMarkPropOrConfig(alignChannel,markDef,config);isSignalRef(markDef)?(warn("The ".concat(alignChannel," for range marks cannot be an expression")),alignChannel=void 0):alignChannel=markDef;return"x"===
channel?ALIGNED_X_CHANNEL[alignChannel||("top"===defaultAlign?"left":"center")]:BASELINED_Y_CHANNEL[alignChannel||defaultAlign]}function pointOrRangePosition(channel,model,$jscomp$destructuring$var110){var {defaultPos,defaultPos2,range}=$jscomp$destructuring$var110;return range?rangePosition(channel,model,{defaultPos,defaultPos2}):pointPosition(channel,model,{defaultPos})}function rangePosition(channel$jscomp$0,model,$jscomp$destructuring$var111){var {defaultPos,defaultPos2}=$jscomp$destructuring$var111;
const {markDef:markDef$jscomp$0,config:config$jscomp$0}=model;var channel2=getSecondaryRangeChannel(channel$jscomp$0);$jscomp$destructuring$var111=getSizeChannel(channel$jscomp$0);{const {encoding,mark,markDef,stack,config}=model;var baseChannel=getMainRangeChannel(channel2);const sizeChannel=getSizeChannel(channel2),vgChannel=getVgPositionChannel(channel2);var channelDef=encoding[baseChannel];const scaleName=model.scaleName(baseChannel),scale=model.getScaleComponent(baseChannel);baseChannel=channel2 in
encoding||channel2 in markDef?getOffset(channel2,model.markDef):getOffset(baseChannel,model.markDef);if(channelDef||"x2"!==channel2&&"y2"!==channel2||!encoding.latitude&&!encoding.longitude){var {channel,channelDef:channelDef$jscomp$0,channel2Def,markDef:markDef$jscomp$1,config:config$jscomp$1,scaleName:scaleName$jscomp$0,scale:scale$jscomp$0,stack:stack$jscomp$0,offset,defaultRef}={channel:channel2,channelDef,channel2Def:encoding[channel2],markDef,config,scaleName,scale,stack,offset:baseChannel,
defaultRef:void 0};channelDef=isFieldOrDatumDef(channelDef$jscomp$0)&&stack$jscomp$0&&channel.charAt(0)===stack$jscomp$0.fieldChannel.charAt(0)?valueRefForFieldOrDatumDef(channelDef$jscomp$0,scaleName$jscomp$0,{suffix:"start"},{offset}):midPointRefWithPositionInvalidTest({channel,channelDef:channel2Def,scaleName:scaleName$jscomp$0,scale:scale$jscomp$0,stack:stack$jscomp$0,markDef:markDef$jscomp$1,config:config$jscomp$1,offset,defaultRef});channel2=void 0!==channelDef?{[vgChannel]:channelDef}:position2orSize(channel2,
markDef)||position2orSize(channel2,{[channel2]:getMarkStyleConfig(channel2,markDef,config.style),[sizeChannel]:getMarkStyleConfig(sizeChannel,markDef,config.style)})||position2orSize(channel2,config[mark])||position2orSize(channel2,config.mark)||{[vgChannel]:pointPositionDefaultRef({model,defaultPos:defaultPos2,channel:channel2,scaleName,scale})()}}else channel2={[vgChannel]:{field:model.getName(channel2)}}}$jscomp$destructuring$var111=channel2[$jscomp$destructuring$var111]?vgAlignedPositionChannel(channel$jscomp$0,
markDef$jscomp$0,config$jscomp$0):getVgPositionChannel(channel$jscomp$0);return Object.assign({},pointPosition(channel$jscomp$0,model,{defaultPos,vgChannel:$jscomp$destructuring$var111}),channel2)}function position2orSize(channel,markDef){const sizeChannel=getSizeChannel(channel),vgChannel=getVgPositionChannel(channel);if(void 0!==markDef[vgChannel])return{[vgChannel]:widthHeightValueOrSignalRef(channel,markDef[vgChannel])};if(void 0!==markDef[channel])return{[vgChannel]:widthHeightValueOrSignalRef(channel,
markDef[channel])};if(markDef[sizeChannel])return{[sizeChannel]:widthHeightValueOrSignalRef(channel,markDef[sizeChannel])}}function rectPosition(model,channel$jscomp$0,mark){var _ref,_encoding$sizeChannel;const {config:config$jscomp$0,encoding:encoding$jscomp$0,markDef:markDef$jscomp$0,stack:stack$jscomp$0}=model;var channel2=getSecondaryRangeChannel(channel$jscomp$0),sizeChannel=getSizeChannel(channel$jscomp$0),channelDef=encoding$jscomp$0[channel$jscomp$0];channel2=encoding$jscomp$0[channel2];var scale=
model.getScaleComponent(channel$jscomp$0),scaleType=scale?scale.get("type"):void 0,scaleName=model.scaleName(channel$jscomp$0);const orient=markDef$jscomp$0.orient;sizeChannel=null!==(_ref=null!==(_encoding$sizeChannel=encoding$jscomp$0[sizeChannel])&&void 0!==_encoding$sizeChannel?_encoding$sizeChannel:encoding$jscomp$0.size)&&void 0!==_ref?_ref:getMarkPropOrConfig("size",markDef$jscomp$0,config$jscomp$0,{vgChannel:sizeChannel});_ref="bar"===mark&&("x"===channel$jscomp$0?"vertical"===orient:"horizontal"===
orient);if(isFieldDef(channelDef)&&(isBinning(channelDef.bin)||isBinned(channelDef.bin)||channelDef.timeUnit&&!channel2)&&!sizeChannel&&!(scaleType in DISCRETE_DOMAIN_INDEX)){var _model$component$axes,_axis$get;mark=getBand({channel:channel$jscomp$0,fieldDef:channelDef,stack:stack$jscomp$0,markDef:markDef$jscomp$0,config:config$jscomp$0});model=null===(_model$component$axes=model.component.axes[channel$jscomp$0])||void 0===_model$component$axes?void 0:_model$component$axes[0];model=null!==(_axis$get=
null===model||void 0===model?void 0:model.get("translate"))&&void 0!==_axis$get?_axis$get:.5;a:{channel$jscomp$0={fieldDef:channelDef,fieldDef2:channel2,channel:channel$jscomp$0,markDef:markDef$jscomp$0,scaleName,band:mark,axisTranslate:model,spacing:channel$jscomp$0 in POSITION_SCALE_CHANNEL_INDEX?getMarkPropOrConfig("binSpacing",markDef$jscomp$0,config$jscomp$0):void 0,reverse:scale.get("reverse"),config:config$jscomp$0};var {fieldDef,fieldDef2,channel,band,scaleName:scaleName$jscomp$0,markDef:markDef$jscomp$1,
spacing=0,axisTranslate,reverse,config:config$jscomp$1}=channel$jscomp$0;channel$jscomp$0=getSecondaryRangeChannel(channel);channelDef=getVgPositionChannel(channel);model=getVgPositionChannel(channel$jscomp$0);mark=getOffset(channel,markDef$jscomp$1);if(isBinning(fieldDef.bin)||fieldDef.timeUnit)channel$jscomp$0={[model]:rectBinRef({channel,fieldDef,scaleName:scaleName$jscomp$0,markDef:markDef$jscomp$1,band:(1-band)/2,offset:getBinSpacing(channel$jscomp$0,spacing,reverse,axisTranslate,mark),config:config$jscomp$1}),
[channelDef]:rectBinRef({channel,fieldDef,scaleName:scaleName$jscomp$0,markDef:markDef$jscomp$1,band:1-(1-band)/2,offset:getBinSpacing(channel,spacing,reverse,axisTranslate,mark),config:config$jscomp$1})};else{if(isBinned(fieldDef.bin)){var startRef=valueRefForFieldOrDatumDef(fieldDef,scaleName$jscomp$0,{},{offset:getBinSpacing(channel$jscomp$0,spacing,reverse,axisTranslate,mark)});if(isFieldDef(fieldDef2)){channel$jscomp$0={[model]:startRef,[channelDef]:valueRefForFieldOrDatumDef(fieldDef2,scaleName$jscomp$0,
{},{offset:getBinSpacing(channel,spacing,reverse,axisTranslate,mark)})};break a}if(isObject(fieldDef.bin)&&fieldDef.bin.step){channel$jscomp$0={[model]:startRef,[channelDef]:{signal:'scale("'.concat(scaleName$jscomp$0,'", ').concat(vgField(fieldDef,{expr:"datum"})," + ").concat(fieldDef.bin.step,")"),offset:getBinSpacing(channel,spacing,reverse,axisTranslate,mark)}};break a}}warn(channelRequiredForBinned(channel$jscomp$0));channel$jscomp$0=void 0}}return channel$jscomp$0}if((isFieldOrDatumDef(channelDef)&&
scaleType in DISCRETE_DOMAIN_INDEX||_ref)&&!channel2){{var _ref2;const {markDef,encoding,config,stack}=model;_model$component$axes=markDef.orient;scale=model.scaleName(channel$jscomp$0);scaleName=model.getScaleComponent(channel$jscomp$0);_axis$get=getSizeChannel(channel$jscomp$0);channel2=getSecondaryRangeChannel(channel$jscomp$0);_model$component$axes="horizontal"===_model$component$axes&&"y"===channel$jscomp$0||"vertical"===_model$component$axes&&"x"===channel$jscomp$0;_ref=getMarkPropOrConfig(_model$component$axes?
"size":_axis$get,markDef,config,{vgChannel:_axis$get});if(encoding.size||void 0!==_ref)_model$component$axes?startRef=nonPosition("size",model,{vgChannel:_axis$get,defaultValue:_ref}):warn('Cannot apply size to non-oriented mark "'.concat(markDef.type,'".'));_model$component$axes=null!==(_ref2=isFieldOrDatumDef(channelDef)?getBand({channel:channel$jscomp$0,fieldDef:channelDef,markDef,stack,config}):void 0)&&void 0!==_ref2?_ref2:1;startRef||(scaleType=_axis$get,_ref2=scale,_ref=scaleName,startRef=
config,_encoding$sizeChannel=_model$component$axes,_ref?(scaleType=_ref.get("type"),"point"===scaleType||"band"===scaleType?void 0!==startRef[mark].discreteBandSize?mark={value:startRef[mark].discreteBandSize}:scaleType===ScaleType.POINT?(mark=_ref.get("range"),mark=isVgRangeStep(mark)&&isNumber(mark.step)?{value:mark.step-2}:{value:18}):mark={scale:_ref2,band:_encoding$sizeChannel}:mark={value:startRef[mark].continuousBandSize}):(_ref2=getViewConfigDiscreteStep(startRef.view,scaleType),mark=getFirstDefined(startRef[mark].discreteBandSize,
_ref2-2),mark=void 0!==mark?{value:mark}:void 0),startRef={[_axis$get]:mark});_ref="band"!==(null===scaleName||void 0===scaleName?void 0:scaleName.get("type"))||!("band"in startRef[_axis$get]);mark=vgAlignedPositionChannel(channel$jscomp$0,markDef,config,_ref?"middle":"top");_ref2=getOffset(channel$jscomp$0,markDef);channel$jscomp$0=midPointRefWithPositionInvalidTest({channel:channel$jscomp$0,channelDef,markDef,config,scaleName:scale,scale:scaleName,stack,offset:_ref2,defaultRef:pointPositionDefaultRef({model,
defaultPos:"mid",channel:channel$jscomp$0,scaleName:scale,scale:scaleName}),band:_ref?.5:(1-_model$component$axes)/2});_axis$get?channel$jscomp$0=Object.assign({},{[mark]:channel$jscomp$0},startRef):(channelDef=getVgPositionChannel(channel2),model=startRef[_axis$get],model=_ref2?Object.assign({},model,{offset:_ref2}):model,channel$jscomp$0={[mark]:channel$jscomp$0,[channelDef]:isArray(channel$jscomp$0)?[channel$jscomp$0[0],Object.assign({},channel$jscomp$0[1],{offset:model})]:Object.assign({},channel$jscomp$0,
{offset:model})})}return channel$jscomp$0}return rangePosition(channel$jscomp$0,model,{defaultPos:"zeroOrMax",defaultPos2:"zeroOrMin"})}function getBinSpacing(channel,spacing,reverse,translate,offset){if(channel in POLAR_POSITION_CHANNEL_INDEX)return 0;channel="x"===channel||"y2"===channel?-spacing/2:spacing/2;if(isSignalRef(reverse)||isSignalRef(offset)||isSignalRef(translate))return reverse=signalOrStringValue(reverse),offset=signalOrStringValue(offset),translate=(translate=signalOrStringValue(translate))?
"".concat(translate," + "):"",reverse=reverse?"(".concat(reverse," ? -1 : 1) * "):"",channel=offset?"(".concat(offset," + ").concat(channel,")"):channel,{signal:translate+reverse+channel};offset=offset||0;return translate+(reverse?-offset-channel:+offset+channel)}function rectBinRef($jscomp$destructuring$var114){var {channel,fieldDef,scaleName,markDef,band,offset,config}=$jscomp$destructuring$var114;$jscomp$destructuring$var114=interpolatedSignalRef({scaleName,fieldOrDatumDef:fieldDef,band,offset});
return wrapPositionInvalidTest({fieldDef,channel,markDef,ref:$jscomp$destructuring$var114,config})}function baseEncodeEntry(model,ignore){const {fill,stroke}="include"===ignore.color?color$jscomp$0(model):{};return Object.assign({},markDefProperties(model.markDef,ignore),wrapAllFieldsInvalid(model,"fill",fill),wrapAllFieldsInvalid(model,"stroke",stroke),nonPosition("opacity",model),nonPosition("fillOpacity",model),nonPosition("strokeOpacity",model),nonPosition("strokeWidth",model),nonPosition("strokeDash",
model),zindex(model),tooltip(model),text$jscomp$0(model,"href"),aria(model))}function wrapAllFieldsInvalid(model,channel,valueRef){const {config,mark,markDef}=model;return"hide"===getMarkPropOrConfig("invalid",markDef,config)&&valueRef&&!isPathMark(mark)&&(model=allFieldsInvalidPredicate(model,{invalid:!0,channels:SCALE_CHANNELS}))?{[channel]:[{test:model,value:null},...array$jscomp$0(valueRef)]}:valueRef?{[channel]:valueRef}:{}}function markDefProperties(mark,ignore){return VG_MARK_CONFIGS.reduce((m,
prop)=>{ALWAYS_IGNORE.has(prop)||void 0===mark[prop]||"ignore"===ignore[prop]||(m[prop]=signalOrValueRef(mark[prop]));return m},{})}function allFieldsInvalidPredicate(model,$jscomp$destructuring$var115){var {invalid=!1,channels}=$jscomp$destructuring$var115;$jscomp$destructuring$var115=channels.reduce((aggregator,channel)=>{var scaleComponent=model.getScaleComponent(channel);scaleComponent&&(scaleComponent=scaleComponent.get("type"),(channel=model.vgField(channel,{expr:"datum"}))&&scaleComponent in
CONTINUOUS_DOMAIN_INDEX&&(aggregator[channel]=!0));return aggregator},{});$jscomp$destructuring$var115=keys$jscomp$0($jscomp$destructuring$var115);if(0<$jscomp$destructuring$var115.length){const op=invalid?"||":"\x26\x26";return $jscomp$destructuring$var115.map(field=>fieldInvalidPredicate(field,invalid)).join(" ".concat(op," "))}}function defined(model){const {config,markDef}=model;return getMarkPropOrConfig("invalid",markDef,config)&&(model=allFieldsInvalidPredicate$1(model,{channels:POSITION_SCALE_CHANNELS}))?
{defined:{signal:model}}:{}}function allFieldsInvalidPredicate$1(model,$jscomp$destructuring$var116){var {invalid=!1,channels}=$jscomp$destructuring$var116;$jscomp$destructuring$var116=channels.reduce((aggregator,channel)=>{var scaleComponent=model.getScaleComponent(channel);scaleComponent&&(scaleComponent=scaleComponent.get("type"),(channel=model.vgField(channel,{expr:"datum"}))&&scaleComponent in CONTINUOUS_DOMAIN_INDEX&&(aggregator[channel]=!0));return aggregator},{});$jscomp$destructuring$var116=
keys$jscomp$0($jscomp$destructuring$var116);if(0<$jscomp$destructuring$var116.length){const op=invalid?"||":"\x26\x26";return $jscomp$destructuring$var116.map(field=>fieldInvalidPredicate(field,invalid)).join(" ".concat(op," "))}}function valueIfDefined(prop,value){if(void 0!==value)return{[prop]:signalOrValueRef(value)}}function domain$1(model,channel){model=$(model.scaleName(channel));return"domain(".concat(model,")")}function isTopLevelLayer(model){var _model$parent$parent;return model.parent&&
isLayerModel(model.parent)&&(null!==(_model$parent$parent=!model.parent.parent)&&void 0!==_model$parent$parent?_model$parent$parent:isTopLevelLayer(model.parent.parent))}function parseInteractiveLegend(model,channel,legendCmpt){var _model$fieldDef;const field=null===(_model$fieldDef=model.fieldDef(channel))||void 0===_model$fieldDef?void 0:_model$fieldDef.field;forEachSelection(model,selCmpt=>{var _selCmpt$project$hasF;const proj=null!==(_selCmpt$project$hasF=selCmpt.project.hasField[field])&&void 0!==
_selCmpt$project$hasF?_selCmpt$project$hasF:selCmpt.project.hasChannel[channel];if(proj&&legendBindings.has(selCmpt)){var _legendCmpt$get;_selCmpt$project$hasF=null!==(_legendCmpt$get=legendCmpt.get("selections"))&&void 0!==_legendCmpt$get?_legendCmpt$get:[];_selCmpt$project$hasF.push(selCmpt.name);legendCmpt.set("selections",_selCmpt$project$hasF,!1);proj.hasLegend=!0}})}function onDelta(model,selCmpt,proj,size,signals){var _scaleCmpt$get,name=selCmpt.name,anchor=name+"_translate_anchor";name+="_translate_delta";
var channel=proj.channel;const hasScales=scaleBindings.has(selCmpt);selCmpt=signals.filter(s=>s.name===proj.signals[hasScales?"data":"visual"])[0];size=model.getSizeSignalRef(size).signal;model=model.getScaleComponent(channel);signals=model.get("type");const sign=hasScales&&"x"===channel?"-":"";anchor="".concat(anchor,".extent_").concat(channel);channel="".concat(sign).concat(name,".").concat(channel," / ")+(hasScales?"".concat(size):"span(".concat(anchor,")"));anchor="".concat(hasScales?"log"===
signals?"panLog":"pow"===signals?"panPow":"panLinear":"panLinear","(").concat(anchor,", ").concat(channel)+(hasScales&&"pow"===signals?", ".concat(null!==(_scaleCmpt$get=model.get("exponent"))&&void 0!==_scaleCmpt$get?_scaleCmpt$get:1):"")+")";selCmpt.on.push({events:{signal:name},update:hasScales?anchor:"clampRange(".concat(anchor,", 0, ").concat(size,")")})}function onDelta$1(model,selCmpt,proj,size,signals){var _scaleCmpt$get,name=selCmpt.name;const channel=proj.channel,hasScales=scaleBindings.has(selCmpt);
selCmpt=signals.filter(s=>s.name===proj.signals[hasScales?"data":"visual"])[0];size=model.getSizeSignalRef(size).signal;signals=model.getScaleComponent(channel);const scaleType=signals.get("type"),base=hasScales?domain$1(model,channel):selCmpt.name;model=name+"_zoom_delta";name="".concat(name).concat("_zoom_anchor",".").concat(channel);name="".concat(hasScales?"log"===scaleType?"zoomLog":"pow"===scaleType?"zoomPow":"zoomLinear":"zoomLinear","(").concat(base,", ").concat(name,", ").concat(model)+(hasScales&&
"pow"===scaleType?", ".concat(null!==(_scaleCmpt$get=signals.get("exponent"))&&void 0!==_scaleCmpt$get?_scaleCmpt$get:1):"")+")";selCmpt.on.push({events:{signal:model},update:hasScales?name:"clampRange(".concat(name,", 0, ").concat(size,")")})}function forEachTransform(selCmpt,cb){for(const t of compilers)t.has(selCmpt)&&cb(t)}function assembleInit(init,isExpr,wrap){isExpr=void 0===isExpr?!0:isExpr;wrap=void 0===wrap?identity:wrap;return isArray(init)?(init=init.map(v=>assembleInit(v,isExpr,wrap)),
isExpr?"[".concat(init.join(", "),"]"):init):isDateTime(init)?isExpr?wrap(dateTimeToExpr(init)):wrap(dateTimeToTimestamp(init)):isExpr?wrap(JSON.stringify(init)):init}function assembleUnitSelectionSignals(model,signals){forEachSelection(model,(selCmpt,selCompiler)=>{const name=selCmpt.name;let modifyExpr=selCompiler.modifyExpr(model,selCmpt);signals.push(...selCompiler.signals(model,selCmpt));forEachTransform(selCmpt,txCompiler=>{txCompiler.signals&&(signals=txCompiler.signals(model,selCmpt,signals));
txCompiler.modifyExpr&&(modifyExpr=txCompiler.modifyExpr(model,selCmpt,modifyExpr))});signals.push({name:name+"_modify",on:[{events:{signal:selCmpt.name+"_tuple"},update:"modify(".concat($(selCmpt.name+"_store"),", ").concat(modifyExpr,")")}]})});return cleanupEmptyOnArray(signals)}function assembleFacetSignals(model,signals){model.component.selection&&keys$jscomp$0(model.component.selection).length&&(model=$(model.getName("cell")),signals.unshift({name:"facet",value:{},on:[{events:eventSelector("mousemove",
"scope"),update:"isTuple(facet) ? facet : group(".concat(model,").datum")}]}));return cleanupEmptyOnArray(signals)}function assembleTopLevelSignals(model,signals){let hasSelections=!1;forEachSelection(model,(selCmpt,selCompiler)=>{const name=selCmpt.name,store=$(name+"_store");if(0===signals.filter(s=>s.name===name).length){const resolve="global"===selCmpt.resolve?"union":selCmpt.resolve,isMulti="multi"===selCmpt.type?", true)":")";signals.push({name:selCmpt.name,update:"".concat("vlSelectionResolve",
"(").concat(store,", ").concat($(resolve)).concat(isMulti)})}hasSelections=!0;selCompiler.topLevelSignals&&(signals=selCompiler.topLevelSignals(model,selCmpt,signals));forEachTransform(selCmpt,txCompiler=>{txCompiler.topLevelSignals&&(signals=txCompiler.topLevelSignals(model,selCmpt,signals))})});hasSelections&&0===signals.filter(s=>"unit"===s.name).length&&signals.unshift({name:"unit",value:{},on:[{events:"mousemove",update:"isTuple(group()) ? group() : unit"}]});return cleanupEmptyOnArray(signals)}
function assembleUnitSelectionData(model,data){const dataCopy=[...data];forEachSelection(model,selCmpt=>{const init={name:selCmpt.name+"_store"};if(selCmpt.init){const fields=selCmpt.project.items.map(proj=>{proj=Object.assign({},proj);return delete proj.signals,proj}),insert=selCmpt.init.map(i=>assembleInit(i,!1));init.values="interval"===selCmpt.type?[{unit:unitName(model,{escape:!1}),fields,values:insert}]:insert.map(i=>({unit:unitName(model,{escape:!1}),fields,values:i}))}dataCopy.filter(d=>d.name===
selCmpt.name+"_store").length||dataCopy.push(init)});return dataCopy}function assembleUnitSelectionMarks(model,marks){forEachSelection(model,(selCmpt,selCompiler)=>{marks=selCompiler.marks?selCompiler.marks(model,selCmpt,marks):marks;forEachTransform(selCmpt,txCompiler=>{txCompiler.marks&&(marks=txCompiler.marks(model,selCmpt,marks))})});return marks}function assembleLayerSelectionMarks(model,marks){for(const child of model.children)isUnitModel(child)&&(marks=assembleUnitSelectionMarks(child,marks));
return marks}function cleanupEmptyOnArray(signals){return signals.map(s=>{s.on&&!s.on.length&&delete s.on;return s})}function channelSignals(model,selCmpt,proj,init){const channel=proj.channel,vname=proj.signals.visual;proj=proj.signals.data;const hasScales=scaleBindings.has(selCmpt),scaleName=$(model.scaleName(channel));var scale=model.getScaleComponent(channel);scale=scale?scale.get("type"):void 0;const scaled=str=>"scale(".concat(scaleName,", ").concat(str,")"),size=model.getSizeSignalRef("x"===
channel?"width":"height").signal,coord="".concat(channel,"(unit)");model=events$jscomp$0(selCmpt,(def,evt)=>[...def,{events:evt.between[0],update:"[".concat(coord,", ").concat(coord,"]")},{events:evt,update:"[".concat(vname,"[0], clamp(").concat(coord,", 0, ").concat(size,")]")}]);model.push({events:{signal:selCmpt.name+"_scale_trigger"},update:scale in CONTINUOUS_DOMAIN_INDEX?"[".concat(scaled("".concat(proj,"[0]")),", ").concat(scaled("".concat(proj,"[1]")),"]"):"[0, 0]"});return hasScales?[{name:proj,
on:[]}]:[Object.assign({},{name:vname},init?{init:assembleInit(init,!0,scaled)}:{value:[]},{on:model}),Object.assign({},{name:proj},init?{init:assembleInit(init)}:{},{on:[{events:{signal:vname},update:"".concat(vname,"[0] \x3d\x3d\x3d ").concat(vname,"[1] ? null : invert(").concat(scaleName,", ").concat(vname,")")}]})]}function events$jscomp$0(selCmpt,cb){return selCmpt.events.reduce((on,evt)=>evt.between?cb(on,evt):(warn("".concat(evt," is not an ordered event stream for interval selections.")),
on),[])}function singleOrMultiSignals(model,selCmpt){const name=selCmpt.name;var fieldsSg=name+"_tuple_fields";const values=selCmpt.project.items.map(p=>{const fieldDef=model.fieldDef(p.channel);return fieldDef&&fieldDef.bin?"[".concat("(item().isVoronoi ? datum.datum : datum)","[").concat($(model.vgField(p.channel,{})),"], ")+"".concat("(item().isVoronoi ? datum.datum : datum)","[").concat($(model.vgField(p.channel,{binSuffix:"end"})),"]]"):"".concat("(item().isVoronoi ? datum.datum : datum)","[").concat($(p.field),
"]")}).join(", ");fieldsSg="unit: ".concat(unitName(model),", fields: ").concat(fieldsSg,", values");selCmpt=selCmpt.events;return[{name:name+"_tuple",on:selCmpt?[{events:selCmpt,update:"datum \x26\x26 item().mark.marktype !\x3d\x3d 'group' ? {".concat(fieldsSg,": [").concat(values,"]} : null"),force:!0}]:[]}]}function forEachSelection(model,cb){if(model=model.component.selection)for(const sel of vals$jscomp$0(model))if(!0===cb(sel,compilers$1[sel.type]))break}function unitName(model,$jscomp$destructuring$var128){({escape:$jscomp$destructuring$var128}=
void 0===$jscomp$destructuring$var128?{escape:!0}:$jscomp$destructuring$var128);$jscomp$destructuring$var128=$jscomp$destructuring$var128?$(model.name):model.name;for(model=model.parent;model&&!isFacetModel(model);)model=model.parent;if(model){const {facet}=model;for(const channel of FACET_CHANNELS)facet[channel]&&($jscomp$destructuring$var128+=" + '__facet_".concat(channel,"_' + (facet[").concat($(model.vgField(channel)),"])"))}return $jscomp$destructuring$var128}function requiresSelectionId(model){let identifier=
!1;forEachSelection(model,selCmpt=>{identifier=identifier||selCmpt.project.items.some(proj=>"_vgsid_"===proj.field)});return identifier}function ASTNode(type){this.type=type}function children$jscomp$0(node){switch(node.type){case "ArrayExpression":return node.elements;case "BinaryExpression":case "LogicalExpression":return[node.left,node.right];case "CallExpression":return[node.callee].concat(node.arguments);case "ConditionalExpression":return[node.test,node.consequent,node.alternate];case "MemberExpression":return[node.object,
node.property];case "ObjectExpression":return node.properties;case "Property":return[node.key,node.value];case "UnaryExpression":return[node.argument];default:return[]}}function assert(condition,message){if(!condition)throw Error("ASSERT: "+message);}function isDecimalDigit(ch){return 48<=ch&&57>=ch}function isHexDigit(ch){return 0<="0123456789abcdefABCDEF".indexOf(ch)}function isOctalDigit(ch){return 0<="01234567".indexOf(ch)}function isLineTerminator(ch){return 10===ch||13===ch||8232===ch||8233===
ch}function isIdentifierStart(ch){return 36===ch||95===ch||65<=ch&&90>=ch||97<=ch&&122>=ch||92===ch||128<=ch&&RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch))}function isIdentifierPart(ch){return 36===ch||95===ch||65<=ch&&90>=ch||97<=ch&&122>=ch||48<=ch&&57>=ch||92===ch||128<=ch&&RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch))}function skipComment(){for(;index$jscomp$0<length$jscomp$0;){const ch=source$jscomp$0.charCodeAt(index$jscomp$0);if(32===ch||9===ch||11===ch||12===ch||160===
ch||5760<=ch&&0<=[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279].indexOf(ch)||isLineTerminator(ch))++index$jscomp$0;else break}}function scanHexEscape(prefix){var code=0;var len="u"===prefix?4:2;for(prefix=0;prefix<len;++prefix)if(index$jscomp$0<length$jscomp$0&&isHexDigit(source$jscomp$0[index$jscomp$0])){var ch=source$jscomp$0[index$jscomp$0++];code=16*code+"0123456789abcdef".indexOf(ch.toLowerCase())}else throwError({},"Unexpected token %0","ILLEGAL");return String.fromCharCode(code)}
function getEscapedIdentifier(){var ch=source$jscomp$0.charCodeAt(index$jscomp$0++);var id=String.fromCharCode(ch);92===ch&&(117!==source$jscomp$0.charCodeAt(index$jscomp$0)&&throwError({},"Unexpected token %0","ILLEGAL"),++index$jscomp$0,(ch=scanHexEscape("u"))&&"\\"!==ch&&isIdentifierStart(ch.charCodeAt(0))||throwError({},"Unexpected token %0","ILLEGAL"),id=ch);for(;index$jscomp$0<length$jscomp$0;){ch=source$jscomp$0.charCodeAt(index$jscomp$0);if(!isIdentifierPart(ch))break;++index$jscomp$0;id+=
String.fromCharCode(ch);92===ch&&(id=id.substr(0,id.length-1),117!==source$jscomp$0.charCodeAt(index$jscomp$0)&&throwError({},"Unexpected token %0","ILLEGAL"),++index$jscomp$0,(ch=scanHexEscape("u"))&&"\\"!==ch&&isIdentifierPart(ch.charCodeAt(0))||throwError({},"Unexpected token %0","ILLEGAL"),id+=ch)}return id}function scanPunctuator(){var start=index$jscomp$0,code=source$jscomp$0.charCodeAt(index$jscomp$0),ch1=source$jscomp$0[index$jscomp$0];switch(code){case 46:case 40:case 41:case 59:case 44:case 123:case 125:case 91:case 93:case 58:case 63:case 126:return++index$jscomp$0,
{type:7,value:String.fromCharCode(code),start,end:index$jscomp$0};default:var code2=source$jscomp$0.charCodeAt(index$jscomp$0+1);if(61===code2)switch(code){case 43:case 45:case 47:case 60:case 62:case 94:case 124:case 37:case 38:case 42:return index$jscomp$0+=2,{type:7,value:String.fromCharCode(code)+String.fromCharCode(code2),start,end:index$jscomp$0};case 33:case 61:return index$jscomp$0+=2,61===source$jscomp$0.charCodeAt(index$jscomp$0)&&++index$jscomp$0,{type:7,value:source$jscomp$0.slice(start,
index$jscomp$0),start,end:index$jscomp$0}}}code=source$jscomp$0.substr(index$jscomp$0,4);if("\x3e\x3e\x3e\x3d"===code)return index$jscomp$0+=4,{type:7,value:code,start,end:index$jscomp$0};code=code.substr(0,3);if("\x3e\x3e\x3e"===code||"\x3c\x3c\x3d"===code||"\x3e\x3e\x3d"===code)return index$jscomp$0+=3,{type:7,value:code,start,end:index$jscomp$0};code=code.substr(0,2);if(ch1===code[1]&&0<="+-\x3c\x3e\x26|".indexOf(ch1)||"\x3d\x3e"===code)return index$jscomp$0+=2,{type:7,value:code,start,end:index$jscomp$0};
if(0<="\x3c\x3e\x3d!+-*%\x26|^/".indexOf(ch1))return++index$jscomp$0,{type:7,value:ch1,start,end:index$jscomp$0};throwError({},"Unexpected token %0","ILLEGAL")}function scanNumericLiteral(){var ch=source$jscomp$0[index$jscomp$0];assert(isDecimalDigit(ch.charCodeAt(0))||"."===ch,"Numeric literal must start with a decimal digit or a decimal point");var start=index$jscomp$0;var number="";if("."!==ch){number=source$jscomp$0[index$jscomp$0++];ch=source$jscomp$0[index$jscomp$0];if("0"===number){if("x"===
ch||"X"===ch){++index$jscomp$0;for(number="";index$jscomp$0<length$jscomp$0&&isHexDigit(source$jscomp$0[index$jscomp$0]);)number+=source$jscomp$0[index$jscomp$0++];0===number.length&&throwError({},"Unexpected token %0","ILLEGAL");isIdentifierStart(source$jscomp$0.charCodeAt(index$jscomp$0))&&throwError({},"Unexpected token %0","ILLEGAL");return start={type:6,value:parseInt("0x"+number,16),start,end:index$jscomp$0}}if(isOctalDigit(ch)){for(number="0"+source$jscomp$0[index$jscomp$0++];index$jscomp$0<
length$jscomp$0&&isOctalDigit(source$jscomp$0[index$jscomp$0]);)number+=source$jscomp$0[index$jscomp$0++];(isIdentifierStart(source$jscomp$0.charCodeAt(index$jscomp$0))||isDecimalDigit(source$jscomp$0.charCodeAt(index$jscomp$0)))&&throwError({},"Unexpected token %0","ILLEGAL");return start={type:6,value:parseInt(number,8),octal:!0,start,end:index$jscomp$0}}ch&&isDecimalDigit(ch.charCodeAt(0))&&throwError({},"Unexpected token %0","ILLEGAL")}for(;isDecimalDigit(source$jscomp$0.charCodeAt(index$jscomp$0));)number+=
source$jscomp$0[index$jscomp$0++];ch=source$jscomp$0[index$jscomp$0]}if("."===ch){for(number+=source$jscomp$0[index$jscomp$0++];isDecimalDigit(source$jscomp$0.charCodeAt(index$jscomp$0));)number+=source$jscomp$0[index$jscomp$0++];ch=source$jscomp$0[index$jscomp$0]}if("e"===ch||"E"===ch){number+=source$jscomp$0[index$jscomp$0++];ch=source$jscomp$0[index$jscomp$0];if("+"===ch||"-"===ch)number+=source$jscomp$0[index$jscomp$0++];if(isDecimalDigit(source$jscomp$0.charCodeAt(index$jscomp$0)))for(;isDecimalDigit(source$jscomp$0.charCodeAt(index$jscomp$0));)number+=
source$jscomp$0[index$jscomp$0++];else throwError({},"Unexpected token %0","ILLEGAL")}isIdentifierStart(source$jscomp$0.charCodeAt(index$jscomp$0))&&throwError({},"Unexpected token %0","ILLEGAL");return{type:6,value:parseFloat(number),start,end:index$jscomp$0}}function testRegExp(pattern,flags){let tmp=pattern;0<=flags.indexOf("u")&&(tmp=tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g,($0,$1)=>{if(1114111>=parseInt($1,16))return"x";throwError({},"Invalid regular expression")}).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
"x"));try{new RegExp(tmp)}catch(e){throwError({},"Invalid regular expression")}try{return new RegExp(pattern,flags)}catch(exception){return null}}function advance(){skipComment();if(index$jscomp$0>=length$jscomp$0)return{type:2,start:index$jscomp$0,end:index$jscomp$0};var ch=source$jscomp$0.charCodeAt(index$jscomp$0);if(isIdentifierStart(ch)){ch=index$jscomp$0;if(92===source$jscomp$0.charCodeAt(index$jscomp$0))var id=getEscapedIdentifier();else a:{for(id=index$jscomp$0++;index$jscomp$0<length$jscomp$0;){var ch$jscomp$0=
source$jscomp$0.charCodeAt(index$jscomp$0);if(92===ch$jscomp$0){index$jscomp$0=id;id=getEscapedIdentifier();break a}if(isIdentifierPart(ch$jscomp$0))++index$jscomp$0;else break}id=source$jscomp$0.slice(id,index$jscomp$0)}return{type:1===id.length?3:keywords.hasOwnProperty(id)?4:"null"===id?5:"true"===id||"false"===id?1:3,value:id,start:ch,end:index$jscomp$0}}if(40===ch||41===ch||59===ch)return scanPunctuator();if(39===ch||34===ch){var str="";ch$jscomp$0=!1;ch=source$jscomp$0[index$jscomp$0];assert("'"===
ch||'"'===ch,"String literal must starts with a quote");id=index$jscomp$0;for(++index$jscomp$0;index$jscomp$0<length$jscomp$0;){var ch$jscomp$1=source$jscomp$0[index$jscomp$0++];if(ch$jscomp$1===ch){ch="";break}else if("\\"===ch$jscomp$1)if((ch$jscomp$1=source$jscomp$0[index$jscomp$0++])&&isLineTerminator(ch$jscomp$1.charCodeAt(0)))"\r"===ch$jscomp$1&&"\n"===source$jscomp$0[index$jscomp$0]&&++index$jscomp$0;else switch(ch$jscomp$1){case "u":case "x":if("{"===source$jscomp$0[index$jscomp$0]){++index$jscomp$0;
var code=source$jscomp$0[index$jscomp$0];ch$jscomp$1=0;for("}"===code&&throwError({},"Unexpected token %0","ILLEGAL");index$jscomp$0<length$jscomp$0;){code=source$jscomp$0[index$jscomp$0++];if(!isHexDigit(code))break;ch$jscomp$1=16*ch$jscomp$1+"0123456789abcdef".indexOf(code.toLowerCase())}(1114111<ch$jscomp$1||"}"!==code)&&throwError({},"Unexpected token %0","ILLEGAL");ch$jscomp$1=65535>=ch$jscomp$1?String.fromCharCode(ch$jscomp$1):String.fromCharCode((ch$jscomp$1-65536>>10)+55296,(ch$jscomp$1-65536&
1023)+56320);str+=ch$jscomp$1}else str+=scanHexEscape(ch$jscomp$1);break;case "n":str+="\n";break;case "r":str+="\r";break;case "t":str+="\t";break;case "b":str+="\b";break;case "f":str+="\f";break;case "v":str+="\x0B";break;default:isOctalDigit(ch$jscomp$1)?(code="01234567".indexOf(ch$jscomp$1),0!==code&&(ch$jscomp$0=!0),index$jscomp$0<length$jscomp$0&&isOctalDigit(source$jscomp$0[index$jscomp$0])&&(ch$jscomp$0=!0,code=8*code+"01234567".indexOf(source$jscomp$0[index$jscomp$0++]),0<="0123".indexOf(ch$jscomp$1)&&
index$jscomp$0<length$jscomp$0&&isOctalDigit(source$jscomp$0[index$jscomp$0])&&(code=8*code+"01234567".indexOf(source$jscomp$0[index$jscomp$0++]))),str+=String.fromCharCode(code)):str+=ch$jscomp$1}else if(isLineTerminator(ch$jscomp$1.charCodeAt(0)))break;else str+=ch$jscomp$1}""!==ch&&throwError({},"Unexpected token %0","ILLEGAL");return{type:8,value:str,octal:ch$jscomp$0,start:id,end:index$jscomp$0}}return 46===ch?isDecimalDigit(source$jscomp$0.charCodeAt(index$jscomp$0+1))?scanNumericLiteral():
scanPunctuator():isDecimalDigit(ch)?scanNumericLiteral():scanPunctuator()}function lex(){const token=lookahead;index$jscomp$0=token.end;lookahead=advance();index$jscomp$0=token.end;return token}function peek(){const pos=index$jscomp$0;lookahead=advance();index$jscomp$0=pos}function finishBinaryExpression(operator,left,right){const node=new ASTNode("||"===operator||"\x26\x26"===operator?"LogicalExpression":"BinaryExpression");node.operator=operator;node.left=left;node.right=right;return node}function finishIdentifier(name){const node=
new ASTNode("Identifier");node.name=name;return node}function finishLiteral(token){const node=new ASTNode("Literal");node.value=token.value;node.raw=source$jscomp$0.slice(token.start,token.end);token.regex&&("//"===node.raw&&(node.raw="/(?:)/"),node.regex=token.regex);return node}function finishMemberExpression(accessor,object,property){const node=new ASTNode("MemberExpression");node.computed="["===accessor;node.object=object;node.property=property;node.computed||(property.member=!0);return node}
function finishProperty(kind,key,value){const node=new ASTNode("Property");node.key=key;node.value=value;node.kind=kind;return node}function throwError(token,messageFormat){var args=Array.prototype.slice.call(arguments,2),msg=messageFormat.replace(/%(\d)/g,(whole,index)=>{assert(index<args.length,"Message reference must be in range");return args[index]});var error=Error(msg);error.index=index$jscomp$0;error.description=msg;throw error;}function throwUnexpected(token){2===token.type&&throwError(token,
"Unexpected end of input");6===token.type&&throwError(token,"Unexpected number");8===token.type&&throwError(token,"Unexpected string");3===token.type&&throwError(token,"Unexpected identifier");4===token.type&&throwError(token,"Unexpected reserved word");throwError(token,"Unexpected token %0",token.value)}function expect(value){const token=lex();7===token.type&&token.value===value||throwUnexpected(token)}function match(value){return 7===lookahead.type&&lookahead.value===value}function parseObjectPropertyKey(){index$jscomp$0=
lookahead.start;const token=lex();return 8===token.type||6===token.type?(token.octal&&throwError(token,"Octal literals are not allowed in strict mode."),finishLiteral(token)):finishIdentifier(token.value)}function parsePrimaryExpression(){if(match("(")){expect("(");var type=parseExpression();expect(")");return type}if(match("[")){type=[];index$jscomp$0=lookahead.start;for(expect("[");!match("]");)match(",")?(lex(),type.push(null)):(type.push(parseConditionalExpression()),match("]")||expect(","));
lex();var JSCompiler_object_inline_value_5449=new ASTNode("ArrayExpression");JSCompiler_object_inline_value_5449.elements=type;return type=JSCompiler_object_inline_value_5449}if(match("{")){type=[];JSCompiler_object_inline_value_5449={};var JSCompiler_object_inline_literal_5450=String;index$jscomp$0=lookahead.start;for(expect("{");!match("}");){index$jscomp$0=lookahead.start;var JSCompiler_object_inline_value_5451=lookahead;if(3===JSCompiler_object_inline_value_5451.type){var JSCompiler_object_inline_literal_5452=
parseObjectPropertyKey();expect(":");JSCompiler_object_inline_value_5451=parseConditionalExpression();JSCompiler_object_inline_value_5451=finishProperty("init",JSCompiler_object_inline_literal_5452,JSCompiler_object_inline_value_5451)}else 2===JSCompiler_object_inline_value_5451.type||7===JSCompiler_object_inline_value_5451.type?(throwUnexpected(JSCompiler_object_inline_value_5451),JSCompiler_object_inline_value_5451=void 0):(JSCompiler_object_inline_literal_5452=parseObjectPropertyKey(),expect(":"),
JSCompiler_object_inline_value_5451=parseConditionalExpression(),JSCompiler_object_inline_value_5451=finishProperty("init",JSCompiler_object_inline_literal_5452,JSCompiler_object_inline_value_5451));JSCompiler_object_inline_literal_5452="Identifier"===JSCompiler_object_inline_value_5451.key.type?JSCompiler_object_inline_value_5451.key.name:JSCompiler_object_inline_literal_5450(JSCompiler_object_inline_value_5451.key.value);JSCompiler_object_inline_literal_5452="$"+JSCompiler_object_inline_literal_5452;
Object.prototype.hasOwnProperty.call(JSCompiler_object_inline_value_5449,JSCompiler_object_inline_literal_5452)?throwError({},"Duplicate data property in object literal not allowed in strict mode"):JSCompiler_object_inline_value_5449[JSCompiler_object_inline_literal_5452]=!0;type.push(JSCompiler_object_inline_value_5451);match("}")||expect(",")}expect("}");JSCompiler_object_inline_value_5449=new ASTNode("ObjectExpression");JSCompiler_object_inline_value_5449.properties=type;return type=JSCompiler_object_inline_value_5449}type=
lookahead.type;index$jscomp$0=lookahead.start;if(3===type||legalKeywords[lookahead.value])JSCompiler_object_inline_value_5449=finishIdentifier(lex().value);else if(8===type||6===type)lookahead.octal&&throwError(lookahead,"Octal literals are not allowed in strict mode."),JSCompiler_object_inline_value_5449=finishLiteral(lex());else{if(4===type)throw Error("Disabled.");if(1===type)type=lex(),type.value="true"===type.value,JSCompiler_object_inline_value_5449=finishLiteral(type);else if(5===type)type=
lex(),type.value=null,JSCompiler_object_inline_value_5449=finishLiteral(type);else if(match("/")||match("/\x3d")){var value;lookahead=null;skipComment();type=index$jscomp$0;JSCompiler_object_inline_value_5449=source$jscomp$0[index$jscomp$0];assert("/"===JSCompiler_object_inline_value_5449,"Regular expression literal must start with a slash");JSCompiler_object_inline_literal_5450=source$jscomp$0[index$jscomp$0++];for(JSCompiler_object_inline_literal_5452=JSCompiler_object_inline_value_5451=!1;index$jscomp$0<
length$jscomp$0;)if(JSCompiler_object_inline_value_5449=source$jscomp$0[index$jscomp$0++],JSCompiler_object_inline_literal_5450+=JSCompiler_object_inline_value_5449,"\\"===JSCompiler_object_inline_value_5449)JSCompiler_object_inline_value_5449=source$jscomp$0[index$jscomp$0++],isLineTerminator(JSCompiler_object_inline_value_5449.charCodeAt(0))&&throwError({},"Invalid regular expression: missing /"),JSCompiler_object_inline_literal_5450+=JSCompiler_object_inline_value_5449;else if(isLineTerminator(JSCompiler_object_inline_value_5449.charCodeAt(0)))throwError({},
"Invalid regular expression: missing /");else if(JSCompiler_object_inline_value_5451)"]"===JSCompiler_object_inline_value_5449&&(JSCompiler_object_inline_value_5451=!1);else if("/"===JSCompiler_object_inline_value_5449){JSCompiler_object_inline_literal_5452=!0;break}else"["===JSCompiler_object_inline_value_5449&&(JSCompiler_object_inline_value_5451=!0);JSCompiler_object_inline_literal_5452||throwError({},"Invalid regular expression: missing /");JSCompiler_object_inline_value_5449=JSCompiler_object_inline_literal_5450.substr(1,
JSCompiler_object_inline_literal_5450.length-2);for(value=JSCompiler_object_inline_literal_5452="";index$jscomp$0<length$jscomp$0;){JSCompiler_object_inline_value_5451=source$jscomp$0[index$jscomp$0];if(!isIdentifierPart(JSCompiler_object_inline_value_5451.charCodeAt(0)))break;++index$jscomp$0;"\\"===JSCompiler_object_inline_value_5451&&index$jscomp$0<length$jscomp$0?throwError({},"Unexpected token %0","ILLEGAL"):(value+=JSCompiler_object_inline_value_5451,JSCompiler_object_inline_literal_5452+=JSCompiler_object_inline_value_5451)}0<=
value.search(/[^gimuy]/g)&&throwError({},"Invalid regular expression",value);JSCompiler_object_inline_value_5451=value;value=testRegExp(JSCompiler_object_inline_value_5449,JSCompiler_object_inline_value_5451);JSCompiler_object_inline_value_5449=finishLiteral({literal:JSCompiler_object_inline_literal_5450+JSCompiler_object_inline_literal_5452,value,regex:{pattern:JSCompiler_object_inline_value_5449,flags:JSCompiler_object_inline_value_5451},start:type,end:index$jscomp$0});peek()}else throwUnexpected(lex())}return JSCompiler_object_inline_value_5449}
function parsePostfixExpression(){var JSCompiler_inline_result;for(JSCompiler_inline_result=parsePrimaryExpression();;)if(match(".")){expect(".");index$jscomp$0=lookahead.start;var args=lex();3===args.type||4===args.type||1===args.type||5===args.type||throwUnexpected(args);args=finishIdentifier(args.value);JSCompiler_inline_result=finishMemberExpression(".",JSCompiler_inline_result,args)}else if(match("(")){args=[];expect("(");if(!match(")"))for(;index$jscomp$0<length$jscomp$0;){args.push(parseConditionalExpression());
if(match(")"))break;expect(",")}expect(")");{const node=new ASTNode("CallExpression");node.callee=JSCompiler_inline_result;node.arguments=args;JSCompiler_inline_result=node}}else if(match("["))expect("["),args=parseExpression(),expect("]"),JSCompiler_inline_result=finishMemberExpression("[",JSCompiler_inline_result,args);else break;if(7===lookahead.type&&(match("++")||match("--")))throw Error("Disabled.");return JSCompiler_inline_result}function parseUnaryExpression(){if(7!==lookahead.type&&4!==lookahead.type)var expr=
parsePostfixExpression();else{if(match("++")||match("--"))throw Error("Disabled.");if(match("+")||match("-")||match("~")||match("!")){var token=lex();expr=parseUnaryExpression();{token=token.value;const node=new ASTNode("UnaryExpression");node.operator=token;node.argument=expr;node.prefix=!0;expr=node}}else{if(4===lookahead.type&&"delete"===lookahead.value||4===lookahead.type&&"void"===lookahead.value||4===lookahead.type&&"typeof"===lookahead.value)throw Error("Disabled.");expr=parsePostfixExpression()}}return expr}
function binaryPrecedence(token){let prec=0;if(7!==token.type&&4!==token.type)return 0;switch(token.value){case "||":prec=1;break;case "\x26\x26":prec=2;break;case "|":prec=3;break;case "^":prec=4;break;case "\x26":prec=5;break;case "\x3d\x3d":case "!\x3d":case "\x3d\x3d\x3d":case "!\x3d\x3d":prec=6;break;case "\x3c":case "\x3e":case "\x3c\x3d":case "\x3e\x3d":case "instanceof":case "in":prec=7;break;case "\x3c\x3c":case "\x3e\x3e":case "\x3e\x3e\x3e":prec=8;break;case "+":case "-":prec=9;break;case "*":case "/":case "%":prec=
11}return prec}function parseConditionalExpression(){var consequent=lookahead;var expr=parseUnaryExpression();var token=lookahead;var alternate=binaryPrecedence(token);if(0===alternate)var expr$jscomp$0=expr;else{token.prec=alternate;lex();consequent=[consequent,lookahead];var right=parseUnaryExpression();for(expr$jscomp$0=[expr,token,right];0<(alternate=binaryPrecedence(lookahead));){for(;2<expr$jscomp$0.length&&alternate<=expr$jscomp$0[expr$jscomp$0.length-2].prec;)right=expr$jscomp$0.pop(),token=
expr$jscomp$0.pop().value,expr=expr$jscomp$0.pop(),consequent.pop(),expr=finishBinaryExpression(token,expr,right),expr$jscomp$0.push(expr);token=lex();token.prec=alternate;expr$jscomp$0.push(token);consequent.push(lookahead);expr=parseUnaryExpression();expr$jscomp$0.push(expr)}alternate=expr$jscomp$0.length-1;expr=expr$jscomp$0[alternate];for(consequent.pop();1<alternate;)consequent.pop(),expr=finishBinaryExpression(expr$jscomp$0[alternate-1].value,expr$jscomp$0[alternate-2],expr),alternate-=2;expr$jscomp$0=
expr}match("?")&&(lex(),consequent=parseConditionalExpression(),expect(":"),alternate=parseConditionalExpression(),expr=new ASTNode("ConditionalExpression"),expr.test=expr$jscomp$0,expr.consequent=consequent,expr.alternate=alternate,expr$jscomp$0=expr);return expr$jscomp$0}function parseExpression(){const expr=parseConditionalExpression();if(match(","))throw Error("Disabled.");return expr}function parser(code){source$jscomp$0=code;index$jscomp$0=0;length$jscomp$0=source$jscomp$0.length;lookahead=
null;peek();code=parseExpression();if(2!==lookahead.type)throw Error("Unexpect token after expression.");return code}function getName(node){const name=[];if("Identifier"===node.type)return[node.name];if("Literal"===node.type)return[node.value];"MemberExpression"===node.type&&(name.push(...getName(node.object)),name.push(...getName(node.property)));return name}function startsWithDatum(node){return"MemberExpression"===node.object.type?startsWithDatum(node.object):"datum"===node.object.name}function getDependentFields(expression){expression=
parser(expression);const dependents=new Set;expression.visit(node=>{"MemberExpression"===node.type&&startsWithDatum(node)&&dependents.add(getName(node).slice(1).join("."))});return dependents}function parseUnitSelection(model,selDefs){const selCmpts={},selectionConfig=model.config.selection;for(const name of keys$jscomp$0(null!==selDefs&&void 0!==selDefs?selDefs:{})){const selDef=duplicate(selDefs[name]);var $jscomp$destructuring$var130=Object.assign({},selectionConfig[selDef.type]);$jscomp$destructuring$var130=
(delete $jscomp$destructuring$var130.fields,delete $jscomp$destructuring$var130.encodings,$jscomp$destructuring$var130);for(const key in $jscomp$destructuring$var130)if(!("encodings"===key&&selDef.fields||"fields"===key&&selDef.encodings)&&("mark"===key&&(selDef[key]=Object.assign({},$jscomp$destructuring$var130[key],selDef[key])),void 0===selDef[key]||!0===selDef[key])){var _cfg$key;selDef[key]=null!==(_cfg$key=$jscomp$destructuring$var130[key])&&void 0!==_cfg$key?_cfg$key:selDef[key]}$jscomp$destructuring$var130=
varName(name);const selCmpt=selCmpts[$jscomp$destructuring$var130]=Object.assign({},selDef,{name:$jscomp$destructuring$var130,events:isString(selDef.on)?eventSelector(selDef.on,"scope"):duplicate(selDef.on)});forEachTransform(selCmpt,txCompiler=>{txCompiler.has(selCmpt)&&txCompiler.parse&&txCompiler.parse(model,selCmpt,selDef,selDefs[name])})}return selCmpts}function parseSelectionPredicate(model,selections,dfnode,datum){datum=void 0===datum?"datum":datum;const stores=[];selections=logicalExpr(selections,
function(name){var vname=varName(name);name=model.getSelectionComponent(vname,name);vname=$(vname+"_store");if(name.project.timeUnit){const child=null!==dfnode&&void 0!==dfnode?dfnode:model.component.data.raw,tunode=name.project.timeUnit.clone();child.parent?tunode.insertAsParentOf(child):child.parent=tunode}"none"!==name.empty&&stores.push(vname);return"vlSelectionTest(".concat(vname,", ").concat(datum)+("global"===name.resolve?")":", ".concat($(name.resolve),")"))});return(stores.length?"!("+stores.map(s=>
"length(data(".concat(s,"))")).join(" || ")+") || ":"")+"(".concat(selections,")")}function parseSelectionBinExtent(selCmpt,extent){const encoding=extent.encoding;let field=extent.field;if(!encoding&&!field)field=selCmpt.project.items[0].field,1<selCmpt.project.items.length&&warn('A "field" or "encoding" must be specified when using a selection as a scale domain. '+'Using "field": '.concat($(field),"."));else if(encoding&&!field){const encodings=selCmpt.project.items.filter(p=>p.channel===encoding);
!encodings.length||1<encodings.length?(field=selCmpt.project.items[0].field,warn((encodings.length?"Multiple ":"No ")+"matching ".concat($(encoding)," encoding found for selection ").concat($(extent.selection),". ")+'Using "field": '.concat($(field),"."))):field=encodings[0].field}return"".concat(selCmpt.name,"[").concat($(field),"]")}function materializeSelections(model,main){forEachSelection(model,selCmpt=>{const selection=selCmpt.name,lookupName=model.getName("lookup_".concat(selection));model.component.data.outputNodes[lookupName]=
selCmpt.materialized=new OutputNode(new FilterNode(main,model,{selection}),lookupName,DataSourceType.Lookup,model.component.data.outputNodeRefCounts)})}function expression$jscomp$0(model,filterOp,node){return logicalExpr(filterOp,predicate=>isString(predicate)?predicate:(null===predicate||void 0===predicate?0:predicate.selection)?parseSelectionPredicate(model,predicate.selection,node):fieldFilterExpression(predicate))}function assembleTitle(title,config){if(title)return isArray(title)&&!isText(title)?
title.map(fieldDef=>titleFormatter(fieldDef,config)).join(", "):title}function setAxisEncode(axis,part,vgProp,vgRef){var _axis$encode,_axis$encode$part,_axis$encode$part$upd;axis.encode=null!==(_axis$encode=axis.encode)&&void 0!==_axis$encode?_axis$encode:{};axis.encode[part]=null!==(_axis$encode$part=axis.encode[part])&&void 0!==_axis$encode$part?_axis$encode$part:{};axis.encode[part].update=null!==(_axis$encode$part$upd=axis.encode[part].update)&&void 0!==_axis$encode$part$upd?_axis$encode$part$upd:
{};axis.encode[part].update[vgProp]=vgRef}function assembleAxis(axisCmpt,kind,config,opt){opt=void 0===opt?{header:!1}:opt;var $jscomp$destructuring$var131=axisCmpt.combine(),$jscomp$destructuring$var132=Object.assign({},$jscomp$destructuring$var131),disable=$jscomp$destructuring$var131.disable;const orient=$jscomp$destructuring$var131.orient,scale=$jscomp$destructuring$var131.scale,labelExpr=$jscomp$destructuring$var131.labelExpr,title=$jscomp$destructuring$var131.title;$jscomp$destructuring$var131=
$jscomp$destructuring$var131.zindex;$jscomp$destructuring$var132=(delete $jscomp$destructuring$var132.disable,delete $jscomp$destructuring$var132.orient,delete $jscomp$destructuring$var132.scale,delete $jscomp$destructuring$var132.labelExpr,delete $jscomp$destructuring$var132.title,delete $jscomp$destructuring$var132.zindex,$jscomp$destructuring$var132);if(!disable){for(const prop in $jscomp$destructuring$var132){var propType=AXIS_PROPERTY_TYPE[prop];disable=$jscomp$destructuring$var132[prop];if(propType&&
propType!==kind&&"both"!==propType)delete $jscomp$destructuring$var132[prop];else if(isConditionalAxisValue(disable)){propType=disable;disable=Object.assign({},propType);propType=propType.condition;disable=(delete disable.condition,disable);propType=array$jscomp$0(propType);const propIndex=CONDITIONAL_AXIS_PROP_INDEX[prop];if(propIndex){const {vgProp,part}=propIndex;disable=[...propType.map(c=>{var $jscomp$destructuring$var136=Object.assign({},c);c=c.test;$jscomp$destructuring$var136=(delete $jscomp$destructuring$var136.test,
$jscomp$destructuring$var136);return Object.assign({},{test:expression$jscomp$0(null,c)},$jscomp$destructuring$var136)}),disable];setAxisEncode($jscomp$destructuring$var132,part,vgProp,disable);delete $jscomp$destructuring$var132[prop]}else null===propIndex&&(disable={signal:propType.map(c=>{var $jscomp$destructuring$var138=Object.assign({},c);c=c.test;$jscomp$destructuring$var138=(delete $jscomp$destructuring$var138.test,$jscomp$destructuring$var138);return"".concat(expression$jscomp$0(null,c)," ? ").concat(exprFromValueOrSignalRef($jscomp$destructuring$var138),
" : ")}).join("")+exprFromValueOrSignalRef(disable)},$jscomp$destructuring$var132[prop]=disable)}else if(isSignalRef(disable)&&(propType=CONDITIONAL_AXIS_PROP_INDEX[prop])){const {vgProp,part}=propType;setAxisEncode($jscomp$destructuring$var132,part,vgProp,disable);delete $jscomp$destructuring$var132[prop]}}if("grid"===kind){if($jscomp$destructuring$var132.grid)return $jscomp$destructuring$var132.encode&&({grid:config}=$jscomp$destructuring$var132.encode,$jscomp$destructuring$var132.encode=Object.assign({},
config?{grid:config}:{}),isEmpty($jscomp$destructuring$var132.encode)&&delete $jscomp$destructuring$var132.encode),Object.assign({},{scale,orient},$jscomp$destructuring$var132,{domain:!1,labels:!1,aria:!1,maxExtent:0,minExtent:0,ticks:!1,zindex:getFirstDefined($jscomp$destructuring$var131,0)})}else if(opt.header||!axisCmpt.mainExtracted){if(void 0!==labelExpr){var _axis$encode2,_axis$encode2$labels;kind=labelExpr;(null===(_axis$encode2=$jscomp$destructuring$var132.encode)||void 0===_axis$encode2?
0:null===(_axis$encode2$labels=_axis$encode2.labels)||void 0===_axis$encode2$labels?0:_axis$encode2$labels.update)&&isSignalRef($jscomp$destructuring$var132.encode.labels.update.text)&&(kind=replaceAll(labelExpr,"datum.label",$jscomp$destructuring$var132.encode.labels.update.text.signal));setAxisEncode($jscomp$destructuring$var132,"labels","text",{signal:kind})}null===$jscomp$destructuring$var132.labelAlign&&delete $jscomp$destructuring$var132.labelAlign;if($jscomp$destructuring$var132.encode){for(const part of AXIS_PARTS)axisCmpt.hasAxisPart(part)||
delete $jscomp$destructuring$var132.encode[part];isEmpty($jscomp$destructuring$var132.encode)&&delete $jscomp$destructuring$var132.encode}axisCmpt=assembleTitle(title,config);return Object.assign({},{scale,orient,grid:!1},axisCmpt?{title:axisCmpt}:{},$jscomp$destructuring$var132,!1===config.aria?{aria:!1}:{},{zindex:getFirstDefined($jscomp$destructuring$var131,0)})}}}function assembleAxisSignals(model){const {axes}=model.component,signals=[];for(const channel of POSITION_SCALE_CHANNELS)if(axes[channel])for(const axis of axes[channel])if(!axis.get("disable")&&
!axis.get("gridScale")){const sizeType="x"===channel?"height":"width",update=model.getSizeSignalRef(sizeType).signal;sizeType!==update&&signals.push({name:sizeType,update})}return signals}function assembleAxes(axisComponents,config){const {x=[],y=[]}=axisComponents;return[...x.map(a=>assembleAxis(a,"grid",config)),...y.map(a=>assembleAxis(a,"grid",config)),...x.map(a=>assembleAxis(a,"main",config)),...y.map(a=>assembleAxis(a,"main",config))].filter(a=>a)}function getAxisConfigFromConfigTypes(configTypes,
config,channel,orient){return Object.assign.apply(null,[{},...configTypes.map(configType=>{if("axisOrient"===configType){configType="x"===channel?"bottom":"left";const orientConfig1=config["x"===channel?"axisBottom":"axisLeft"]||{},orientConfig2=config["x"===channel?"axisTop":"axisRight"]||{},props=new Set([...keys$jscomp$0(orientConfig1),...keys$jscomp$0(orientConfig2)]),conditionalOrientAxisConfig={};for(const prop of props.values())conditionalOrientAxisConfig[prop]={signal:"".concat(orient.signal,
' \x3d\x3d\x3d "').concat(configType,'" ? ').concat(signalOrStringValue(orientConfig1[prop])," : ").concat(signalOrStringValue(orientConfig2[prop]))};return conditionalOrientAxisConfig}return config[configType]})])}function getAxisConfigs(channel,scaleType,orient,config){var typeBasedConfigTypes="band"===scaleType?["axisDiscrete","axisBand"]:"point"===scaleType?["axisDiscrete","axisPoint"]:scaleType in QUANTITATIVE_SCALES_INDEX?["axisQuantitative"]:"time"===scaleType||"utc"===scaleType?["axisTemporal"]:
[];const axisChannel="x"===channel?"axisX":"axisY";scaleType=isSignalRef(orient)?"axisOrient":"axis"+titleCase(orient);typeBasedConfigTypes=[...typeBasedConfigTypes,...typeBasedConfigTypes.map(c=>axisChannel+c.substr(4))];scaleType=["axis",scaleType,axisChannel];return{vlOnlyAxisConfig:getAxisConfigFromConfigTypes(typeBasedConfigTypes,config,channel,orient),vgAxisConfig:getAxisConfigFromConfigTypes(scaleType,config,channel,orient),axisConfigStyle:getAxisConfigStyle([...scaleType,...typeBasedConfigTypes],
config)}}function getAxisConfigStyle(axisConfigTypes,config){const toMerge=[{}];for(const configType of axisConfigTypes){var _config$configType;if(axisConfigTypes=null===(_config$configType=config[configType])||void 0===_config$configType?void 0:_config$configType.style){axisConfigTypes=array$jscomp$0(axisConfigTypes);for(const s of axisConfigTypes)toMerge.push(config.style[s])}}return Object.assign.apply(null,toMerge)}function getAxisConfig(property,styleConfigIndex,style,axisConfigs){axisConfigs=
void 0===axisConfigs?{}:axisConfigs;styleConfigIndex=getStyleConfig(property,style,styleConfigIndex);if(void 0!==styleConfigIndex)return{configFrom:"style",configValue:styleConfigIndex};for(const configFrom of["vlOnlyAxisConfig","vgAxisConfig","axisConfigStyle"]){var _axisConfigs$configFr;if(void 0!==(null===(_axisConfigs$configFr=axisConfigs[configFrom])||void 0===_axisConfigs$configFr?void 0:_axisConfigs$configFr[property]))return{configFrom,configValue:axisConfigs[configFrom][property]}}return{}}
function getLabelAngle(fieldOrDatumDef,axis,channel,styleConfig,axisConfigs){const labelAngle=null===axis||void 0===axis?void 0:axis.labelAngle;if(void 0!==labelAngle)return isSignalRef(labelAngle)?labelAngle:normalizeAngle(labelAngle);({configValue:axis}=getAxisConfig("labelAngle",styleConfig,null===axis||void 0===axis?void 0:axis.style,axisConfigs));if(void 0!==axis)return normalizeAngle(axis);if("x"===channel&&contains(["nominal","ordinal"],fieldOrDatumDef.type)&&(!isFieldDef(fieldOrDatumDef)||
!fieldOrDatumDef.timeUnit))return 270}function normalizeAngleExpr(angle){return"(((".concat(angle.signal," % 360) + 360) % 360)")}function defaultLabelBaseline(angle,orient,channel,alwaysIncludeMiddle){if(void 0!==angle)return"x"===channel?isSignalRef(angle)?(alwaysIncludeMiddle=normalizeAngleExpr(angle),orient=isSignalRef(orient)?"(".concat(orient.signal,' \x3d\x3d\x3d "top")'):"top"===orient,{signal:"(45 \x3c ".concat(alwaysIncludeMiddle," \x26\x26 ").concat(alwaysIncludeMiddle," \x3c 135) || (225 \x3c ").concat(alwaysIncludeMiddle,
" \x26\x26 ").concat(alwaysIncludeMiddle,' \x3c 315) ? "middle" :')+"(".concat(alwaysIncludeMiddle," \x3c\x3d 45 || 315 \x3c\x3d ").concat(alwaysIncludeMiddle,") \x3d\x3d\x3d ").concat(orient,' ? "bottom" : "top"')}):45<angle&&135>angle||225<angle&&315>angle?"middle":isSignalRef(orient)?(alwaysIncludeMiddle=45>=angle||315<=angle?"\x3d\x3d\x3d":"!\x3d\x3d",{signal:"".concat(orient.signal," ").concat(alwaysIncludeMiddle,' "top" ? "bottom" : "top"')}):(45>=angle||315<=angle)===("top"===orient)?"bottom":
"top":isSignalRef(angle)?(angle=normalizeAngleExpr(angle),orient=isSignalRef(orient)?"(".concat(orient.signal,' \x3d\x3d\x3d "left")'):"left"===orient,alwaysIncludeMiddle=alwaysIncludeMiddle?'"middle"':"null",{signal:"".concat(angle," \x3c\x3d 45 || 315 \x3c\x3d ").concat(angle," || (135 \x3c\x3d ").concat(angle," \x26\x26 ").concat(angle," \x3c\x3d 225) ? ").concat(alwaysIncludeMiddle," : (45 \x3c\x3d ").concat(angle," \x26\x26 ").concat(angle," \x3c\x3d 135) \x3d\x3d\x3d ").concat(orient,' ? "top" : "bottom"')}):
45>=angle||315<=angle||135<=angle&&225>=angle?alwaysIncludeMiddle?"middle":null:isSignalRef(orient)?(alwaysIncludeMiddle=45<=angle&&135>=angle?"\x3d\x3d\x3d":"!\x3d\x3d",{signal:"".concat(orient.signal," ").concat(alwaysIncludeMiddle,' "left" ? "top" : "bottom"')}):(45<=angle&&135>=angle)===("left"===orient)?"top":"bottom"}function defaultLabelAlign(angle,orient,channel){if(void 0!==angle){var startAngle=(channel="x"===channel)?0:90,mainOrient=channel?"bottom":"left";return isSignalRef(angle)?(angle=
normalizeAngleExpr(angle),orient=isSignalRef(orient)?"(".concat(orient.signal,' \x3d\x3d\x3d "').concat(mainOrient,'")'):orient===mainOrient,{signal:"(".concat(startAngle?"("+angle+" + 90)":angle," % 180 \x3d\x3d\x3d 0) ? ").concat(channel?null:'"center"'," :")+"(".concat(startAngle," \x3c ").concat(angle," \x26\x26 ").concat(angle," \x3c ").concat(180+startAngle,") \x3d\x3d\x3d ").concat(orient,' ? "left" : "right"')}):0===(angle+startAngle)%180?channel?null:"center":isSignalRef(orient)?(channel=
startAngle<angle&&angle<180+startAngle?"\x3d\x3d\x3d":"!\x3d\x3d",orient="".concat(orient.signal," ").concat(channel,' "').concat(mainOrient,'"'),{signal:"".concat(orient,' ? "left" : "right"')}):(startAngle<angle&&angle<180+startAngle)===(orient===mainOrient)?"left":"right"}}function getFieldDefTitle(model,channel){var channel2="x"===channel?"x2":"y2";channel=model.fieldDef(channel);model=model.fieldDef(channel2);channel2=channel?channel.title:void 0;model=model?model.title:void 0;if(channel2&&model)return mergeTitle(channel2,
model);if(channel2)return channel2;if(model)return model;if(void 0!==channel2)return channel2;if(void 0!==model)return model}function sortArrayIndexField(fieldDef,channel,opt){return vgField(fieldDef,Object.assign({},{prefix:channel,suffix:"sort_index"},null!==opt&&void 0!==opt?opt:{}))}function getHeaderChannel(channel,orient){return contains(["top","bottom"],orient)?"column":contains(["left","right"],orient)?"row":"row"===channel?"row":"column"}function getHeaderProperty(prop,header,config,channel){return getFirstDefined((header||
{})[prop],("row"===channel?config.headerRow:"column"===channel?config.headerColumn:config.headerFacet)[prop],config.header[prop])}function getHeaderProperties(properties,header,config,channel){const props={};for(const prop of properties)properties=getHeaderProperty(prop,header||{},config,channel),void 0!==properties&&(props[prop]=properties);return props}function assembleTitleGroup(model,channel){const title=model.component.layoutHeaders[channel].title,config=model.config?model.config:void 0;model=
model.component.layoutHeaders[channel].facetFieldDef?model.component.layoutHeaders[channel].facetFieldDef:void 0;const {titleAnchor,titleAngle:ta,titleOrient}=getHeaderProperties(["titleAnchor","titleAngle","titleOrient"],model.header,config,channel),headerChannel=getHeaderChannel(channel,titleOrient),titleAngle=normalizeAngle(ta);return{name:"".concat(channel,"-title"),type:"group",role:"".concat(headerChannel,"-title"),title:Object.assign({},{text:title},"row"===channel?{orient:"left"}:{},{style:"guide-title"},
defaultHeaderGuideBaseline(titleAngle,headerChannel),defaultHeaderGuideAlign(headerChannel,titleAngle,titleAnchor),assembleHeaderProperties(config,model,channel,HEADER_TITLE_PROPERTIES,HEADER_TITLE_PROPERTIES_MAP))}}function defaultHeaderGuideAlign(headerChannel,angle,anchor){switch(void 0===anchor?"middle":anchor){case "start":return{align:"left"};case "end":return{align:"right"}}return(headerChannel=defaultLabelAlign(angle,"row"===headerChannel?"left":"top","row"===headerChannel?"y":"x"))?{align:headerChannel}:
{}}function defaultHeaderGuideBaseline(angle,channel){return(angle=defaultLabelBaseline(angle,"row"===channel?"left":"top","row"===channel?"y":"x",!0))?{baseline:angle}:{}}function assembleHeaderGroups(model,channel$jscomp$0){const layoutHeader=model.component.layoutHeaders[channel$jscomp$0],groups=[];for(const headerType of HEADER_TYPES)if(layoutHeader[headerType])for(const headerComponent of layoutHeader[headerType]){a:{var JSCompiler_inline_result=model;var channel=channel$jscomp$0,headerType$jscomp$0=
headerType,layoutHeader$jscomp$0=layoutHeader,headerComponent$jscomp$0=headerComponent;if(headerComponent$jscomp$0){let title=null;const {facetFieldDef}=layoutHeader$jscomp$0;var config=JSCompiler_inline_result.config?JSCompiler_inline_result.config:void 0;if(facetFieldDef&&headerComponent$jscomp$0.labels){var {labelOrient}=getHeaderProperties(["labelOrient"],facetFieldDef.header,config,channel);if("row"===channel&&!contains(["top","bottom"],labelOrient)||"column"===channel&&!contains(["left","right"],
labelOrient))title=assembleLabelTitle(facetFieldDef,channel,config)}config=isFacetModel(JSCompiler_inline_result)&&!isFacetMapping(JSCompiler_inline_result.facet);labelOrient=headerComponent$jscomp$0.axes;const hasAxes=0<(null===labelOrient||void 0===labelOrient?void 0:labelOrient.length);if(title||hasAxes){const sizeChannel="row"===channel?"height":"width";JSCompiler_inline_result=Object.assign({},{name:JSCompiler_inline_result.getName("".concat(channel,"_").concat(headerType$jscomp$0)),type:"group",
role:"".concat(channel,"-").concat(headerType$jscomp$0)},layoutHeader$jscomp$0.facetFieldDef?{from:{data:JSCompiler_inline_result.getName(channel+"_domain")},sort:getSort(facetFieldDef,channel)}:{},hasAxes&&config?{from:{data:JSCompiler_inline_result.getName("facet_domain_".concat(channel))}}:{},title?{title}:{},headerComponent$jscomp$0.sizeSignal?{encode:{update:{[sizeChannel]:headerComponent$jscomp$0.sizeSignal}}}:{},hasAxes?{axes:labelOrient}:{});break a}}JSCompiler_inline_result=null}null!=JSCompiler_inline_result&&
groups.push(JSCompiler_inline_result)}return groups}function getSort(facetFieldDef,channel){const {sort}=facetFieldDef;if(isSortField(sort)){var _sort$order;return{field:vgField(sort,{expr:"datum"}),order:null!==(_sort$order=sort.order)&&void 0!==_sort$order?_sort$order:"ascending"}}return isArray(sort)?{field:sortArrayIndexField(facetFieldDef,channel,{expr:"datum"}),order:"ascending"}:{field:vgField(facetFieldDef,{expr:"datum"}),order:null!==sort&&void 0!==sort?sort:"ascending"}}function assembleLabelTitle(facetFieldDef,
channel,config){const {format,formatType,labelAngle,labelAnchor,labelOrient,labelExpr}=getHeaderProperties("format formatType labelAngle labelAnchor labelOrient labelExpr".split(" "),facetFieldDef.header,config,channel),titleTextExpr=formatSignalRef({fieldOrDatumDef:facetFieldDef,format,formatType,expr:"parent",config}).signal,headerChannel=getHeaderChannel(channel,labelOrient);return Object.assign({},{text:{signal:labelExpr?replaceAll(replaceAll(labelExpr,"datum.label",titleTextExpr),"datum.value",
vgField(facetFieldDef,{expr:"parent"})):titleTextExpr}},"row"===channel?{orient:"left"}:{},{style:"guide-label",frame:"group"},defaultHeaderGuideBaseline(labelAngle,headerChannel),defaultHeaderGuideAlign(headerChannel,labelAngle,labelAnchor),assembleHeaderProperties(config,facetFieldDef,channel,HEADER_LABEL_PROPERTIES,HEADER_LABEL_PROPERTIES_MAP))}function assembleHeaderProperties(config,facetFieldDef,channel,properties,propertiesMap){const props={};for(const prop of properties)propertiesMap[prop]&&
(properties=getHeaderProperty(prop,null===facetFieldDef||void 0===facetFieldDef?void 0:facetFieldDef.header,config,channel),void 0!==properties&&(props[propertiesMap[prop]]=properties));return props}function assembleLayoutSignals(model){return[...sizeSignals(model,"width"),...sizeSignals(model,"height"),...sizeSignals(model,"childWidth"),...sizeSignals(model,"childHeight")]}function sizeSignals(model,sizeType){var channel="width"===sizeType?"x":"y",size=model.component.layoutSize.get(sizeType);if(!size||
"merged"===size)return[];sizeType=model.getSizeSignalRef(sizeType).signal;if("step"===size){if(size=model.getScaleComponent(channel)){var type=size.get("type");const range=size.get("range");if(type in DISCRETE_DOMAIN_INDEX&&isVgRangeStep(range))return type=model.scaleName(channel),isFacetModel(model.parent)&&"independent"===model.parent.component.resolve.scale[channel]?[{name:type+"_step",value:range.step}]:[{name:type+"_step",value:range.step},{name:sizeType,update:sizeExpr(type,size,"domain('".concat(type,
"').length"))}]}throw Error("layout size is step although width/height is not step.");}return"container"==size?(channel=(size=sizeType.endsWith("width"))?"containerSize()[0]":"containerSize()[1]",model=getViewConfigContinuousSize(model.config.view,size?"width":"height"),model="isFinite(".concat(channel,") ? ").concat(channel," : ").concat(model),[{name:sizeType,init:model,on:[{update:model,events:"window:resize"}]}]):[{name:sizeType,value:size}]}function sizeExpr(scaleName,scaleComponent,cardinality){const type=
scaleComponent.get("type"),padding=scaleComponent.get("padding"),paddingOuter=getFirstDefined(scaleComponent.get("paddingOuter"),padding);scaleComponent=scaleComponent.get("paddingInner");scaleComponent="band"===type?void 0!==scaleComponent?scaleComponent:padding:1;return"bandspace(".concat(cardinality,", ").concat(signalOrStringValue(scaleComponent),", ").concat(signalOrStringValue(paddingOuter),") * ").concat(scaleName,"_step")}function getSizeTypeFromLayoutSizeType(layoutSizeType){return"childWidth"===
layoutSizeType?"width":"childHeight"===layoutSizeType?"height":layoutSizeType}function guideEncodeEntry(encoding,model){return keys$jscomp$0(encoding).reduce((encode,channel)=>Object.assign({},encode,wrapCondition(model,encoding[channel],channel,def=>signalOrValueRef(def.value))),{})}function parseGuideResolve(resolve,channel){const guide=channel in POSITION_SCALE_CHANNEL_INDEX?"axis":"legend";return"independent"===resolve.scale[channel]?("shared"===resolve[guide][channel]&&warn('Setting the scale to be independent for "'.concat(channel,
'" means we also have to set the guide (axis or legend) to be independent.')),"independent"):resolve[guide][channel]||"shared"}function getMaxValue(channelDef){return getConditionValue(channelDef,(v,conditionalDef)=>Math.max(v,conditionalDef.value))}function getFirstConditionValue(channelDef){return getConditionValue(channelDef,(v,conditionalDef)=>getFirstDefined(v,conditionalDef.value))}function getConditionValue(channelDef,reducer){var JSCompiler_inline_result=channelDef&&channelDef.condition;if(JSCompiler_inline_result=
!!JSCompiler_inline_result&&(isArray(JSCompiler_inline_result)||isValueDef(JSCompiler_inline_result)))return array$jscomp$0(channelDef.condition).reduce(reducer,channelDef.value);if(isValueDef(channelDef))return channelDef.value}function selectedCondition(model,legendCmpt,fieldDef){model=legendCmpt.get("selections");if(null!==model&&void 0!==model&&model.length){var field=$(fieldDef.field);return model.map(name=>{const store=$(varName(name)+"_store");return"(!length(data(".concat(store,")) || (").concat(name,
"[").concat(field,"] \x26\x26 indexof(").concat(name,"[").concat(field,"], datum.value) \x3e\x3d 0))")}).join(" || ")}}function gradientLengthSignal(model,sizeType,min,max){model=model.getSizeSignalRef(sizeType).signal;return{signal:"clamp(".concat(model,", ").concat(min,", ").concat(max,")")}}function parseLegend(model$jscomp$0){var JSCompiler_temp;if(isUnitModel(model$jscomp$0)){var {encoding:encoding$jscomp$0}=model$jscomp$0,legendComponent={};for(const channel of["color",...LEGEND_SCALE_CHANNELS]){var def=
getFieldOrDatumDef(encoding$jscomp$0[channel]);if(def&&model$jscomp$0.getScaleComponent(channel)&&("shape"!==channel||!isFieldDef(def)||"geojson"!==def.type)){a:{var _legend$direction=def=void 0,_ref3=void 0,_legend=void 0,_legend$encoding=void 0;var JSCompiler_inline_result=void 0;var model=model$jscomp$0,channel$jscomp$0=channel;let legend=model.legend(channel$jscomp$0);const {markDef,encoding,config}=model;var legendConfig=config.legend;b:{var JSCompiler_inline_result$jscomp$0=model;var channel$jscomp$1=
channel$jscomp$0,scale=JSCompiler_inline_result$jscomp$0.scaleName(channel$jscomp$1);if("trail"===JSCompiler_inline_result$jscomp$0.mark){if("color"===channel$jscomp$1){JSCompiler_inline_result$jscomp$0={stroke:scale};break b}if("size"===channel$jscomp$1){JSCompiler_inline_result$jscomp$0={strokeWidth:scale};break b}}JSCompiler_inline_result$jscomp$0="color"===channel$jscomp$1?JSCompiler_inline_result$jscomp$0.markDef.filled?{fill:scale}:{stroke:scale}:{[channel$jscomp$1]:scale}}JSCompiler_inline_result$jscomp$0=
new LegendComponent({},JSCompiler_inline_result$jscomp$0);parseInteractiveLegend(model,channel$jscomp$0,JSCompiler_inline_result$jscomp$0);channel$jscomp$1=void 0!==legend?!legend:legendConfig.disable;JSCompiler_inline_result$jscomp$0.set("disable",channel$jscomp$1,void 0!==legend);if(channel$jscomp$1){def=JSCompiler_inline_result$jscomp$0;break a}legend=legend||{};scale=model.getScaleComponent(channel$jscomp$0).get("type");channel$jscomp$1=getFieldOrDatumDef(encoding[channel$jscomp$0]);var timeUnit=
isFieldDef(channel$jscomp$1)?null===(JSCompiler_inline_result=normalizeTimeUnit(channel$jscomp$1.timeUnit))||void 0===JSCompiler_inline_result?void 0:JSCompiler_inline_result.unit:void 0;const orient=legend.orient||config.legend.orient||"right";JSCompiler_inline_result={legend,channel:channel$jscomp$0,timeUnit,scaleType:scale};({legend:timeUnit}=JSCompiler_inline_result);timeUnit=timeUnit.type;b:{var {channel:channel$jscomp$2,timeUnit:timeUnit$jscomp$0,scaleType}=JSCompiler_inline_result;if(isColorChannel(channel$jscomp$2)){if(contains(["quarter",
"month","day"],timeUnit$jscomp$0)){JSCompiler_inline_result="symbol";break b}if(scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX){JSCompiler_inline_result="gradient";break b}}JSCompiler_inline_result="symbol"}JSCompiler_inline_result=getFirstDefined(timeUnit,JSCompiler_inline_result);var {legendConfig:legendConfig$jscomp$0,legendType,orient:orient$jscomp$0,legend:legend$jscomp$0}={legend,legendType:JSCompiler_inline_result,orient,legendConfig};if(null!==(_ref3=null!==(_legend$direction=legend$jscomp$0.direction)&&
void 0!==_legend$direction?_legend$direction:legendConfig$jscomp$0[legendType?"gradientDirection":"symbolDirection"])&&void 0!==_ref3)_legend$direction=_ref3;else b:{switch(orient$jscomp$0){case "top":case "bottom":_legend$direction="horizontal";break b;case "left":case "right":case "none":case void 0:break;default:_legend$direction="gradient"===legendType?"horizontal":void 0;break b}_legend$direction=void 0}legendConfig={legend,channel:channel$jscomp$0,model,markDef,encoding,fieldOrDatumDef:channel$jscomp$1,
legendConfig,config,scaleType:scale,orient,legendType:JSCompiler_inline_result,direction:_legend$direction};for(const property of LEGEND_COMPONENT_PROPERTIES)if(!("gradient"===JSCompiler_inline_result&&property.startsWith("symbol")||"symbol"===JSCompiler_inline_result&&property.startsWith("gradient"))&&(_legend$direction=property in legendRules?legendRules[property](legendConfig):legend[property],void 0!==_legend$direction)){b:{_ref3=model.fieldDef(channel$jscomp$0);switch(property){case "disable":_ref3=
void 0!==legend;break b;case "values":_ref3=!(null===legend||void 0===legend||!legend.values);break b;case "title":if("title"===property&&_legend$direction===(null===_ref3||void 0===_ref3?void 0:_ref3.title)){_ref3=!0;break b}}_ref3=_legend$direction===(legend||{})[property]}(_ref3||void 0===config.legend[property])&&JSCompiler_inline_result$jscomp$0.set(property,_legend$direction,_ref3)}legendConfig=null!==(_legend$encoding=null===(_legend=legend)||void 0===_legend?void 0:_legend.encoding)&&void 0!==
_legend$encoding?_legend$encoding:{};_legend=JSCompiler_inline_result$jscomp$0.get("selections");_legend$encoding={};channel$jscomp$0={fieldOrDatumDef:channel$jscomp$1,model,channel:channel$jscomp$0,legendCmpt:JSCompiler_inline_result$jscomp$0,legendType:JSCompiler_inline_result};for(const part of"labels legend title symbols gradient entries".split(" "))_legend$direction=guideEncodeEntry(null!==(JSCompiler_temp=legendConfig[part])&&void 0!==JSCompiler_temp?JSCompiler_temp:{},model),_legend$direction=
part in legendEncodeRules?legendEncodeRules[part](_legend$direction,channel$jscomp$0):_legend$direction,void 0===_legend$direction||isEmpty(_legend$direction)||(_legend$encoding[part]=Object.assign({},(null===_legend||void 0===_legend?0:_legend.length)&&isFieldDef(channel$jscomp$1)?{name:"".concat(varName(channel$jscomp$1.field),"_legend_").concat(part)}:{},(null===_legend||void 0===_legend?0:_legend.length)?{interactive:!!_legend}:{},{update:_legend$direction}));isEmpty(_legend$encoding)||JSCompiler_inline_result$jscomp$0.set("encode",
_legend$encoding,!(null===(def=legend)||void 0===def||!def.encoding));def=JSCompiler_inline_result$jscomp$0}legendComponent[channel]=def}}JSCompiler_temp=legendComponent}else{{const {legends,resolve}=model$jscomp$0.component;for(encoding$jscomp$0 of model$jscomp$0.children){parseLegend(encoding$jscomp$0);for(legendComponent of keys$jscomp$0(encoding$jscomp$0.component.legends))resolve.legend[legendComponent]=parseGuideResolve(model$jscomp$0.component.resolve,legendComponent),"shared"===resolve.legend[legendComponent]&&
(legends[legendComponent]=mergeLegendComponent(legends[legendComponent],encoding$jscomp$0.component.legends[legendComponent]),legends[legendComponent]||(resolve.legend[legendComponent]="independent",delete legends[legendComponent]))}for(def of keys$jscomp$0(legends))for(model of model$jscomp$0.children)model.component.legends[def]&&"shared"===resolve.legend[def]&&delete model.component.legends[def];JSCompiler_temp=legends}}return model$jscomp$0.component.legends=JSCompiler_temp}function mergeLegendComponent(mergedLegend,
childLegend){if(!mergedLegend)return childLegend.clone();var mergedOrient=mergedLegend.getWithExplicit("orient");const childOrient=childLegend.getWithExplicit("orient");if(!mergedOrient.explicit||!childOrient.explicit||mergedOrient.value===childOrient.value){var typeMerged=!1;for(const prop of LEGEND_COMPONENT_PROPERTIES)mergedOrient=mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop),childLegend.getWithExplicit(prop),prop,"legend",(v1,v2)=>{switch(prop){case "symbolType":return v1="circle"===
v2.value?v2:v1,v1;case "title":return mergeTitleComponent(v1,v2);case "type":return typeMerged=!0,makeImplicit("symbol")}return defaultTieBreaker(v1,v2,prop,"legend")}),mergedLegend.setWithExplicit(prop,mergedOrient);if(typeMerged){var _mergedLegend$implici,_mergedLegend$implici2,_mergedLegend$explici,_mergedLegend$explici2;(null===(_mergedLegend$implici=mergedLegend.implicit)||void 0===_mergedLegend$implici?0:null===(_mergedLegend$implici2=_mergedLegend$implici.encode)||void 0===_mergedLegend$implici2?
0:_mergedLegend$implici2.gradient)&&deleteNestedProperty(mergedLegend.implicit,["encode","gradient"]);(null===(_mergedLegend$explici=mergedLegend.explicit)||void 0===_mergedLegend$explici?0:null===(_mergedLegend$explici2=_mergedLegend$explici.encode)||void 0===_mergedLegend$explici2?0:_mergedLegend$explici2.gradient)&&deleteNestedProperty(mergedLegend.explicit,["encode","gradient"])}return mergedLegend}}function assembleLegends(model){const legendComponentIndex=model.component.legends,legendByDomain=
{};for(const channel of keys$jscomp$0(legendComponentIndex)){var scaleComponent=model.getScaleComponent(channel);scaleComponent=stringify(scaleComponent.get("domains"));if(legendByDomain[scaleComponent])for(const mergedLegendComponent of legendByDomain[scaleComponent])mergeLegendComponent(mergedLegendComponent,legendComponentIndex[channel])||legendByDomain[scaleComponent].push(legendComponentIndex[channel]);else legendByDomain[scaleComponent]=[legendComponentIndex[channel].clone()]}return vals$jscomp$0(legendByDomain).flat().map(l=>
{{var config=model.config,_legend$encode2,$jscomp$inline_2894=l.combine();l=Object.assign({},$jscomp$inline_2894);const disable=$jscomp$inline_2894.disable;$jscomp$inline_2894=$jscomp$inline_2894.labelExpr;l=(delete l.disable,delete l.labelExpr,delete l.selections,l);if(disable)var JSCompiler_inline_result=void 0;else{!1===config.aria&&void 0==l.aria&&(l.aria=!1);if(null===(_legend$encode2=l.encode)||void 0===_legend$encode2?0:_legend$encode2.symbols){config=l.encode.symbols.update;!config.fill||
"transparent"===config.fill.value||config.stroke||l.stroke||(config.stroke={value:"transparent"});for(var property of LEGEND_SCALE_CHANNELS)l[property]&&delete config[property]}l.title||delete l.title;if(void 0!==$jscomp$inline_2894){var _legend$encode3,_legend$encode3$label;property=$jscomp$inline_2894;(null===(_legend$encode3=l.encode)||void 0===_legend$encode3?0:null===(_legend$encode3$label=_legend$encode3.labels)||void 0===_legend$encode3$label?0:_legend$encode3$label.update)&&isSignalRef(l.encode.labels.update.text)&&
(property=replaceAll($jscomp$inline_2894,"datum.label",l.encode.labels.update.text.signal));_legend$encode3=l;_legend$encode3$label={signal:property};var _legend$encode$part,_legend$encode$part$u;_legend$encode3.encode=null!==(JSCompiler_inline_result=_legend$encode3.encode)&&void 0!==JSCompiler_inline_result?JSCompiler_inline_result:{};_legend$encode3.encode.labels=null!==(_legend$encode$part=_legend$encode3.encode.labels)&&void 0!==_legend$encode$part?_legend$encode$part:{};_legend$encode3.encode.labels.update=
null!==(_legend$encode$part$u=_legend$encode3.encode.labels.update)&&void 0!==_legend$encode$part$u?_legend$encode$part$u:{};_legend$encode3.encode.labels.update.text=_legend$encode3$label}JSCompiler_inline_result=l}}return JSCompiler_inline_result}).filter(l=>void 0!==l)}function assembleProjectionsForModelAndChildren(model){return model.children.reduce((projections,child)=>projections.concat(child.assembleProjections()),assembleProjectionForModel(model))}function assembleProjectionForModel(model){var component=
model.component.projection;if(!component||component.merged)return[];const projection=component.combine(),{name}=projection;if(component.data){const size={signal:"[".concat(component.size.map(ref=>ref.signal).join(", "),"]")};component=component.data.reduce((sources,data)=>{data=isSignalRef(data)?data.signal:"data('".concat(model.lookupDataSource(data),"')");contains(sources,data)||sources.push(data);return sources},[]);if(0>=component.length)throw Error("Projection's fit didn't find any data sources");
return[Object.assign({},{name,size,fit:{signal:1<component.length?"[".concat(component.join(", "),"]"):component[0]}},projection)]}return[Object.assign({},{name},{translate:{signal:"[width / 2, height / 2]"}},projection)]}function parseProjection(model){var JSCompiler_temp_const=model.component;if(isUnitModel(model))if(model.hasProjection){var _model$config$project;const proj=model.specifiedProjection;var fit=!(proj&&(null!=proj.scale||null!=proj.translate));const size=fit?[model.getSizeSignalRef("width"),
model.getSizeSignalRef("height")]:void 0;if(fit){{fit=[];const {encoding}=model;for(JSCompiler_temp of[["longitude","latitude"],["longitude2","latitude2"]])(getFieldOrDatumDef(encoding[JSCompiler_temp[0]])||getFieldOrDatumDef(encoding[JSCompiler_temp[1]]))&&fit.push({signal:model.getName("geojson_".concat(fit.length))});model.channelHasField("shape")&&"geojson"===model.typedFieldDef("shape").type&&fit.push({signal:model.getName("geojson_".concat(fit.length))});0===fit.length&&fit.push(model.requestDataName(DataSourceType.Main));
var JSCompiler_temp=fit}}else JSCompiler_temp=void 0;model=new ProjectionComponent(model.projectionName(!0),Object.assign({},null!==(_model$config$project=model.config.projection)&&void 0!==_model$config$project?_model$config$project:{},null!==proj&&void 0!==proj?proj:{}),size,JSCompiler_temp)}else model=void 0;else model=parseNonUnitProjections(model);JSCompiler_temp_const.projection=model}function mergeIfNoConflict(first,second){const allPropertiesShared=every(PROJECTION_PROPERTIES,prop=>!hop.call(first.explicit,
prop)&&!hop.call(second.explicit,prop)||hop.call(first.explicit,prop)&&hop.call(second.explicit,prop)&&stringify(first.get(prop))===stringify(second.get(prop))?!0:!1);if(stringify(first.size)===stringify(second.size)){if(allPropertiesShared)return first;if(stringify(first.explicit)===stringify({}))return second;if(stringify(second.explicit)===stringify({}))return first}return null}function parseNonUnitProjections(model){if(0!==model.children.length){var nonUnitProjection;for(var child$jscomp$0 of model.children)parseProjection(child$jscomp$0);
child$jscomp$0=every(model.children,child=>{if(child=child.component.projection){if(nonUnitProjection)return(child=mergeIfNoConflict(nonUnitProjection,child))&&(nonUnitProjection=child),!!child;nonUnitProjection=child}return!0});if(nonUnitProjection&&child$jscomp$0){child$jscomp$0=model.projectionName(!0);const modelProjection=new ProjectionComponent(child$jscomp$0,nonUnitProjection.specifiedProjection,nonUnitProjection.size,duplicate(nonUnitProjection.data));for(const child of model.children)if(model=
child.component.projection)model.isFit&&modelProjection.data.push(...child.component.projection.data),child.renameProjection(model.get("name"),child$jscomp$0),model.merged=!0;return modelProjection}}}function rangeFormula(model,fieldDef,channel,config){if(binRequiresRange(fieldDef,channel)){var _ref,_model$axis;model=isUnitModel(model)?null!==(_ref=null!==(_model$axis=model.axis(channel))&&void 0!==_model$axis?_model$axis:model.legend(channel))&&void 0!==_ref?_ref:{}:{};_ref=vgField(fieldDef,{expr:"datum"});
_model$axis=vgField(fieldDef,{expr:"datum",binSuffix:"end"});return{formulaAs:vgField(fieldDef,{binSuffix:"range",forAs:!0}),formula:binFormatExpression(_ref,_model$axis,model.format,model.formatType,config)}}return{}}function binKey(bin,field){return"".concat(binToString(bin),"_").concat(field)}function getBinSignalName(model,field,bin){var _normalizeBin;bin=null!==(_normalizeBin=normalizeBin(bin,void 0))&&void 0!==_normalizeBin?_normalizeBin:{};field=binKey(bin,field);return model.getName("".concat(field,
"_bins"))}function createBinComponent(t,bin,model){let as;as="as"in t?isString(t.as)?[t.as,"".concat(t.as,"_end")]:[t.as[0],t.as[1]]:[vgField(t,{forAs:!0}),vgField(t,{binSuffix:"end",forAs:!0})];const normalizedBin=Object.assign({},normalizeBin(bin,void 0));bin=binKey(normalizedBin,t.field);var JSCompiler_inline_result={signal:model.getName("".concat(bin,"_bins")),extentSignal:model.getName("".concat(bin,"_extent"))};const {signal,extentSignal}=JSCompiler_inline_result;if(isSelectionExtent(normalizedBin.extent)){var span=
normalizedBin.extent;JSCompiler_inline_result=span.selection;span=parseSelectionBinExtent(model.getSelectionComponent(varName(JSCompiler_inline_result),JSCompiler_inline_result),span);delete normalizedBin.extent}t=Object.assign({},{bin:normalizedBin,field:t.field,as:[as]},signal?{signal}:{},extentSignal?{extentSignal}:{},span?{span}:{});return{key:bin,binComponent:t}}function unquote(pattern){return"'"===pattern[0]&&"'"===pattern[pattern.length-1]||'"'===pattern[0]&&'"'===pattern[pattern.length-1]?
pattern.slice(1,-1):pattern}function parseExpression$1(field,parse){field=accessPathWithDatum(field);if("number"===parse)return"toNumber(".concat(field,")");if("boolean"===parse)return"toBoolean(".concat(field,")");if("string"===parse)return"toString(".concat(field,")");if("date"===parse)return"toDate(".concat(field,")");if("flatten"===parse)return field;if(0===parse.indexOf("date:"))return parse=unquote(parse.slice(5,parse.length)),"timeParse(".concat(field,",'").concat(parse,"')");if(0===parse.indexOf("utc:"))return parse=
unquote(parse.slice(4,parse.length)),"utcParse(".concat(field,",'").concat(parse,"')");warn('Unrecognized parse "'.concat(parse,'".'));return null}function getImplicitFromFilterTransform(transform){const implicit={};forEachLeaf(transform.filter,filter=>{if(isFieldPredicate(filter)){let val=null;if(isFieldEqualPredicate(filter))val=signalRefOrValue(filter.equal);else if(isFieldLTEPredicate(filter))val=signalRefOrValue(filter.lte);else if(isFieldLTPredicate(filter))val=signalRefOrValue(filter.lt);else if(isFieldGTPredicate(filter))val=
signalRefOrValue(filter.gt);else if(isFieldGTEPredicate(filter))val=signalRefOrValue(filter.gte);else if(isFieldRangePredicate(filter))val=filter.range[0];else if(isFieldOneOfPredicate(filter)){var _filter$oneOf;val=(null!==(_filter$oneOf=filter.oneOf)&&void 0!==_filter$oneOf?_filter$oneOf:filter["in"])[0]}val&&(isDateTime(val)?implicit[filter.field]="date":isNumber(val)?implicit[filter.field]="number":isString(val)&&(implicit[filter.field]="string"));filter.timeUnit&&(implicit[filter.field]="date")}});
return implicit}function getImplicitFromEncoding(model){function add(fieldDef){if(isFieldOrDatumDefForTimeFormat(fieldDef))implicit[fieldDef.field]="date";else{var JSCompiler_temp;if(JSCompiler_temp="quantitative"===fieldDef.type)JSCompiler_temp=fieldDef.aggregate,JSCompiler_temp=isString(JSCompiler_temp)&&contains(["min","max"],JSCompiler_temp);JSCompiler_temp?implicit[fieldDef.field]="number":1<accessPathDepth(fieldDef.field)?fieldDef.field in implicit||(implicit[fieldDef.field]="flatten"):isScaleFieldDef(fieldDef)&&
isSortField(fieldDef.sort)&&1<accessPathDepth(fieldDef.sort.field)&&(fieldDef.sort.field in implicit||(implicit[fieldDef.sort.field]="flatten"))}}const implicit={};(isUnitModel(model)||isFacetModel(model))&&model.forEachFieldDef((fieldDef,channel)=>{isTypedFieldDef(fieldDef)?add(fieldDef):(channel=getMainRangeChannel(channel),channel=model.fieldDef(channel),add(Object.assign({},fieldDef,{type:channel.type})))});if(isUnitModel(model)){const {mark,markDef,encoding}=model;if(isPathMark(mark)&&!model.encoding.order){const dimensionChannelDef=
encoding["horizontal"===markDef.orient?"y":"x"];!isFieldDef(dimensionChannelDef)||"quantitative"!==dimensionChannelDef.type||dimensionChannelDef.field in implicit||(implicit[dimensionChannelDef.field]="number")}}return implicit}function isDataSourceNode(node){return node instanceof SourceNode||node instanceof GraticuleNode||node instanceof SequenceNode}function getStackByFields(model){return model.stack.stackBy.reduce((fields,by)=>{(by=vgField(by.fieldDef))&&fields.push(by);return fields},[])}function isValidAsArray(as){return isArray(as)&&
as.every(s=>isString(s))&&1<as.length}function cloneSubtree(facet){function clone(node){if(!(node instanceof FacetNode)){const copy=node.clone();if(copy instanceof OutputNode){const newName="scale_"+copy.getSource();copy.setSource(newName);facet.model.component.data.outputNodes[newName]=copy}else(copy instanceof AggregateNode||copy instanceof StackNode||copy instanceof WindowTransformNode||copy instanceof JoinAggregateTransformNode)&&copy.addDimensions(facet.fields);for(const n of node.children.flatMap(clone))n.parent=
copy;return[copy]}return node.children.flatMap(clone)}return clone}function moveFacetDown(node){if(node instanceof FacetNode)if(1!==node.numChildren()||node.children[0]instanceof OutputNode){var facetMain=node.model.component.data.main;moveMainDownToFacet(facetMain);const cloner=cloneSubtree(node);node=node.children.map(cloner).flat();for(const c of node)c.parent=facetMain}else facetMain=node.children[0],(facetMain instanceof AggregateNode||facetMain instanceof StackNode||facetMain instanceof WindowTransformNode||
facetMain instanceof JoinAggregateTransformNode)&&facetMain.addDimensions(node.fields),facetMain.swapWithParent(),moveFacetDown(node);else node.children.map(moveFacetDown)}function moveMainDownToFacet(node){if(node instanceof OutputNode&&node.type===DataSourceType.Main&&1===node.numChildren()){const child=node.children[0];child instanceof FacetNode||(child.swapWithParent(),moveMainDownToFacet(node))}}function checkLinks(nodes){for(const node of nodes){for(const child of node.children)if(child.parent!==
node)return!1;if(!checkLinks(node.children))return!1}return!0}function runOptimizer(optimizer,nodes){let modified=!1;for(const node of nodes)modified=optimizer.optimize(node)||modified;return modified}function optimizationDataflowHelper(dataComponent,model,firstPass){let roots=dataComponent.sources,modified=!1;modified=runOptimizer(new RemoveUnnecessaryOutputNodes,roots)||modified;modified=runOptimizer(new RemoveUnnecessaryIdentifierNodes(model),roots)||modified;roots=roots.filter(r=>0<r.numChildren());
modified=runOptimizer(new RemoveUnusedSubtrees,roots)||modified;roots=roots.filter(r=>0<r.numChildren());firstPass||(modified=runOptimizer(new MoveParseUp,roots)||modified,modified=runOptimizer(new MergeBins(model),roots)||modified,modified=runOptimizer(new RemoveDuplicateTimeUnits,roots)||modified,modified=runOptimizer(new MergeParse,roots)||modified,modified=runOptimizer(new MergeAggregates,roots)||modified,modified=runOptimizer(new MergeTimeUnits,roots)||modified,modified=runOptimizer(new MergeIdenticalNodes,
roots)||modified,modified=runOptimizer(new MergeOutputs,roots)||modified);dataComponent.sources=roots;return modified}function parseUnitScaleDomain(model){const localScaleComponents=model.component.scales;for(const channel of keys$jscomp$0(localScaleComponents)){var JSCompiler_inline_result=model;var channel$jscomp$0=channel,scaleType=JSCompiler_inline_result.getScaleComponent(channel$jscomp$0).get("type"),{encoding}=JSCompiler_inline_result;var JSCompiler_inline_result$jscomp$0=JSCompiler_inline_result.scaleDomain(channel$jscomp$0);
var fieldDef=JSCompiler_inline_result.typedFieldDef(channel$jscomp$0),scaleConfig=JSCompiler_inline_result.config.scale;if("unaggregated"===JSCompiler_inline_result$jscomp$0){const {valid,reason}=canUseUnaggregatedDomain(fieldDef,scaleType);valid||(warn(reason),JSCompiler_inline_result$jscomp$0=void 0)}else void 0===JSCompiler_inline_result$jscomp$0&&scaleConfig.useUnaggregatedDomain&&({valid:fieldDef}=canUseUnaggregatedDomain(fieldDef,scaleType),fieldDef&&(JSCompiler_inline_result$jscomp$0="unaggregated"));
JSCompiler_inline_result$jscomp$0!==JSCompiler_inline_result.scaleDomain(channel$jscomp$0)&&(JSCompiler_inline_result.specifiedScales[channel$jscomp$0]=Object.assign({},JSCompiler_inline_result.specifiedScales[channel$jscomp$0],{domain:JSCompiler_inline_result$jscomp$0}));JSCompiler_inline_result="x"===channel$jscomp$0&&getFieldOrDatumDef(encoding.x2)?getFieldOrDatumDef(encoding.x)?mergeValuesWithExplicit(parseSingleChannelDomain(scaleType,JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,
"x"),parseSingleChannelDomain(scaleType,JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,"x2"),"domain","scale",domainsTieBreaker):parseSingleChannelDomain(scaleType,JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,"x2"):"y"===channel$jscomp$0&&getFieldOrDatumDef(encoding.y2)?getFieldOrDatumDef(encoding.y)?mergeValuesWithExplicit(parseSingleChannelDomain(scaleType,JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,"y"),parseSingleChannelDomain(scaleType,JSCompiler_inline_result$jscomp$0,
JSCompiler_inline_result,"y2"),"domain","scale",domainsTieBreaker):parseSingleChannelDomain(scaleType,JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,"y2"):parseSingleChannelDomain(scaleType,JSCompiler_inline_result$jscomp$0,JSCompiler_inline_result,channel$jscomp$0);localScaleComponents[channel].setWithExplicit("domains",JSCompiler_inline_result);encoding=void 0;channel$jscomp$0=model.component.scales[channel];JSCompiler_inline_result$jscomp$0=model.specifiedScales[channel].domain;scaleType=
null===(encoding=model.fieldDef(channel))||void 0===encoding?void 0:encoding.bin;encoding=isSelectionDomain(JSCompiler_inline_result$jscomp$0)&&JSCompiler_inline_result$jscomp$0;scaleType=isObject(scaleType)&&isSelectionExtent(scaleType.extent)&&scaleType.extent;(encoding||scaleType)&&channel$jscomp$0.set("selectionExtent",null!==encoding&&void 0!==encoding?encoding:scaleType,!0);if(model.component.data.isFaceted){for(channel$jscomp$0=model;!isFacetModel(channel$jscomp$0)&&channel$jscomp$0.parent;)channel$jscomp$0=
channel$jscomp$0.parent;if("shared"===channel$jscomp$0.component.resolve.scale[channel])for(const domain of JSCompiler_inline_result.value)isDataRefDomain(domain)&&(domain.data="scale_"+domain.data.replace("scale_",""))}}}function parseNonUnitScaleDomain(model$jscomp$0){for(var child$jscomp$0 of model$jscomp$0.children){var model=child$jscomp$0;isUnitModel(model)?parseUnitScaleDomain(model):parseNonUnitScaleDomain(model)}model=model$jscomp$0.component.scales;for(const channel of keys$jscomp$0(model)){let domains;
child$jscomp$0=null;for(const child of model$jscomp$0.children){var childComponent=child.component.scales[channel];childComponent&&(domains=void 0===domains?childComponent.getWithExplicit("domains"):mergeValuesWithExplicit(domains,childComponent.getWithExplicit("domains"),"domains","scale",domainsTieBreaker),childComponent=childComponent.get("selectionExtent"),child$jscomp$0&&childComponent&&child$jscomp$0.selection!==childComponent.selection&&warn("The same selection must be used to override scale domains in a layered view."),
child$jscomp$0=childComponent)}model[channel].setWithExplicit("domains",domains);child$jscomp$0&&model[channel].set("selectionExtent",child$jscomp$0,!0)}}function mapDomainToDataSignal(domain,type,timeUnit){return domain.map(v=>{v=valueExpr(v,{timeUnit,type});return{signal:"{data: ".concat(v,"}")}})}function convertDomainIfItIsDateTime(domain,type,timeUnit){var _normalizeTimeUnit;timeUnit=null===(_normalizeTimeUnit=normalizeTimeUnit(timeUnit))||void 0===_normalizeTimeUnit?void 0:_normalizeTimeUnit.unit;
return"temporal"===type||timeUnit?mapDomainToDataSignal(domain,type,timeUnit):[domain]}function parseSingleChannelDomain(scaleType,domain,model,channel){var {encoding}=model;encoding=getFieldOrDatumDef(encoding[channel]);const {type}=encoding,timeUnit=encoding.timeUnit;if(domain&&domain.unionWith)return channel=parseSingleChannelDomain(scaleType,void 0,model,channel),domain=convertDomainIfItIsDateTime(domain.unionWith,type,timeUnit),makeExplicit([...channel.value,...domain]);if(isSignalRef(domain))return makeExplicit([domain]);
if(domain&&"unaggregated"!==domain&&!isSelectionDomain(domain))return makeExplicit(convertDomainIfItIsDateTime(domain,type,timeUnit));var stack=model.stack;if(stack&&channel===stack.fieldChannel){if("normalize"===stack.offset)return makeImplicit([[0,1]]);domain=model.requestDataName(DataSourceType.Main);return makeImplicit([{data:domain,field:model.vgField(channel,{suffix:"start"})},{data:domain,field:model.vgField(channel,{suffix:"end"})}])}stack=SCALE_CHANNEL_INDEX[channel]&&isFieldDef(encoding)?
domainSort(model,channel,scaleType):void 0;if(isDatumDef(encoding))return channel=convertDomainIfItIsDateTime([encoding.datum],type,timeUnit),makeImplicit(channel);if("unaggregated"===domain)return channel=model.requestDataName(DataSourceType.Main),{field:domain}=encoding,makeImplicit([{data:channel,field:vgField({field:domain,aggregate:"min"})},{data:channel,field:vgField({field:domain,aggregate:"max"})}]);if(isBinning(encoding.bin)){if(scaleType in DISCRETE_DOMAIN_INDEX)return"bin-ordinal"===scaleType?
makeImplicit([]):makeImplicit([{data:isBoolean$1(stack)?model.requestDataName(DataSourceType.Main):model.requestDataName(DataSourceType.Raw),field:model.vgField(channel,binRequiresRange(encoding,channel)?{binSuffix:"range"}:{}),sort:!0!==stack&&isObject(stack)?stack:{field:model.vgField(channel,{}),op:"min"}}]);({bin:domain}=encoding);if(isBinning(domain)){const binSignal=getBinSignalName(model,encoding.field,domain);return makeImplicit([new SignalRefWrapper(()=>{const signal=model.getSignalName(binSignal);
return"[".concat(signal,".start, ").concat(signal,".stop]")})])}return makeImplicit([{data:model.requestDataName(DataSourceType.Main),field:model.vgField(channel,{})}])}return encoding.timeUnit&&contains(["time","utc"],scaleType)&&hasBand(channel,encoding,isUnitModel(model)?model.encoding[getSecondaryRangeChannel(channel)]:void 0,model.stack,model.markDef,model.config)?(domain=model.requestDataName(DataSourceType.Main),makeImplicit([{data:domain,field:model.vgField(channel)},{data:domain,field:model.vgField(channel,
{suffix:"end"})}])):stack?makeImplicit([{data:isBoolean$1(stack)?model.requestDataName(DataSourceType.Main):model.requestDataName(DataSourceType.Raw),field:model.vgField(channel),sort:stack}]):makeImplicit([{data:model.requestDataName(DataSourceType.Main),field:model.vgField(channel)}])}function normalizeSortField(sort,isStackedMeasure){const {op,field,order}=sort;return Object.assign({},{op:null!==op&&void 0!==op?op:isStackedMeasure?"sum":"min"},field?{field:replacePathInField(field)}:{},order?{order}:
{})}function domainSort(model,channel,scaleType){if(scaleType in DISCRETE_DOMAIN_INDEX){var fieldDef=model.fieldDef(channel);scaleType=fieldDef.sort;if(isSortArray(scaleType))return{op:"min",field:sortArrayIndexField(fieldDef,channel),order:"ascending"};({stack:fieldDef}=model);var stackDimensions=fieldDef?[...fieldDef.groupbyField?[fieldDef.groupbyField]:[],...fieldDef.stackBy.map(s=>s.fieldDef.field)]:void 0;if(isSortField(scaleType))return model=fieldDef&&!contains(stackDimensions,scaleType.field),
normalizeSortField(scaleType,model);if(scaleType&&scaleType.encoding){const {encoding,order}=scaleType;model=model.fieldDef(encoding);const {aggregate,field}=model;channel=fieldDef&&!contains(stackDimensions,field);if(isArgminDef(aggregate)||isArgmaxDef(aggregate))return normalizeSortField({field:vgField(model),order},channel);if(isAggregateOp(aggregate)||!aggregate)return normalizeSortField({op:aggregate,field,order},channel)}else{if("descending"===scaleType)return{op:"min",field:model.vgField(channel),
order:"descending"};if(contains(["ascending",void 0],scaleType))return!0}}}function canUseUnaggregatedDomain(fieldDef,scaleType){const {aggregate,type}=fieldDef;return aggregate?isString(aggregate)&&!SHARED_DOMAIN_OP_INDEX[aggregate]?{valid:!1,reason:'Unaggregated domain not applicable for "'.concat(aggregate,'" since it produces values outside the origin domain of the source data.')}:"quantitative"===type&&"log"===scaleType?{valid:!1,reason:"Unaggregated domain is currently unsupported for log scale (".concat(stringify(fieldDef),
").")}:{valid:!0}:{valid:!1,reason:"Using unaggregated domain with raw field has no effect (".concat(stringify(fieldDef),").")}}function domainsTieBreaker(v1$jscomp$0,v2$jscomp$0,property,propertyOf){if(v1$jscomp$0.explicit&&v2$jscomp$0.explicit){var v1=v1$jscomp$0.value,v2=v2$jscomp$0.value;property="Conflicting ".concat(propertyOf.toString(),' property "').concat(property.toString(),'" (').concat(stringify(v1)," and ").concat(stringify(v2),"). Using the union of the two domains.");warn(property)}return{explicit:v1$jscomp$0.explicit,
value:[...v1$jscomp$0.value,...v2$jscomp$0.value]}}function mergeDomains(domains){var uniqueDomains=unique(domains.map(domain=>isDataRefDomain(domain)?(domain=Object.assign({},domain),delete domain.sort,domain):domain),hash),sorts=unique(domains.map(d=>{if(isDataRefDomain(d))return d=d.sort,void 0===d||isBoolean$1(d)||("op"in d&&"count"===d.op&&delete d.field,"ascending"===d.order&&delete d.order),d}).filter(s=>void 0!==s),hash);if(0!==uniqueDomains.length){if(1===uniqueDomains.length){uniqueDomains=
domains[0];if(isDataRefDomain(uniqueDomains)&&0<sorts.length){var sort=sorts[0];1<sorts.length?(warn("Domains that should be unioned has conflicting sort properties. Sort will be set to true."),sort=!0):isObject(sort)&&"field"in sort&&uniqueDomains.field===sort.field&&(sort=sort.order?{order:sort.order}:!0);return Object.assign({},uniqueDomains,{sort})}return uniqueDomains}sorts=unique(sorts.map(s=>{if(isBoolean$1(s)||!("op"in s)||isString(s.op)&&s.op in MULTIDOMAIN_SORT_OP_INDEX)return s;warn("Dropping sort property ".concat(stringify(s),
' as unioned domains only support boolean or op "count", "min", and "max".'));return!0}),hash);1===sorts.length?sort=sorts[0]:1<sorts.length&&(warn("Domains that should be unioned has conflicting sort properties. Sort will be set to true."),sort=!0);sorts=unique(domains.map(d=>isDataRefDomain(d)?d.data:null),x=>x);return 1===sorts.length&&null!==sorts[0]?Object.assign({},{data:sorts[0],fields:uniqueDomains.map(d=>d.field)},sort?{sort}:{}):Object.assign({},{fields:uniqueDomains},sort?{sort}:{})}}function getFieldFromDomain(domain){if(isDataRefDomain(domain)&&
isString(domain.field))return domain.field;var JSCompiler_inline_result=isArray(domain)?!1:"fields"in domain&&!("data"in domain);if(JSCompiler_inline_result){let field;for(const nonUnionDomain of domain.fields)if(isDataRefDomain(nonUnionDomain)&&isString(nonUnionDomain.field))if(!field)field=nonUnionDomain.field;else if(field!==nonUnionDomain.field)return warn("Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect."),
field;warn("Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.");return field}JSCompiler_inline_result=isArray(domain)?!1:"fields"in domain&&"data"in domain;if(JSCompiler_inline_result)return warn("Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect."),
domain=domain.fields[0],isString(domain)?domain:void 0}function assembleDomain(model,channel){channel=model.component.scales[channel].get("domains").map(domain=>{isDataRefDomain(domain)&&(domain.data=model.lookupDataSource(domain.data));return domain});return mergeDomains(channel)}function assembleScales(model){return isLayerModel(model)||isConcatModel(model)?model.children.reduce((scales,child)=>scales.concat(assembleScales(child)),assembleScalesForModel(model)):assembleScalesForModel(model)}function assembleScalesForModel(model){return keys$jscomp$0(model.component.scales).reduce((scales,
channel)=>{var scaleComponent=model.component.scales[channel];if(scaleComponent.merged)return scales;var scale=scaleComponent.combine(),$jscomp$destructuring$var177=Object.assign({},scale);scaleComponent=scale.name;const type=scale.type,selectionExtent=scale.selectionExtent,reverse=scale.reverse;$jscomp$destructuring$var177=(delete $jscomp$destructuring$var177.name,delete $jscomp$destructuring$var177.type,delete $jscomp$destructuring$var177.selectionExtent,delete $jscomp$destructuring$var177.domains,
delete $jscomp$destructuring$var177.range,delete $jscomp$destructuring$var177.reverse,$jscomp$destructuring$var177);scale=scale.range;channel in POSITION_SCALE_CHANNEL_INDEX?isVgRangeStep(scale)&&(scale={step:{signal:scaleComponent+"_step"}}):isObject(scale)&&isDataRefDomain(scale)&&(scale=Object.assign({},scale,{data:model.lookupDataSource(scale.data)}));if(selectionExtent){var domainRaw=selectionExtent.selection;domainRaw=model.getSelectionComponent(domainRaw,varName(domainRaw));domainRaw={signal:parseSelectionBinExtent(domainRaw,
selectionExtent)}}channel=assembleDomain(model,channel);scales.push(Object.assign({},{name:scaleComponent,type},channel?{domain:channel}:{},domainRaw?{domainRaw}:{},{range:scale},void 0!==reverse?{reverse}:{},$jscomp$destructuring$var177));return scales},[])}function getSizeChannel$1(channel){return"x"===channel?"width":"y"===channel?"height":void 0}function getBinStepSignal(model,channel){const fieldDef=model.fieldDef(channel);if(fieldDef&&fieldDef.bin&&isBinning(fieldDef.bin)){const binSignal=getBinSignalName(model,
fieldDef.field,fieldDef.bin);channel=getSizeChannel$1(channel);const sizeSignal=model.getName(channel);return new SignalRefWrapper(()=>{var updatedName=model.getSignalName(binSignal);updatedName="(".concat(updatedName,".stop - ").concat(updatedName,".start) / ").concat(updatedName,".step");return"".concat(model.getSignalName(sizeSignal)," / (").concat(updatedName,")")})}}function parseRangeForChannel(channel,model){const specifiedScale=model.specifiedScales[channel];var {size}=model,scaleType=model.getScaleComponent(channel).get("type");
for(var property of RANGE_PROPERTIES)if(void 0!==specifiedScale[property]){const supportedByScaleType=scaleTypeSupportProperty(scaleType,property),channelIncompatability=channelScalePropertyIncompatability(channel,property);if(supportedByScaleType)if(channelIncompatability)warn(channelIncompatability);else switch(property){case "range":scaleType=specifiedScale.range;if(isArray(scaleType)){if(channel in POSITION_SCALE_CHANNEL_INDEX)return makeExplicit(scaleType.map(v=>{if("width"===v||"height"===v){v=
model.getName(v);const getSignalName=model.getSignalName.bind(model);return SignalRefWrapper.fromName(getSignalName,v)}return v}))}else if(isObject(scaleType))return makeExplicit({data:model.requestDataName(DataSourceType.Main),field:scaleType.field,sort:{op:"min",field:model.vgField(channel)}});return makeExplicit(scaleType);case "scheme":return makeExplicit(parseScheme(specifiedScale[property]))}else warn(scalePropertyNotWorkWithScaleType(scaleType,property,channel))}if("x"===channel||"y"===channel)if(property=
"x"===channel?"width":"height",size=size[property],isStep(size)){if(scaleType in DISCRETE_DOMAIN_INDEX)return makeExplicit({step:size.step});warn(stepDropped(property))}const {rangeMin,rangeMax}=specifiedScale;channel=defaultRange(channel,model);return(void 0!==rangeMin||void 0!==rangeMax)&&scaleTypeSupportProperty(scaleType,"rangeMin")&&isArray(channel)&&2===channel.length?makeExplicit([null!==rangeMin&&void 0!==rangeMin?rangeMin:channel[0],null!==rangeMax&&void 0!==rangeMax?rangeMax:channel[1]]):
makeImplicit(channel)}function parseScheme(scheme){return!isString(scheme)&&scheme.name?Object.assign({},{scheme:scheme.name},omit(scheme,["name"])):{scheme}}function defaultRange(channel,model){const {size,config,mark,encoding}=model;var getSignalName=model.getSignalName.bind(model),{type}=getFieldOrDatumDef(encoding[channel]);const scaleType=model.getScaleComponent(channel).get("type"),{domain,domainMid}=model.specifiedScales[channel];switch(channel){case "x":case "y":if(contains(["point","band"],
scaleType))if("x"===channel&&!size.width){if(type=getViewConfigDiscreteSize(config.view,"width"),isStep(type))return type}else if("y"===channel&&!size.height&&(type=getViewConfigDiscreteSize(config.view,"height"),isStep(type)))return type;type=getSizeChannel$1(channel);type=model.getName(type);return"y"===channel&&scaleType in CONTINUOUS_DOMAIN_INDEX?[SignalRefWrapper.fromName(getSignalName,type),0]:[0,SignalRefWrapper.fromName(getSignalName,type)];case "size":return getSignalName=model.component.scales[channel].get("zero"),
getSignalName=sizeRangeMin(mark,getSignalName,config),type=sizeRangeMax(mark,size,model,config),scaleType in CONTINUOUS_TO_DISCRETE_INDEX?interpolateRange(getSignalName,type,defaultContinuousToDiscreteCount(scaleType,config,domain,channel)):[getSignalName,type];case "theta":return[0,2*Math.PI];case "angle":return[0,360];case "radius":return[0,new SignalRefWrapper(()=>{const w=model.getSignalName("width"),h=model.getSignalName("height");return"min(".concat(w,",").concat(h,")/2")})];case "strokeWidth":return[config.scale.minStrokeWidth,
config.scale.maxStrokeWidth];case "strokeDash":return[[1,0],[4,2],[2,1],[1,1],[1,2,4,2]];case "shape":return"symbol";case "color":case "fill":case "stroke":return"ordinal"===scaleType?"nominal"===type?"category":"ordinal":void 0!==domainMid?"diverging":"rect"===mark||"geoshape"===mark?"heatmap":"ramp";case "opacity":case "fillOpacity":case "strokeOpacity":return[config.scale.minOpacity,config.scale.maxOpacity]}throw Error("Scale range undefined for channel ".concat(channel));}function defaultContinuousToDiscreteCount(scaleType,
config,domain,channel){switch(scaleType){case "quantile":return config.scale.quantileCount;case "quantize":return config.scale.quantizeCount;case "threshold":if(void 0!==domain&&isArray(domain))return domain.length+1;warn("Domain for ".concat(channel," is required for threshold scale."));return 3}}function interpolateRange(rangeMin,rangeMax,cardinality){const f=()=>{const rMax=signalOrStringValue(rangeMax),rMin=signalOrStringValue(rangeMin),step="(".concat(rMax," - ").concat(rMin,") / (").concat(cardinality,
" - 1)");return"sequence(".concat(rMin,", ").concat(rMax," + ").concat(step,", ").concat(step,")")};return isSignalRef(rangeMax)?new SignalRefWrapper(f):{signal:f()}}function sizeRangeMin(mark,zero,config){if(zero)return isSignalRef(zero)?{signal:"".concat(zero.signal," ? 0 : ").concat(sizeRangeMin(mark,!1,config))}:0;switch(mark){case "bar":case "tick":return config.scale.minBandSize;case "line":case "trail":case "rule":return config.scale.minStrokeWidth;case "text":return config.scale.minFontSize;
case "point":case "square":case "circle":return config.scale.minSize}throw Error(incompatibleChannel("size",mark));}function sizeRangeMax(mark,size,model,config){model={x:getBinStepSignal(model,"x"),y:getBinStepSignal(model,"y")};switch(mark){case "bar":case "tick":{if(void 0!==config.scale.maxBandSize)return config.scale.maxBandSize;const min=minXYStep(size,model,config.view);return isNumber(min)?min-1:new SignalRefWrapper(()=>"".concat(min.signal," - 1"))}case "line":case "trail":case "rule":return config.scale.maxStrokeWidth;
case "text":return config.scale.maxFontSize;case "point":case "square":case "circle":{if(config.scale.maxSize)return config.scale.maxSize;const pointStep=minXYStep(size,model,config.view);return isNumber(pointStep)?Math.pow(.95*pointStep,2):new SignalRefWrapper(()=>"pow(".concat(.95," * ").concat(pointStep.signal,", 2)"))}}throw Error(incompatibleChannel("size",mark));}function minXYStep(size,xyStepSignals,viewConfig){const widthStep=isStep(size.width)?size.width.step:getViewConfigDiscreteStep(viewConfig,
"width"),heightStep=isStep(size.height)?size.height.step:getViewConfigDiscreteStep(viewConfig,"height");return xyStepSignals.x||xyStepSignals.y?new SignalRefWrapper(()=>"min(".concat([xyStepSignals.x?xyStepSignals.x.signal:widthStep,xyStepSignals.y?xyStepSignals.y.signal:heightStep].join(", "),")")):Math.min(widthStep,heightStep)}function parseScaleProperty(model,property){if(isUnitModel(model)){{const localScaleComponents=model.component.scales,{config,encoding,markDef,specifiedScales}=model;for(const channel of keys$jscomp$0(localScaleComponents)){var specifiedScale=
specifiedScales[channel];const localScaleCmpt=localScaleComponents[channel];var mergedScaleCmpt=model.getScaleComponent(channel),fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]),specifiedValue=specifiedScale[property];const scaleType=mergedScaleCmpt.get("type"),scalePadding=mergedScaleCmpt.get("padding");mergedScaleCmpt=mergedScaleCmpt.get("paddingInner");const supportedByScaleType=scaleTypeSupportProperty(scaleType,property),channelIncompatability=channelScalePropertyIncompatability(channel,
property);void 0!==specifiedValue&&(supportedByScaleType?channelIncompatability&&warn(channelIncompatability):warn(scalePropertyNotWorkWithScaleType(scaleType,property,channel)));if(supportedByScaleType&&void 0===channelIncompatability)if(void 0!==specifiedValue)switch(specifiedValue=fieldOrDatumDef.timeUnit,fieldOrDatumDef=fieldOrDatumDef.type,property){case "domainMax":case "domainMin":isDateTime(specifiedScale[property])||"temporal"===fieldOrDatumDef||specifiedValue?localScaleCmpt.set(property,
{signal:valueExpr(specifiedScale[property],{type:fieldOrDatumDef,timeUnit:specifiedValue})},!0):localScaleCmpt.set(property,specifiedScale[property],!0);break;default:localScaleCmpt.copyKeyFromObject(property,specifiedScale)}else specifiedScale=property in scaleRules?scaleRules[property]({model,channel,fieldOrDatumDef,scaleType,scalePadding,scalePaddingInner:mergedScaleCmpt,domain:specifiedScale.domain,markDef,config}):config.scale[property],void 0!==specifiedScale&&localScaleCmpt.set(property,specifiedScale,
!1)}}}else parseNonUnitScaleProperty(model,property)}function parseScaleRange(model){if(isUnitModel(model)){{const localScaleComponents=model.component.scales;for(const channel of SCALE_CHANNELS){const localScaleCmpt=localScaleComponents[channel];if(!localScaleCmpt)continue;const rangeWithExplicit=parseRangeForChannel(channel,model);localScaleCmpt.setWithExplicit("range",rangeWithExplicit)}}}else parseNonUnitScaleProperty(model,"range")}function parseNonUnitScaleProperty(model,property){const localScaleComponents=
model.component.scales;for(var child$jscomp$0 of model.children)"range"===property?parseScaleRange(child$jscomp$0):parseScaleProperty(child$jscomp$0,property);for(const channel of keys$jscomp$0(localScaleComponents)){let valueWithExplicit;for(const child of model.children)if(child$jscomp$0=child.component.scales[channel])child$jscomp$0=child$jscomp$0.getWithExplicit(property),valueWithExplicit=mergeValuesWithExplicit(valueWithExplicit,child$jscomp$0,property,"scale",tieBreakByComparing((v1,v2)=>{switch(property){case "range":if(v1.step&&
v2.step)return v1.step-v2.step}return 0}));localScaleComponents[channel].setWithExplicit(property,valueWithExplicit)}}function bins$jscomp$1(model,fieldDef){const bin=fieldDef.bin;if(isBinning(bin)){const binSignal=getBinSignalName(model,fieldDef.field,bin);return new SignalRefWrapper(()=>model.getSignalName(binSignal))}if(isBinned(bin)&&isObject(bin)&&void 0!==bin.step)return{step:bin.step}}function defaultType$2(channel,fieldDef,mark){var _fieldDef$axis;switch(fieldDef.type){case "nominal":case "ordinal":if(isColorChannel(channel)||
"discrete"===rangeType(channel))return"shape"===channel&&"ordinal"===fieldDef.type&&warn(discreteChannelCannotEncode(channel,"ordinal")),"ordinal";if(channel in POSITION_SCALE_CHANNEL_INDEX){if(contains(["rect","bar","image","rule"],mark))return"band"}else if("arc"===mark&&channel in POLAR_POSITION_SCALE_CHANNEL_INDEX)return"band";return void 0!==fieldDef.band||isPositionFieldOrDatumDef(fieldDef)&&(null===(_fieldDef$axis=fieldDef.axis)||void 0===_fieldDef$axis?0:_fieldDef$axis.tickBand)?"band":"point";
case "temporal":if(!isColorChannel(channel)){if("discrete"===rangeType(channel))return warn(discreteChannelCannotEncode(channel,"temporal")),"ordinal";if(isFieldDef(fieldDef)&&fieldDef.timeUnit&&normalizeTimeUnit(fieldDef.timeUnit).utc)return"utc"}return"time";case "quantitative":if(isColorChannel(channel)){if(isFieldDef(fieldDef)&&isBinning(fieldDef.bin))return"bin-ordinal"}else if("discrete"===rangeType(channel))return warn(discreteChannelCannotEncode(channel,"quantitative")),"ordinal";return"linear";
case "geojson":return}throw Error('Invalid field type "'.concat(fieldDef.type,'".'));}function parseScaleCore(model$jscomp$0){if(isUnitModel(model$jscomp$0))model$jscomp$0.component.scales=parseUnitScaleCore(model$jscomp$0);else{var JSCompiler_temp_const=model$jscomp$0.component;{const scaleComponents=model$jscomp$0.component.scales={},scaleTypeWithExplicitIndex={};var resolve=model$jscomp$0.component.resolve;for(const child of model$jscomp$0.children){parseScaleCore(child);for(const channel of keys$jscomp$0(child.component.scales)){var _resolve$scale$channe,
JSCompiler_temp_const$jscomp$0=resolve.scale;if(null!==(_resolve$scale$channe=resolve.scale[channel])&&void 0!==_resolve$scale$channe)var JSCompiler_temp=_resolve$scale$channe;else{JSCompiler_temp=channel;var model=model$jscomp$0;if(isLayerModel(model)||isFacetModel(model))JSCompiler_temp="shared";else if(isConcatModel(model))JSCompiler_temp=JSCompiler_temp in POSITION_SCALE_CHANNEL_INDEX?"independent":"shared";else throw Error("invalid model type for resolve");}JSCompiler_temp_const$jscomp$0[channel]=
JSCompiler_temp;if("shared"===resolve.scale[channel])if(JSCompiler_temp_const$jscomp$0=scaleTypeWithExplicitIndex[channel],JSCompiler_temp=child.component.scales[channel].getWithExplicit("type"),JSCompiler_temp_const$jscomp$0){{model=SCALE_CATEGORY_INDEX[JSCompiler_temp_const$jscomp$0.value];const scaleCategory2=SCALE_CATEGORY_INDEX[JSCompiler_temp.value];model=model===scaleCategory2||"ordinal-position"===model&&"time"===scaleCategory2||"ordinal-position"===scaleCategory2&&"time"===model}model?scaleTypeWithExplicitIndex[channel]=
mergeValuesWithExplicit(JSCompiler_temp_const$jscomp$0,JSCompiler_temp,"type","scale",scaleTypeTieBreaker):(resolve.scale[channel]="independent",delete scaleTypeWithExplicitIndex[channel])}else scaleTypeWithExplicitIndex[channel]=JSCompiler_temp}}for(const channel of keys$jscomp$0(scaleTypeWithExplicitIndex)){_resolve$scale$channe=model$jscomp$0.scaleName(channel,!0);scaleComponents[channel]=new ScaleComponent(_resolve$scale$channe,scaleTypeWithExplicitIndex[channel]);for(const child of model$jscomp$0.children)if(resolve=
child.component.scales[channel])child.renameScale(resolve.get("name"),_resolve$scale$channe),resolve.merged=!0}model$jscomp$0=scaleComponents}JSCompiler_temp_const.scales=model$jscomp$0}}function parseUnitScaleCore(model){const {encoding,mark}=model;return SCALE_CHANNELS.reduce((scaleComponents,channel)=>{var fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);if(fieldOrDatumDef&&mark===GEOSHAPE&&"shape"===channel&&"geojson"===fieldOrDatumDef.type)return scaleComponents;let specifiedScale=fieldOrDatumDef&&
fieldOrDatumDef.scale;if(fieldOrDatumDef&&null!==specifiedScale&&!1!==specifiedScale){var _specifiedScale;specifiedScale=null!==(_specifiedScale=specifiedScale)&&void 0!==_specifiedScale?_specifiedScale:{};var specifiedScale$jscomp$0=specifiedScale;_specifiedScale=defaultType$2(channel,fieldOrDatumDef,mark);({type:specifiedScale$jscomp$0}=specifiedScale$jscomp$0);if(SCALE_CHANNEL_INDEX[channel]){if(void 0!==specifiedScale$jscomp$0)if(channelSupportScaleType(channel,specifiedScale$jscomp$0)){var JSCompiler_temp;
if(JSCompiler_temp=isFieldDef(fieldOrDatumDef))JSCompiler_temp=specifiedScale$jscomp$0,fieldOrDatumDef=fieldOrDatumDef.type,JSCompiler_temp=!(contains(["ordinal","nominal"],fieldOrDatumDef)?void 0===JSCompiler_temp||JSCompiler_temp in DISCRETE_DOMAIN_INDEX:"temporal"===fieldOrDatumDef?contains([ScaleType.TIME,ScaleType.UTC,void 0],JSCompiler_temp):"quantitative"===fieldOrDatumDef?contains([ScaleType.LOG,ScaleType.POW,ScaleType.SQRT,ScaleType.SYMLOG,ScaleType.QUANTILE,ScaleType.QUANTIZE,ScaleType.THRESHOLD,
ScaleType.LINEAR,void 0],JSCompiler_temp):1);JSCompiler_temp?(fieldOrDatumDef=_specifiedScale,fieldOrDatumDef='FieldDef does not work with "'.concat(specifiedScale$jscomp$0,'" scale. We are using "').concat(fieldOrDatumDef,'" scale instead.'),warn(fieldOrDatumDef)):_specifiedScale=specifiedScale$jscomp$0}else fieldOrDatumDef=specifiedScale$jscomp$0,specifiedScale$jscomp$0=_specifiedScale,fieldOrDatumDef='Channel "'.concat(channel,'" does not work with "').concat(fieldOrDatumDef,'" scale. We are using "').concat(specifiedScale$jscomp$0,
'" scale instead.'),warn(fieldOrDatumDef)}else _specifiedScale=null;scaleComponents[channel]=new ScaleComponent(model.scaleName(channel+"",!0),{value:_specifiedScale,explicit:specifiedScale.type===_specifiedScale})}return scaleComponents},{})}function isUnitModel(model){return"unit"===(null===model||void 0===model?void 0:model.type)}function isFacetModel(model){return"facet"===(null===model||void 0===model?void 0:model.type)}function isConcatModel(model){return"concat"===(null===model||void 0===model?
void 0:model.type)}function isLayerModel(model){return"layer"===(null===model||void 0===model?void 0:model.type)}function makeWalkTree(data){function walkTree(node,dataSource){node instanceof SourceNode&&!(node.isGenerator||"url"in node.data)&&(data.push(dataSource),dataSource={name:null,source:dataSource.name,transform:[]});if(node instanceof ParseNode)if(node.parent instanceof SourceNode&&!dataSource.source){var _dataSource$format;dataSource.format=Object.assign({},null!==(_dataSource$format=dataSource.format)&&
void 0!==_dataSource$format?_dataSource$format:{},{parse:node.assembleFormatParse()});dataSource.transform.push(...node.assembleTransforms(!0))}else dataSource.transform.push(...node.assembleTransforms());if(node instanceof FacetNode){dataSource.name||(dataSource.name="data_".concat(datasetIndex++));!dataSource.source||0<dataSource.transform.length?(data.push(dataSource),node.data=dataSource.name):node.data=dataSource.source;for(const d of node.assemble())data.push(d)}else switch((node instanceof
GraticuleNode||node instanceof SequenceNode||node instanceof FilterInvalidNode||node instanceof FilterNode||node instanceof CalculateNode||node instanceof GeoPointNode||node instanceof GeoJSONNode||node instanceof AggregateNode||node instanceof LookupNode||node instanceof WindowTransformNode||node instanceof JoinAggregateTransformNode||node instanceof FoldTransformNode||node instanceof FlattenTransformNode||node instanceof DensityTransformNode||node instanceof LoessTransformNode||node instanceof QuantileTransformNode||
node instanceof RegressionTransformNode||node instanceof IdentifierNode||node instanceof SampleTransformNode||node instanceof PivotTransformNode)&&dataSource.transform.push(node.assemble()),(node instanceof BinNode||node instanceof TimeUnitNode||node instanceof ImputeNode||node instanceof StackNode)&&dataSource.transform.push(...node.assemble()),node instanceof OutputNode&&(dataSource.source&&0===dataSource.transform.length?node.setSource(dataSource.source):node.parent instanceof OutputNode?node.setSource(dataSource.name):
(dataSource.name||(dataSource.name="data_".concat(datasetIndex++)),node.setSource(dataSource.name),1===node.numChildren()&&(data.push(dataSource),dataSource={name:null,source:dataSource.name,transform:[]}))),node.numChildren()){case 0:node instanceof OutputNode&&(!dataSource.source||0<dataSource.transform.length)&&data.push(dataSource);break;case 1:walkTree(node.children[0],dataSource);break;default:dataSource.name||(dataSource.name="data_".concat(datasetIndex++));_dataSource$format=dataSource.name;
!dataSource.source||0<dataSource.transform.length?data.push(dataSource):_dataSource$format=dataSource.source;for(const child of node.children)walkTree(child,{name:null,source:_dataSource$format,transform:[]})}}let datasetIndex=0;return walkTree}function assembleFacetData(root){const data=[],walkTree=makeWalkTree(data);for(const child of root.children)walkTree(child,{source:root.name,name:null,transform:[]});return data}function assembleRootData(dataComponent,datasets){const data=[];var walkTree=makeWalkTree(data);
let sourceIndex=0;for(const root of dataComponent.sources){root.hasName()||(root.dataName="source_".concat(sourceIndex++));const newData=root.assemble();walkTree(root,newData)}for(const d of data)0===d.transform.length&&delete d.transform;walkTree=0;for(const $jscomp$destructuring$var201 of data.entries()){const [i,d]=$jscomp$destructuring$var201;var _d$transform;0!==(null!==(_d$transform=d.transform)&&void 0!==_d$transform?_d$transform:[]).length||d.source||data.splice(walkTree++,0,data.splice(i,
1)[0])}for(const d of data)for(const t of null!==(_d$transform2=d.transform)&&void 0!==_d$transform2?_d$transform2:[]){var _d$transform2;"lookup"===t.type&&(t.from=dataComponent.outputNodes[t.from].getSource())}for(const d of data)d.name in datasets&&(d.values=datasets[d.name]);return data}function makeHeaderComponent(model,channel,labels){channel="row"===channel?"height":"width";return{labels,sizeSignal:model.child.component.layoutSize.get(channel)?model.child.getSizeSignalRef(channel):void 0,axes:[]}}
function mergeChildAxis(model,channel){var {child}=model;if(child.component.axes[channel]){const {layoutHeaders,resolve}=model.component;resolve.axis[channel]=parseGuideResolve(resolve,channel);if("shared"===resolve.axis[channel]){const headerChannel="x"===channel?"column":"row",layoutHeader=layoutHeaders[headerChannel];for(const axisComponent of child.component.axes[channel]){var _layoutHeader$headerT;channel=axisComponent.get("orient");channel="top"===channel||"left"===channel||isSignalRef(channel)?
"header":"footer";layoutHeader[channel]=null!==(_layoutHeader$headerT=layoutHeader[channel])&&void 0!==_layoutHeader$headerT?_layoutHeader$headerT:[makeHeaderComponent(model,headerChannel,!1)];(child=assembleAxis(axisComponent,"main",model.config,{header:!0}))&&layoutHeader[channel][0].axes.push(child);axisComponent.mainExtracted=!0}}}}function parseChildrenLayoutSize(model){for(const child of model.children)child.parseLayoutSize()}function parseNonUnitLayoutSizeForChannel(model,layoutSizeType){const sizeType=
getSizeTypeFromLayoutSizeType(layoutSizeType),channel=getPositionScaleChannel(sizeType),resolve=model.component.resolve,layoutSizeCmpt=model.component.layoutSize;let mergedSize;for(const child of model.children){const childSize=child.component.layoutSize.getWithExplicit(sizeType),scaleResolve=resolve.scale[channel];if("independent"===scaleResolve&&"step"===childSize.value){mergedSize=void 0;break}if(mergedSize){if("independent"===scaleResolve&&mergedSize.value!==childSize.value){mergedSize=void 0;
break}mergedSize=mergeValuesWithExplicit(mergedSize,childSize,sizeType,"")}else mergedSize=childSize}if(mergedSize){for(const child of model.children)model.renameSignal(child.getName(sizeType),model.getName(layoutSizeType)),child.component.layoutSize.set(sizeType,"merged",!1);layoutSizeCmpt.setWithExplicit(layoutSizeType,mergedSize)}else layoutSizeCmpt.setWithExplicit(layoutSizeType,{explicit:!1,value:void 0})}function defaultUnitSize(model,sizeType){const config=model.config;var scaleComponent=model.getScaleComponent("width"===
sizeType?"x":"y");if(scaleComponent)return model=scaleComponent.get("type"),scaleComponent=scaleComponent.get("range"),model in DISCRETE_DOMAIN_INDEX?(sizeType=getViewConfigDiscreteSize(config.view,sizeType),isVgRangeStep(scaleComponent)||isStep(sizeType)?"step":sizeType):getViewConfigContinuousSize(config.view,sizeType);if(model.hasProjection||"arc"===model.mark)return getViewConfigContinuousSize(config.view,sizeType);sizeType=getViewConfigDiscreteSize(config.view,sizeType);return isStep(sizeType)?
sizeType.step:sizeType}function facetSortFieldName(fieldDef,sort,opt){return vgField(sort,Object.assign({},{suffix:"by_".concat(vgField(fieldDef))},null!==opt&&void 0!==opt?opt:{}))}function findSource(data,sources){for(const other of sources){var _data$format,_otherData$format,_data$format2,_otherData$format2;sources=other.data;if(data.name&&other.hasName()&&data.name!==other.dataName)continue;const formatMesh=null===(_data$format=data.format)||void 0===_data$format?void 0:_data$format.mesh;var otherFeature=
null===(_otherData$format=sources.format)||void 0===_otherData$format?void 0:_otherData$format.feature;if(formatMesh&&otherFeature)continue;const formatFeature=null===(_data$format2=data.format)||void 0===_data$format2?void 0:_data$format2.feature;if(!formatFeature&&!otherFeature||formatFeature===otherFeature)if(otherFeature=null===(_otherData$format2=sources.format)||void 0===_otherData$format2?void 0:_otherData$format2.mesh,!formatMesh&&!otherFeature||formatMesh===otherFeature)if("values"in data&&
"values"in sources){if(deepEqual(data.values,sources.values))return other}else if("url"in data&&"url"in sources){if(data.url===sources.url)return other}else if(isNamedData(data)&&data.name===other.dataName)return other}return null}function parseRoot(model,sources){if(model.data||!model.parent){if(null===model.data)return model=new SourceNode({values:[]}),sources.push(model),model;const existingSource=findSource(model.data,sources);if(existingSource)return isGenerator(model.data)||(existingSource.data.format=
mergeDeep({},model.data.format,existingSource.data.format)),!existingSource.hasName()&&model.data.name&&(existingSource.dataName=model.data.name),existingSource;model=new SourceNode(model.data);sources.push(model);return model}return model.parent.component.data.facetRoot?model.parent.component.data.facetRoot:model.parent.component.data.main}function parseData(model){var _data$format3,_ParseNode$makeExplic,_ParseNode$makeWithAn2,head=parseRoot(model,model.component.data.sources);const {outputNodes,
outputNodeRefCounts}=model.component.data,ancestorParse=model.parent?model.parent.component.data.ancestorParse.clone():new AncestorParse,data=model.data;isGenerator(data)?("sequence"in data?head=new SequenceNode(head,data.sequence):"graticule"in data&&(head=new GraticuleNode(head,data.graticule)),ancestorParse.parseNothing=!0):null===(null===data||void 0===data?void 0:null===(_data$format3=data.format)||void 0===_data$format3?void 0:_data$format3.parse)&&(ancestorParse.parseNothing=!0);head=null!==
(_ParseNode$makeExplic=ParseNode.makeExplicit(head,model,ancestorParse))&&void 0!==_ParseNode$makeExplic?_ParseNode$makeExplic:head;head=new IdentifierNode(head);_data$format3=model.parent&&isLayerModel(model.parent);if((isUnitModel(model)||isFacetModel(model))&&_data$format3){var _BinNode$makeFromEnco;head=null!==(_BinNode$makeFromEnco=BinNode.makeFromEncoding(head,model))&&void 0!==_BinNode$makeFromEnco?_BinNode$makeFromEnco:head}if(0<model.transforms.length){_BinNode$makeFromEnco=0;for(const t of model.transforms){var transformNode=
_ParseNode$makeExplic=void 0;if("calculate"in t)transformNode=head=new CalculateNode(head,t),_ParseNode$makeExplic="derived";else if("filter"in t){var _ParseNode$makeWithAn;transformNode=getImplicitFromFilterTransform(t);transformNode=head=null!==(_ParseNode$makeWithAn=ParseNode.makeWithAncestors(head,{},transformNode,ancestorParse))&&void 0!==_ParseNode$makeWithAn?_ParseNode$makeWithAn:head;head=new FilterNode(head,model,t.filter)}else if("bin"in t)transformNode=head=BinNode.makeFromTransform(head,
t,model),_ParseNode$makeExplic="number";else if("timeUnit"in t)_ParseNode$makeExplic="date",void 0===ancestorParse.getWithExplicit(t.field).value&&(head=new ParseNode(head,{[t.field]:_ParseNode$makeExplic}),ancestorParse.set(t.field,_ParseNode$makeExplic,!1)),transformNode=head=TimeUnitNode.makeFromTransform(head,t);else if("aggregate"in t)transformNode=head=AggregateNode.makeFromTransform(head,t),_ParseNode$makeExplic="number",requiresSelectionId(model)&&(head=new IdentifierNode(head));else if("lookup"in
t)transformNode=head=LookupNode.make(head,model,t,_BinNode$makeFromEnco++),_ParseNode$makeExplic="derived";else if("window"in t)transformNode=head=new WindowTransformNode(head,t),_ParseNode$makeExplic="number";else if("joinaggregate"in t)transformNode=head=new JoinAggregateTransformNode(head,t),_ParseNode$makeExplic="number";else if("stack"in t)transformNode=head=StackNode.makeFromTransform(head,t),_ParseNode$makeExplic="derived";else if("fold"in t)transformNode=head=new FoldTransformNode(head,t),
_ParseNode$makeExplic="derived";else if("flatten"in t)transformNode=head=new FlattenTransformNode(head,t),_ParseNode$makeExplic="derived";else if("pivot"in t)transformNode=head=new PivotTransformNode(head,t),_ParseNode$makeExplic="derived";else if("sample"in t)head=new SampleTransformNode(head,t);else if("impute"in t)transformNode=head=ImputeNode.makeFromTransform(head,t),_ParseNode$makeExplic="derived";else if("density"in t)transformNode=head=new DensityTransformNode(head,t),_ParseNode$makeExplic=
"derived";else if("quantile"in t)transformNode=head=new QuantileTransformNode(head,t),_ParseNode$makeExplic="derived";else if("regression"in t)transformNode=head=new RegressionTransformNode(head,t),_ParseNode$makeExplic="derived";else if("loess"in t)transformNode=head=new LoessTransformNode(head,t),_ParseNode$makeExplic="derived";else{warn("Ignoring an invalid transform: ".concat(stringify(t),"."));continue}if(transformNode&&void 0!==_ParseNode$makeExplic)for(const field of null!==(_transformNode$produc=
transformNode.producedFields())&&void 0!==_transformNode$produc?_transformNode$produc:[]){var _transformNode$produc;ancestorParse.set(field,_ParseNode$makeExplic,!1)}}}_ParseNode$makeWithAn={};if(isUnitModel(model)&&model.component.selection)for(JSCompiler_inline_result of keys$jscomp$0(model.component.selection)){_transformNode$produc=model.component.selection[JSCompiler_inline_result];for(var proj of _transformNode$produc.project.items)!proj.channel&&1<accessPathDepth(proj.field)&&(_ParseNode$makeWithAn[proj.field]=
"flatten")}var JSCompiler_inline_result=_ParseNode$makeWithAn;proj=getImplicitFromEncoding(model);head=null!==(_ParseNode$makeWithAn2=ParseNode.makeWithAncestors(head,{},Object.assign({},JSCompiler_inline_result,proj),ancestorParse))&&void 0!==_ParseNode$makeWithAn2?_ParseNode$makeWithAn2:head;isUnitModel(model)&&(head=GeoJSONNode.parseAll(head,model),head=GeoPointNode.parseAll(head,model));if(isUnitModel(model)||isFacetModel(model)){var _TimeUnitNode$makeFro;if(!_data$format3){var _BinNode$makeFromEnco2;
head=null!==(_BinNode$makeFromEnco2=BinNode.makeFromEncoding(head,model))&&void 0!==_BinNode$makeFromEnco2?_BinNode$makeFromEnco2:head}head=null!==(_TimeUnitNode$makeFro=TimeUnitNode.makeFromEncoding(head,model))&&void 0!==_TimeUnitNode$makeFro?_TimeUnitNode$makeFro:head;head=CalculateNode.parseAllForSortIndex(head,model)}_TimeUnitNode$makeFro=model.getDataName(DataSourceType.Raw);_ParseNode$makeWithAn2=new OutputNode(head,_TimeUnitNode$makeFro,DataSourceType.Raw,outputNodeRefCounts);head=outputNodes[_TimeUnitNode$makeFro]=
_ParseNode$makeWithAn2;if(isUnitModel(model)){var _ImputeNode$makeFromE,_StackNode$makeFromEn;if(_TimeUnitNode$makeFro=AggregateNode.makeFromEncoding(head,model))head=_TimeUnitNode$makeFro,requiresSelectionId(model)&&(head=new IdentifierNode(head));head=null!==(_ImputeNode$makeFromE=ImputeNode.makeFromEncoding(head,model))&&void 0!==_ImputeNode$makeFromE?_ImputeNode$makeFromE:head;head=null!==(_StackNode$makeFromEn=StackNode.makeFromEncoding(head,model))&&void 0!==_StackNode$makeFromEn?_StackNode$makeFromEn:
head}if(isUnitModel(model)){var _FilterInvalidNode$ma;head=null!==(_FilterInvalidNode$ma=FilterInvalidNode.make(head,model))&&void 0!==_FilterInvalidNode$ma?_FilterInvalidNode$ma:head}_StackNode$makeFromEn=model.getDataName(DataSourceType.Main);_ImputeNode$makeFromE=new OutputNode(head,_StackNode$makeFromEn,DataSourceType.Main,outputNodeRefCounts);head=outputNodes[_StackNode$makeFromEn]=_ImputeNode$makeFromE;isUnitModel(model)&&materializeSelections(model,_ImputeNode$makeFromE);_FilterInvalidNode$ma=
null;if(isFacetModel(model)){var _makeJoinAggregateFro;_StackNode$makeFromEn=model.getName("facet");{_FilterInvalidNode$ma=head;const {row,column}=model.facet;if(row&&column){_TimeUnitNode$makeFro=null;for(JSCompiler_inline_result$jscomp$0 of[row,column])if(isSortField(JSCompiler_inline_result$jscomp$0.sort)){const {field,op="min"}=JSCompiler_inline_result$jscomp$0.sort;_FilterInvalidNode$ma=_TimeUnitNode$makeFro=new JoinAggregateTransformNode(_FilterInvalidNode$ma,{joinaggregate:[{op,field,as:facetSortFieldName(JSCompiler_inline_result$jscomp$0,
JSCompiler_inline_result$jscomp$0.sort,{forAs:!0})}],groupby:[vgField(JSCompiler_inline_result$jscomp$0)]})}var JSCompiler_inline_result$jscomp$0=_TimeUnitNode$makeFro}else JSCompiler_inline_result$jscomp$0=null}head=null!==(_makeJoinAggregateFro=JSCompiler_inline_result$jscomp$0)&&void 0!==_makeJoinAggregateFro?_makeJoinAggregateFro:head;_FilterInvalidNode$ma=new FacetNode(head,model,_StackNode$makeFromEn,_ImputeNode$makeFromE.getSource());outputNodes[_StackNode$makeFromEn]=_FilterInvalidNode$ma}return Object.assign({},
model.component.data,{outputNodes,outputNodeRefCounts,raw:_ParseNode$makeWithAn2,main:_ImputeNode$makeFromE,facetRoot:_FilterInvalidNode$ma,ancestorParse})}function parseUnitAxes(model){return POSITION_SCALE_CHANNELS.reduce((axis,channel)=>{model.component.scales[channel]&&(axis[channel]=[parseAxis(channel,model)]);return axis},{})}function mergeAxisComponents(mergedAxisCmpts,childAxisCmpts){if(mergedAxisCmpts){if(mergedAxisCmpts.length!==childAxisCmpts.length)return;const length=mergedAxisCmpts.length;
for(let i=0;i<length;i++){const merged=mergedAxisCmpts[i],child=childAxisCmpts[i];if(!!merged!==!!child)return;if(merged&&child){const mergedOrient=merged.getWithExplicit("orient"),childOrient=child.getWithExplicit("orient");if(mergedOrient.explicit&&childOrient.explicit&&mergedOrient.value!==childOrient.value)return;mergedAxisCmpts[i]=mergeAxisComponent(merged,child)}}}else return childAxisCmpts.map(axisComponent=>axisComponent.clone());return mergedAxisCmpts}function mergeAxisComponent(merged,child){for(const prop of AXIS_COMPONENT_PROPERTIES){const mergedValueWithExplicit=
mergeValuesWithExplicit(merged.getWithExplicit(prop),child.getWithExplicit(prop),prop,"axis",(v1,v2)=>{switch(prop){case "title":return mergeTitleComponent(v1,v2);case "gridScale":return{explicit:v1.explicit,value:getFirstDefined(v1.value,v2.value)}}return defaultTieBreaker(v1,v2,prop,"axis")});merged.setWithExplicit(prop,mergedValueWithExplicit)}return merged}function isExplicit$1(value,property,axis,model,channel){if("disable"===property)return void 0!==axis;axis=axis||{};switch(property){case "titleAngle":case "labelAngle":return value===
(isSignalRef(axis.labelAngle)?axis.labelAngle:normalizeAngle(axis.labelAngle));case "values":return!!axis.values;case "encode":return!!axis.encoding||!!axis.labelAngle;case "title":if(value===getFieldDefTitle(model,channel))return!0}return value===axis[property]}function parseAxis(channel,model){var _axis,_config,_config$axis,_axis2,_axis$encoding;let axis=model.axis(channel);const axisComponent=new AxisComponent;var fieldOrDatumDef=getFieldOrDatumDef(model.encoding[channel]);const {mark,config:config$jscomp$0}=
model;var orient=(null===(_axis=axis)||void 0===_axis?void 0:_axis.orient)||(null===(_config=config$jscomp$0["x"===channel?"axisX":"axisY"])||void 0===_config?void 0:_config.orient)||(null===(_config$axis=config$jscomp$0.axis)||void 0===_config$axis?void 0:_config$axis.orient)||("x"===channel?"bottom":"left");_config=model.getScaleComponent(channel).get("type");_axis=getAxisConfigs(channel,_config,orient,model.config);_config$axis=void 0!==axis?!axis:getAxisConfig("disable",config$jscomp$0.style,
null===(_axis2=axis)||void 0===_axis2?void 0:_axis2.style,_axis).configValue;axisComponent.set("disable",_config$axis,void 0!==axis);if(_config$axis)return axisComponent;axis=axis||{};_axis2=getLabelAngle(fieldOrDatumDef,axis,channel,config$jscomp$0.style,_axis);fieldOrDatumDef={fieldOrDatumDef,axis,channel,model,scaleType:_config,orient,labelAngle:_axis2,mark,config:config$jscomp$0};for(const property of AXIS_COMPONENT_PROPERTIES)if(orient=property in axisRules?axisRules[property](fieldOrDatumDef):
AXIS_PROPERTIES_INDEX[property]?axis[property]:void 0,_axis2=void 0!==orient,_config=isExplicit$1(orient,property,axis,model,channel),_axis2&&_config)axisComponent.set(property,orient,_config);else{const {configValue,configFrom}=AXIS_PROPERTIES_INDEX[property]&&"values"!==property?getAxisConfig(property,config$jscomp$0.style,axis.style,_axis):{};_config$axis=void 0!==configValue;_axis2&&!_config$axis?axisComponent.set(property,orient,_config):("vgAxisConfig"!==configFrom||propsToAlwaysIncludeConfig.has(property)&&
_config$axis||isConditionalAxisValue(configValue)||isSignalRef(configValue))&&axisComponent.set(property,configValue,!1)}const axisEncoding=null!==(_axis$encoding=axis.encoding)&&void 0!==_axis$encoding?_axis$encoding:{};_axis$encoding=AXIS_PARTS.reduce((e,part)=>{var _axisEncoding$part;if(!axisComponent.hasAxisPart(part))return e;var axisEncodingPart=guideEncodeEntry(null!==(_axisEncoding$part=axisEncoding[part])&&void 0!==_axisEncoding$part?_axisEncoding$part:{},model);if("labels"===part){{var _getFieldOrDatumDef;
const {encoding,config}=model;_axisEncoding$part=null!==(_getFieldOrDatumDef=getFieldOrDatumDef(encoding[channel]))&&void 0!==_getFieldOrDatumDef?_getFieldOrDatumDef:getFieldOrDatumDef(encoding[getSecondaryRangeChannel(channel)]);_getFieldOrDatumDef=model.axis(channel)||{};const {format,formatType}=_getFieldOrDatumDef;axisEncodingPart=isCustomFormatType(formatType)?Object.assign({},{text:formatCustomType({fieldOrDatumDef:_axisEncoding$part,field:"datum.value",format,formatType,config})},axisEncodingPart):
axisEncodingPart}}void 0===axisEncodingPart||isEmpty(axisEncodingPart)||(e[part]={update:axisEncodingPart});return e},{});isEmpty(_axis$encoding)||axisComponent.set("encode",_axis$encoding,!!axis.encoding||void 0!==axis.labelAngle);return axisComponent}function orient$jscomp$1(mark,encoding,specifiedOrient){switch(mark){case POINT:case CIRCLE:case SQUARE:case TEXT$1:case RECT:case IMAGE:return}const {x,y,x2,y2}=encoding;switch(mark){case BAR:if(isFieldDef(x)&&(isBinned(x.bin)||isFieldDef(y)&&y.aggregate&&
!x.aggregate))break;if(isFieldDef(y)&&(isBinned(y.bin)||isFieldDef(x)&&x.aggregate&&!y.aggregate))return"horizontal";if(y2||x2){if(specifiedOrient)return specifiedOrient;if(!x2&&(isFieldDef(x)&&"quantitative"===x.type&&!isBinning(x.bin)||isNumericDataDef(x)))return"horizontal";if(!y2&&(isFieldDef(y)&&"quantitative"===y.type&&!isBinning(y.bin)||isNumericDataDef(y)))break}case RULE:if(!(!x2||isFieldDef(x)&&isBinned(x.bin)||!y2||isFieldDef(y)&&isBinned(y.bin)))return;case AREA:if(y2){if(isFieldDef(y)&&
isBinned(y.bin))return"horizontal";break}else if(x2)if(isFieldDef(x)&&isBinned(x.bin))break;else return"horizontal";else if(mark===RULE)if(x&&!y)break;else if(y&&!x)return"horizontal";case LINE:case TICK:encoding=isContinuousFieldOrDatumDef(x);var yIsContinuous=isContinuousFieldOrDatumDef(y);if(encoding&&!yIsContinuous)return"tick"!==mark?"horizontal":"vertical";if(!encoding&&yIsContinuous)return"tick"!==mark?"vertical":"horizontal";if(encoding&&yIsContinuous){encoding="temporal"===x.type;yIsContinuous=
"temporal"===y.type;if(encoding&&!yIsContinuous)return"tick"!==mark?"vertical":"horizontal";if(!encoding&&yIsContinuous)return"tick"!==mark?"horizontal":"vertical";if(!x.aggregate&&y.aggregate)return"tick"!==mark?"vertical":"horizontal";if(x.aggregate&&!y.aggregate)return"tick"!==mark?"horizontal":"vertical";if(specifiedOrient)return specifiedOrient}else{if(specifiedOrient)return specifiedOrient;return}}return"vertical"}function encodeEntry(model,fixedShape){return Object.assign({},baseEncodeEntry(model,
{align:"ignore",baseline:"ignore",color:"include",size:"include",orient:"ignore",theta:"ignore"}),pointPosition("x",model,{defaultPos:"mid"}),pointPosition("y",model,{defaultPos:"mid"}),nonPosition("size",model),nonPosition("angle",model),fixedShape?{shape:{value:fixedShape}}:nonPosition("shape",model))}function align$jscomp$0(markDef,encoding,config){if(void 0===getMarkPropOrConfig("align",markDef,config))return"center"}function baseline(markDef,encoding,config){if(void 0===getMarkPropOrConfig("baseline",
markDef,config))return"middle"}function defaultSize(model){var _getMarkPropOrConfig;const {config,markDef}=model;var {orient}=markDef;const vgSizeChannel="horizontal"===orient?"width":"height";model=model.getScaleComponent("horizontal"===orient?"x":"y");orient=null!==(_getMarkPropOrConfig=getMarkPropOrConfig("size",markDef,config,{vgChannel:vgSizeChannel}))&&void 0!==_getMarkPropOrConfig?_getMarkPropOrConfig:config.tick.bandSize;return void 0!==orient?orient:(_getMarkPropOrConfig=model?model.get("range"):
void 0)&&isVgRangeStep(_getMarkPropOrConfig)&&isNumber(_getMarkPropOrConfig.step)?3*_getMarkPropOrConfig.step/4:3*getViewConfigDiscreteStep(config.view,vgSizeChannel)/4}function parseMarkGroups(model){if(contains([LINE,AREA,TRAIL],model.mark)){var details=pathGroupingFields(model.mark,model.encoding);if(0<details.length)return getPathGroups(model,details)}else if(contains([BAR],model.mark)&&(details=VG_CORNERRADIUS_CHANNELS.some(prop=>getMarkPropOrConfig(prop,model.markDef,model.config)),model.stack&&
!model.fieldDef("size")&&details))return getGroupsForStackedBarWithCornerRadius(model);return getMarkGroup(model)}function getPathGroups(model,details){return[{name:model.getName("pathgroup"),type:"group",from:{facet:{name:"faceted_path_"+model.requestDataName(DataSourceType.Main),data:model.requestDataName(DataSourceType.Main),groupby:details}},encode:{update:{width:{field:{group:"width"}},height:{field:{group:"height"}}}},marks:getMarkGroup(model,{fromPrefix:"faceted_path_"})}]}function getGroupsForStackedBarWithCornerRadius(model){const [mark]=
getMarkGroup(model,{fromPrefix:"stack_group_"}),fieldScale=model.scaleName(model.stack.fieldChannel),stackField=opt=>{opt=void 0===opt?{}:opt;return model.vgField(model.stack.fieldChannel,opt)};var stackFieldGroup=(func,expr)=>{expr=[stackField({prefix:"min",suffix:"start",expr}),stackField({prefix:"max",suffix:"start",expr}),stackField({prefix:"min",suffix:"end",expr}),stackField({prefix:"max",suffix:"end",expr})];return"".concat(func,"(").concat(expr.map(field=>"scale('".concat(fieldScale,"',").concat(field,
")")).join(","),")")};let innerGroupUpdate;"x"===model.stack.fieldChannel?(stackFieldGroup=Object.assign({},pick(mark.encode.update,["y","yc","y2","height",...VG_CORNERRADIUS_CHANNELS]),{x:{signal:stackFieldGroup("min","datum")},x2:{signal:stackFieldGroup("max","datum")},clip:{value:!0}}),innerGroupUpdate={x:{field:{group:"x"},mult:-1},height:{field:{group:"height"}}},mark.encode.update=Object.assign({},omit(mark.encode.update,["y","yc","y2"]),{height:{field:{group:"height"}}})):(stackFieldGroup=
Object.assign({},pick(mark.encode.update,["x","xc","x2","width"]),{y:{signal:stackFieldGroup("min","datum")},y2:{signal:stackFieldGroup("max","datum")},clip:{value:!0}}),innerGroupUpdate={y:{field:{group:"y"},mult:-1},width:{field:{group:"width"}}},mark.encode.update=Object.assign({},omit(mark.encode.update,["x","xc","x2"]),{width:{field:{group:"width"}}}));for(var key of VG_CORNERRADIUS_CHANNELS){var configValue$jscomp$0=getMarkConfig(key,model.markDef,model.config);mark.encode.update[key]?(stackFieldGroup[key]=
mark.encode.update[key],delete mark.encode.update[key]):configValue$jscomp$0&&(stackFieldGroup[key]=signalOrValueRef(configValue$jscomp$0));configValue$jscomp$0&&(mark.encode.update[key]={value:0})}key=model.fieldDef(model.stack.groupbyChannel);configValue$jscomp$0=vgField(key)?[vgField(key)]:[];((null===key||void 0===key?0:key.bin)||(null===key||void 0===key?0:key.timeUnit))&&configValue$jscomp$0.push(vgField(key,{binSuffix:"end"}));stackFieldGroup="stroke strokeWidth strokeJoin strokeCap strokeDash strokeDashOffset strokeMiterLimit strokeOpacity".split(" ").reduce((encode,
prop)=>{if(mark.encode.update[prop])return Object.assign({},encode,{[prop]:mark.encode.update[prop]});{const configValue=getMarkConfig(prop,model.markDef,model.config);return void 0!==configValue?Object.assign({},encode,{[prop]:signalOrValueRef(configValue)}):encode}},stackFieldGroup);stackFieldGroup.stroke&&(stackFieldGroup.strokeForeground={value:!0},stackFieldGroup.strokeOffset={value:0});return[{type:"group",from:{facet:{data:model.requestDataName(DataSourceType.Main),name:"stack_group_"+model.requestDataName(DataSourceType.Main),
groupby:configValue$jscomp$0,aggregate:{fields:[stackField({suffix:"start"}),stackField({suffix:"start"}),stackField({suffix:"end"}),stackField({suffix:"end"})],ops:["min","max","min","max"]}}},encode:{update:stackFieldGroup},marks:[{type:"group",encode:{update:innerGroupUpdate},marks:[mark]}]}]}function getSort$1(model){const {encoding,stack,mark,markDef,config}=model;var order=encoding.order;if(!(!isArray(order)&&isValueDef(order)&&isNullOrFalse(order.value)||!order&&isNullOrFalse(getMarkPropOrConfig("order",
markDef,config)))){if((isArray(order)||isFieldDef(order))&&!stack)return sortParams(order,{expr:"datum"});if(isPathMark(mark)){const dimensionChannel="horizontal"===markDef.orient?"y":"x",dimensionChannelDef=encoding[dimensionChannel];if(isFieldDef(dimensionChannelDef)){order=dimensionChannelDef.sort;if(isArray(order))return{field:vgField(dimensionChannelDef,{prefix:dimensionChannel,suffix:"sort_index",expr:"datum"})};if(isSortField(order))return{field:vgField({aggregate:isAggregate(model.encoding)?
order.op:void 0,field:order.field},{expr:"datum"})};if(order&&order.encoding)return model=model.fieldDef(order.encoding),{field:vgField(model,{expr:"datum"}),order:order.order};if(null!==order)return{field:vgField(dimensionChannelDef,{binSuffix:model.stack&&model.stack.impute?"mid":void 0,expr:"datum"})}}}}}function getMarkGroup(model,opt){opt=void 0===opt?{fromPrefix:""}:opt;const {mark,markDef,encoding,config}=model;var JSCompiler_temp_const=markDef.clip;var JSCompiler_inline_result=model.getScaleComponent("x");
var yScale=model.getScaleComponent("y");JSCompiler_inline_result=JSCompiler_inline_result&&JSCompiler_inline_result.get("selectionExtent")||yScale&&yScale.get("selectionExtent")?!0:void 0;yScale=(yScale=model.component.projection)&&!yScale.isFit?!0:void 0;JSCompiler_temp_const=getFirstDefined(JSCompiler_temp_const,JSCompiler_inline_result,yScale);JSCompiler_inline_result=getStyles(markDef);yScale=encoding.key;const sort=getSort$1(model);var JSCompiler_inline_result$jscomp$0;if(model.component.selection){for(var parentCount=
JSCompiler_inline_result$jscomp$0=keys$jscomp$0(model.component.selection).length,parent=model.parent;parent&&0===parentCount;)parentCount=keys$jscomp$0(parent.component.selection).length,parent=parent.parent;JSCompiler_inline_result$jscomp$0=parentCount?{interactive:0<JSCompiler_inline_result$jscomp$0||!!model.encoding.tooltip}:null}else JSCompiler_inline_result$jscomp$0=null;parentCount=getMarkPropOrConfig("aria",markDef,config);parent=markCompiler[mark].postEncodingTransform?markCompiler[mark].postEncodingTransform(model):
null;return[Object.assign({},{name:model.getName("marks"),type:markCompiler[mark].vgMark},JSCompiler_temp_const?{clip:!0}:{},JSCompiler_inline_result?{style:JSCompiler_inline_result}:{},yScale?{key:yScale.field}:{},sort?{sort}:{},JSCompiler_inline_result$jscomp$0?JSCompiler_inline_result$jscomp$0:{},!1===parentCount?{aria:parentCount}:{},{from:{data:opt.fromPrefix+model.requestDataName(DataSourceType.Main)},encode:{update:markCompiler[mark].encodeEntry(model)}},parent?{transform:parent}:{})]}function buildModel(spec,
parent,parentGivenName,unitSize,config){if("facet"in spec)return new FacetModel(spec,parent,parentGivenName,config);if("layer"in spec)return new LayerModel(spec,parent,parentGivenName,unitSize,config);if(isUnitSpec(spec))return new UnitModel(spec,parent,parentGivenName,unitSize,config);if("vconcat"in spec||"hconcat"in spec||"concat"in spec)return new ConcatModel(spec,parent,parentGivenName,config);throw Error(invalidSpec(spec));}function assembleTopLevelModel(model,topLevelProperties,datasets,usermeta){datasets=
void 0===datasets?{}:datasets;const vgConfig=model.config?stripAndRedirectConfig(model.config):void 0;datasets=[].concat(model.assembleSelectionData([]),assembleRootData(model.component.data,datasets));const projections=model.assembleProjections(),title=model.assembleTitle(),style=model.assembleGroupStyle(),encodeEntry=model.assembleGroupEncodeEntry(!0);let layoutSignals=model.assembleLayoutSignals();layoutSignals=layoutSignals.filter(signal=>"width"!==signal.name&&"height"!==signal.name||void 0===
signal.value?!0:(topLevelProperties[signal.name]=+signal.value,!1));var $jscomp$destructuring$var207=Object.assign({},topLevelProperties);const params=topLevelProperties.params;$jscomp$destructuring$var207=(delete $jscomp$destructuring$var207.params,$jscomp$destructuring$var207);return Object.assign({},{$schema:"https://vega.github.io/schema/vega/v5.json"},model.description?{description:model.description}:{},$jscomp$destructuring$var207,title?{title}:{},style?{style}:{},encodeEntry?{encode:{update:encodeEntry}}:
{},{data:datasets},0<projections.length?{projections}:{},model.assembleGroup([...layoutSignals,...model.assembleSelectionTopLevelSignals([]),...assembleParameterSignals(params)]),vgConfig?{config:vgConfig}:{},usermeta?{usermeta}:{})}const get1=field=>function(obj){return obj[field]},getN=path=>{const len=path.length;return function(obj){for(let i=0;i<len;++i)obj=obj[path[i]];return obj}};(function(field,name,opt){const path=splitAccessPath(field);field=1===path.length?path[0]:field;return accessor$jscomp$0((opt&&
opt.get||getter)(path),[field],name||field)})("id");const identity=accessor$jscomp$0(_=>_,[],"identity");accessor$jscomp$0(()=>0,[],"zero");accessor$jscomp$0(()=>1,[],"one");accessor$jscomp$0(()=>!0,[],"true");accessor$jscomp$0(()=>!1,[],"false");var isArray=Array.isArray;const hop=Object.prototype.hasOwnProperty;Array.prototype.flat||Object.defineProperty(Array.prototype,"flat",{configurable:!0,value:function r(JSCompiler_OptimizeArgumentsArray_p4){var t=isNaN(JSCompiler_OptimizeArgumentsArray_p4)?
1:Number(JSCompiler_OptimizeArgumentsArray_p4);return t?Array.prototype.reduce.call(this,function(a,e){return Array.isArray(e)?a.push.apply(a,r.call(e,t-1)):a.push(e),a},[]):Array.prototype.slice.call(this)},writable:!0});Array.prototype.flatMap||Object.defineProperty(Array.prototype,"flatMap",{configurable:!0,value:function(r){return Array.prototype.map.apply(this,arguments).flat()},writable:!0});var fastJsonStableStringify=function(data,opts){opts||(opts={});"function"===typeof opts&&(opts={cmp:opts});
var cycles="boolean"===typeof opts.cycles?opts.cycles:!1,cmp=opts.cmp&&function(f){return function(node){return function(a,b){return f({key:a,value:node[a]},{key:b,value:node[b]})}}}(opts.cmp),seen=[];return function stringify(node){node&&node.toJSON&&"function"===typeof node.toJSON&&(node=node.toJSON());if(void 0!==node){if("number"==typeof node)return isFinite(node)?""+node:"null";if("object"!==typeof node)return JSON.stringify(node);var i;if(Array.isArray(node)){var out="[";for(i=0;i<node.length;i++)i&&
(out+=","),out+=stringify(node[i])||"null";return out+"]"}if(null===node)return"null";if(-1!==seen.indexOf(node)){if(cycles)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON");}var seenIndex=seen.push(node)-1,keys=Object.keys(node).sort(cmp&&cmp(node));out="";for(i=0;i<keys.length;i++){var key=keys[i],value=stringify(node[key]);value&&(out&&(out+=","),out+=JSON.stringify(key)+":"+value)}seen.splice(seenIndex,1);return"{"+out+"}"}}(data)};const deepEqual=
function equal(a,b){if(a===b)return!0;if(a&&b&&"object"==typeof a&&"object"==typeof b){if(a.constructor!==b.constructor)return!1;var i;if(Array.isArray(a)){var length=a.length;if(length!=b.length)return!1;for(i=length;0!==i--;)if(!equal(a[i],b[i]))return!1;return!0}if(a.constructor===RegExp)return a.source===b.source&&a.flags===b.flags;if(a.valueOf!==Object.prototype.valueOf)return a.valueOf()===b.valueOf();if(a.toString!==Object.prototype.toString)return a.toString()===b.toString();var keys=Object.keys(a);
length=keys.length;if(length!==Object.keys(b).length)return!1;for(i=length;0!==i--;)if(!Object.prototype.hasOwnProperty.call(b,keys[i]))return!1;for(i=length;0!==i--;)if(length=keys[i],!equal(a[length],b[length]))return!1;return!0}return a!==a&&b!==b},duplicate=function(fn,basedir,module){return module={path:basedir,exports:{},require:function(path,base){throw Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");}},fn(module,module.exports),module.exports}(function(module){var clone$jscomp$0=
function(){function _instanceof(obj,type){return null!=type&&obj instanceof type}function clone(parent$jscomp$0,circular,depth$jscomp$0,prototype,includeNonEnumerable){function _clone(parent,depth){if(null===parent)return null;if(0===depth||"object"!=typeof parent)return parent;if(_instanceof(parent,nativeMap))var child=new nativeMap;else if(_instanceof(parent,nativeSet))child=new nativeSet;else if(_instanceof(parent,nativePromise))child=new nativePromise(function(resolve,reject){parent.then(function(value){resolve(_clone(value,
depth-1))},function(err){reject(_clone(err,depth-1))})});else if(clone.__isArray(parent))child=[];else if(clone.__isRegExp(parent))child=new RegExp(parent.source,__getRegExpFlags(parent)),parent.lastIndex&&(child.lastIndex=parent.lastIndex);else if(clone.__isDate(parent))child=new Date(parent.getTime());else{if(useBuffer&&Buffer.isBuffer(parent))return child=Buffer.allocUnsafe?Buffer.allocUnsafe(parent.length):new Buffer(parent.length),parent.copy(child),child;if(_instanceof(parent,Error))child=Object.create(parent);
else if("undefined"==typeof prototype){var proto=Object.getPrototypeOf(parent);child=Object.create(proto)}else child=Object.create(prototype),proto=prototype}if(circular){var index=allParents.indexOf(parent);if(-1!=index)return allChildren[index];allParents.push(parent);allChildren.push(child)}_instanceof(parent,nativeMap)&&parent.forEach(function(value,key){key=_clone(key,depth-1);value=_clone(value,depth-1);child.set(key,value)});_instanceof(parent,nativeSet)&&parent.forEach(function(value){value=
_clone(value,depth-1);child.add(value)});for(var i in parent){var attrs;proto&&(attrs=Object.getOwnPropertyDescriptor(proto,i));attrs&&null==attrs.set||(child[i]=_clone(parent[i],depth-1))}if(Object.getOwnPropertySymbols)for(index=Object.getOwnPropertySymbols(parent),i=0;i<index.length;i++)if(attrs=index[i],proto=Object.getOwnPropertyDescriptor(parent,attrs),!proto||proto.enumerable||includeNonEnumerable)child[attrs]=_clone(parent[attrs],depth-1),proto.enumerable||Object.defineProperty(child,attrs,
{enumerable:!1});if(includeNonEnumerable)for(index=Object.getOwnPropertyNames(parent),i=0;i<index.length;i++)attrs=index[i],proto=Object.getOwnPropertyDescriptor(parent,attrs),proto&&proto.enumerable||(child[attrs]=_clone(parent[attrs],depth-1),Object.defineProperty(child,attrs,{enumerable:!1}));return child}"object"===typeof circular&&(depth$jscomp$0=circular.depth,prototype=circular.prototype,includeNonEnumerable=circular.includeNonEnumerable,circular=circular.circular);var allParents=[],allChildren=
[],useBuffer="undefined"!=typeof Buffer;"undefined"==typeof circular&&(circular=!0);"undefined"==typeof depth$jscomp$0&&(depth$jscomp$0=Infinity);return _clone(parent$jscomp$0,depth$jscomp$0)}function __objToStr(o){return Object.prototype.toString.call(o)}function __getRegExpFlags(re){var flags="";re.global&&(flags+="g");re.ignoreCase&&(flags+="i");re.multiline&&(flags+="m");return flags}try{var nativeMap=Map}catch(_){nativeMap=function(){}}try{var nativeSet=Set}catch(_){nativeSet=function(){}}try{var nativePromise=
Promise}catch(_){nativePromise=function(){}}clone.clonePrototype=function(parent){if(null===parent)return null;var c=function(){};c.prototype=parent;return new c};clone.__objToStr=__objToStr;clone.__isDate=function(o){return"object"===typeof o&&"[object Date]"===__objToStr(o)};clone.__isArray=function(o){return"object"===typeof o&&"[object Array]"===__objToStr(o)};clone.__isRegExp=function(o){return"object"===typeof o&&"[object RegExp]"===__objToStr(o)};clone.__getRegExpFlags=__getRegExpFlags;return clone}();
module.exports&&(module.exports=clone$jscomp$0)});Set.prototype.toJSON=function(){return"Set(".concat([...this].map(x=>fastJsonStableStringify(x)).join(","),")")};const stringify=fastJsonStableStringify,keys$jscomp$0=Object.keys,vals$jscomp$0=Object.values,entries=Object.entries;let idCounter=42;const CONDITIONAL_AXIS_PROP_INDEX={labelAlign:{part:"labels",vgProp:"align"},labelBaseline:{part:"labels",vgProp:"baseline"},labelColor:{part:"labels",vgProp:"fill"},labelFont:{part:"labels",vgProp:"font"},
labelFontSize:{part:"labels",vgProp:"fontSize"},labelFontStyle:{part:"labels",vgProp:"fontStyle"},labelFontWeight:{part:"labels",vgProp:"fontWeight"},labelOpacity:{part:"labels",vgProp:"opacity"},labelOffset:null,labelPadding:null,gridColor:{part:"grid",vgProp:"stroke"},gridDash:{part:"grid",vgProp:"strokeDash"},gridDashOffset:{part:"grid",vgProp:"strokeDashOffset"},gridOpacity:{part:"grid",vgProp:"opacity"},gridWidth:{part:"grid",vgProp:"strokeWidth"},tickColor:{part:"ticks",vgProp:"stroke"},tickDash:{part:"ticks",
vgProp:"strokeDash"},tickDashOffset:{part:"ticks",vgProp:"strokeDashOffset"},tickOpacity:{part:"ticks",vgProp:"opacity"},tickSize:null,tickWidth:{part:"ticks",vgProp:"strokeWidth"}},AXIS_PARTS=["domain","grid","labels","ticks","title"],AXIS_PROPERTY_TYPE={grid:"grid",gridCap:"grid",gridColor:"grid",gridDash:"grid",gridDashOffset:"grid",gridOpacity:"grid",gridScale:"grid",gridWidth:"grid",orient:"main",bandPosition:"both",aria:"main",description:"main",domain:"main",domainCap:"main",domainColor:"main",
domainDash:"main",domainDashOffset:"main",domainOpacity:"main",domainWidth:"main",format:"main",formatType:"main",labelAlign:"main",labelAngle:"main",labelBaseline:"main",labelBound:"main",labelColor:"main",labelFlush:"main",labelFlushOffset:"main",labelFont:"main",labelFontSize:"main",labelFontStyle:"main",labelFontWeight:"main",labelLimit:"main",labelLineHeight:"main",labelOffset:"main",labelOpacity:"main",labelOverlap:"main",labelPadding:"main",labels:"main",labelSeparation:"main",maxExtent:"main",
minExtent:"main",offset:"both",position:"main",tickCap:"main",tickColor:"main",tickDash:"main",tickDashOffset:"main",tickMinStep:"main",tickOffset:"both",tickOpacity:"main",tickRound:"both",ticks:"main",tickSize:"main",tickWidth:"both",title:"main",titleAlign:"main",titleAnchor:"main",titleAngle:"main",titleBaseline:"main",titleColor:"main",titleFont:"main",titleFontSize:"main",titleFontStyle:"main",titleFontWeight:"main",titleLimit:"main",titleLineHeight:"main",titleOpacity:"main",titlePadding:"main",
titleX:"main",titleY:"main",encode:"both",scale:"both",tickBand:"both",tickCount:"both",tickExtra:"both",translate:"both",values:"both",zindex:"both"},COMMON_AXIS_PROPERTIES_INDEX={orient:1,aria:1,bandPosition:1,description:1,domain:1,domainCap:1,domainColor:1,domainDash:1,domainDashOffset:1,domainOpacity:1,domainWidth:1,format:1,formatType:1,grid:1,gridCap:1,gridColor:1,gridDash:1,gridDashOffset:1,gridOpacity:1,gridWidth:1,labelAlign:1,labelAngle:1,labelBaseline:1,labelBound:1,labelColor:1,labelFlush:1,
labelFlushOffset:1,labelFont:1,labelFontSize:1,labelFontStyle:1,labelFontWeight:1,labelLimit:1,labelLineHeight:1,labelOffset:1,labelOpacity:1,labelOverlap:1,labelPadding:1,labels:1,labelSeparation:1,maxExtent:1,minExtent:1,offset:1,position:1,tickBand:1,tickCap:1,tickColor:1,tickCount:1,tickDash:1,tickDashOffset:1,tickExtra:1,tickMinStep:1,tickOffset:1,tickOpacity:1,tickRound:1,ticks:1,tickSize:1,tickWidth:1,title:1,titleAlign:1,titleAnchor:1,titleAngle:1,titleBaseline:1,titleColor:1,titleFont:1,
titleFontSize:1,titleFontStyle:1,titleFontWeight:1,titleLimit:1,titleLineHeight:1,titleOpacity:1,titlePadding:1,titleX:1,titleY:1,translate:1,values:1,zindex:1},AXIS_PROPERTIES_INDEX=Object.assign({},COMMON_AXIS_PROPERTIES_INDEX,{style:1,labelExpr:1,encoding:1}),AXIS_CONFIGS=keys$jscomp$0({axis:1,axisBand:1,axisBottom:1,axisDiscrete:1,axisLeft:1,axisPoint:1,axisQuantitative:1,axisRight:1,axisTemporal:1,axisTop:1,axisX:1,axisXBand:1,axisXDiscrete:1,axisXPoint:1,axisXQuantitative:1,axisXTemporal:1,
axisY:1,axisYBand:1,axisYDiscrete:1,axisYPoint:1,axisYQuantitative:1,axisYTemporal:1}),AGGREGATE_OP_INDEX={argmax:1,argmin:1,average:1,count:1,distinct:1,product:1,max:1,mean:1,median:1,min:1,missing:1,q1:1,q3:1,ci0:1,ci1:1,stderr:1,stdev:1,stdevp:1,sum:1,valid:1,values:1,variance:1,variancep:1},MULTIDOMAIN_SORT_OP_INDEX={count:1,min:1,max:1},COUNTING_OPS=["count","valid","missing","distinct"],SUM_OPS=["count","sum","distinct","valid","missing"],SHARED_DOMAIN_OP_INDEX=toSet("mean average median q1 q3 min max".split(" ")),
POLAR_POSITION_CHANNEL_INDEX={theta:1,theta2:1,radius:1,radius2:1},GEO_POSIITON_CHANNEL_INDEX={longitude:1,longitude2:1,latitude:1,latitude2:1},GEOPOSITION_CHANNELS=keys$jscomp$0(GEO_POSIITON_CHANNEL_INDEX),UNIT_CHANNEL_INDEX=Object.assign({},{x:1,y:1,x2:1,y2:1},POLAR_POSITION_CHANNEL_INDEX,GEO_POSIITON_CHANNEL_INDEX,{color:1,fill:1,stroke:1,opacity:1,fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeDash:1,size:1,angle:1,shape:1,order:1,text:1,detail:1,key:1,tooltip:1,href:1,url:1,description:1}),
FACET_CHANNEL_INDEX={row:1,column:1,facet:1},FACET_CHANNELS=keys$jscomp$0(FACET_CHANNEL_INDEX),CHANNEL_INDEX=Object.assign({},UNIT_CHANNEL_INDEX,FACET_CHANNEL_INDEX),CHANNELS=keys$jscomp$0(CHANNEL_INDEX);var $jscomp$destructuring$var3=Object.assign({},CHANNEL_INDEX),$jscomp$destructuring$var4=(delete $jscomp$destructuring$var3.order,delete $jscomp$destructuring$var3.detail,delete $jscomp$destructuring$var3.tooltip,$jscomp$destructuring$var3),$jscomp$destructuring$var5=Object.assign({},$jscomp$destructuring$var4);
const SINGLE_DEF_UNIT_CHANNEL_INDEX=(delete $jscomp$destructuring$var5.row,delete $jscomp$destructuring$var5.column,delete $jscomp$destructuring$var5.facet,$jscomp$destructuring$var5),SECONDARY_RANGE_CHANNEL="x2 y2 latitude2 longitude2 theta2 radius2".split(" ");var $jscomp$destructuring$var7=Object.assign({},UNIT_CHANNEL_INDEX);const NONPOSITION_CHANNEL_INDEX=(delete $jscomp$destructuring$var7.x,delete $jscomp$destructuring$var7.y,delete $jscomp$destructuring$var7.x2,delete $jscomp$destructuring$var7.y2,
delete $jscomp$destructuring$var7.latitude,delete $jscomp$destructuring$var7.longitude,delete $jscomp$destructuring$var7.latitude2,delete $jscomp$destructuring$var7.longitude2,delete $jscomp$destructuring$var7.theta,delete $jscomp$destructuring$var7.theta2,delete $jscomp$destructuring$var7.radius,delete $jscomp$destructuring$var7.radius2,$jscomp$destructuring$var7),NONPOSITION_CHANNELS=keys$jscomp$0(NONPOSITION_CHANNEL_INDEX),POSITION_SCALE_CHANNEL_INDEX={x:1,y:1},POSITION_SCALE_CHANNELS=keys$jscomp$0(POSITION_SCALE_CHANNEL_INDEX),
POLAR_POSITION_SCALE_CHANNEL_INDEX={theta:1,radius:1},POLAR_POSITION_SCALE_CHANNELS=keys$jscomp$0(POLAR_POSITION_SCALE_CHANNEL_INDEX);var $jscomp$destructuring$var9=Object.assign({},NONPOSITION_CHANNEL_INDEX);const NONPOSITION_SCALE_CHANNEL_INDEX=(delete $jscomp$destructuring$var9.text,delete $jscomp$destructuring$var9.tooltip,delete $jscomp$destructuring$var9.href,delete $jscomp$destructuring$var9.url,delete $jscomp$destructuring$var9.description,delete $jscomp$destructuring$var9.detail,delete $jscomp$destructuring$var9.key,
delete $jscomp$destructuring$var9.order,$jscomp$destructuring$var9),NONPOSITION_SCALE_CHANNELS=keys$jscomp$0(NONPOSITION_SCALE_CHANNEL_INDEX),SCALE_CHANNEL_INDEX=Object.assign({},POSITION_SCALE_CHANNEL_INDEX,POLAR_POSITION_SCALE_CHANNEL_INDEX,NONPOSITION_SCALE_CHANNEL_INDEX),SCALE_CHANNELS=keys$jscomp$0(SCALE_CHANNEL_INDEX),ALL_MARKS={arc:"always",area:"always",bar:"always",circle:"always",geoshape:"always",image:"always",line:"always",rule:"always",point:"always",rect:"always",square:"always",trail:"always",
text:"always",tick:"always"};var $jscomp$destructuring$var11=Object.assign({},ALL_MARKS);const ALL_MARKS_EXCEPT_GEOSHAPE=(delete $jscomp$destructuring$var11.geoshape,$jscomp$destructuring$var11),main$jscomp$0=function(_$jscomp$0,method){let level=_$jscomp$0||0;return{level(_){return arguments.length?(level=+_,this):level},error(){1<=level&&log(method||"error","ERROR",arguments);return this},warn(){2<=level&&log(method||"warn","WARN",arguments);return this},info(){3<=level&&log(method||"log","INFO",
arguments);return this},debug(){4<=level&&log(method||"log","DEBUG",arguments);return this}}}(2);let current=main$jscomp$0;const MONTHS="january february march april may june july august september october november december".split(" "),SHORT_MONTHS=MONTHS.map(m=>m.substr(0,3)),DAYS="sunday monday tuesday wednesday thursday friday saturday".split(" "),SHORT_DAYS=DAYS.map(d=>d.substr(0,3)),LOCAL_SINGLE_TIMEUNIT_INDEX={year:1,quarter:1,month:1,week:1,day:1,dayofyear:1,date:1,hours:1,minutes:1,seconds:1,
milliseconds:1},TIMEUNIT_PARTS=keys$jscomp$0(LOCAL_SINGLE_TIMEUNIT_INDEX),VEGALITE_TIMEFORMAT={"year-month":"%b %Y ","year-month-date":"%b %d, %Y "},VG_MARK_CONFIGS=keys$jscomp$0({aria:1,description:1,ariaRole:1,ariaRoleDescription:1,blend:1,opacity:1,fill:1,fillOpacity:1,stroke:1,strokeCap:1,strokeWidth:1,strokeOpacity:1,strokeDash:1,strokeDashOffset:1,strokeJoin:1,strokeOffset:1,strokeMiterLimit:1,startAngle:1,endAngle:1,padAngle:1,innerRadius:1,outerRadius:1,size:1,shape:1,interpolate:1,tension:1,
orient:1,align:1,baseline:1,text:1,dir:1,dx:1,dy:1,ellipsis:1,limit:1,radius:1,theta:1,angle:1,font:1,fontSize:1,fontWeight:1,fontStyle:1,lineBreak:1,lineHeight:1,cursor:1,href:1,tooltip:1,cornerRadius:1,cornerRadiusTopLeft:1,cornerRadiusTopRight:1,cornerRadiusBottomLeft:1,cornerRadiusBottomRight:1,aspect:1,width:1,height:1,url:1,smooth:1}),VG_MARK_INDEX={arc:1,area:1,group:1,image:1,line:1,path:1,rect:1,rule:1,shape:1,symbol:1,text:1,trail:1},VG_CORNERRADIUS_CHANNELS=["cornerRadius","cornerRadiusTopLeft",
"cornerRadiusTopRight","cornerRadiusBottomLeft","cornerRadiusBottomRight"],ScaleType={LINEAR:"linear",LOG:"log",POW:"pow",SQRT:"sqrt",SYMLOG:"symlog",IDENTITY:"identity",SEQUENTIAL:"sequential",TIME:"time",UTC:"utc",QUANTILE:"quantile",QUANTIZE:"quantize",THRESHOLD:"threshold",BIN_ORDINAL:"bin-ordinal",ORDINAL:"ordinal",POINT:"point",BAND:"band"},SCALE_CATEGORY_INDEX={linear:"numeric",log:"numeric",pow:"numeric",sqrt:"numeric",symlog:"numeric",identity:"numeric",sequential:"numeric",time:"time",utc:"time",
ordinal:"ordinal","bin-ordinal":"bin-ordinal",point:"ordinal-position",band:"ordinal-position",quantile:"discretizing",quantize:"discretizing",threshold:"discretizing"},SCALE_PRECEDENCE_INDEX={linear:0,log:1,pow:1,sqrt:1,symlog:1,identity:1,sequential:1,time:0,utc:0,point:10,band:11,ordinal:0,"bin-ordinal":0,quantile:0,quantize:0,threshold:0},CONTINUOUS_TO_CONTINUOUS_SCALES="linear log pow sqrt symlog time utc".split(" "),CONTINUOUS_TO_CONTINUOUS_INDEX=toSet(CONTINUOUS_TO_CONTINUOUS_SCALES),QUANTITATIVE_SCALES_INDEX=
toSet(["linear","log","pow","sqrt","symlog"]),CONTINUOUS_TO_DISCRETE_INDEX=toSet(["quantile","quantize","threshold"]),CONTINUOUS_DOMAIN_SCALES=CONTINUOUS_TO_CONTINUOUS_SCALES.concat(["quantile","quantize","threshold","sequential","identity"]),CONTINUOUS_DOMAIN_INDEX=toSet(CONTINUOUS_DOMAIN_SCALES),DISCRETE_DOMAIN_INDEX=toSet(["ordinal","bin-ordinal","point","band"]);var $jscomp$destructuring$var16=Object.assign({},{type:1,domain:1,domainMax:1,domainMin:1,domainMid:1,align:1,range:1,rangeMax:1,rangeMin:1,
scheme:1,bins:1,reverse:1,round:1,clamp:1,nice:1,base:1,exponent:1,constant:1,interpolate:1,zero:1,padding:1,paddingInner:1,paddingOuter:1});const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX=(delete $jscomp$destructuring$var16.type,delete $jscomp$destructuring$var16.domain,delete $jscomp$destructuring$var16.range,delete $jscomp$destructuring$var16.rangeMax,delete $jscomp$destructuring$var16.rangeMin,delete $jscomp$destructuring$var16.scheme,$jscomp$destructuring$var16),NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES=
keys$jscomp$0(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX),Mark={arc:"arc",area:"area",bar:"bar",image:"image",line:"line",point:"point",rect:"rect",rule:"rule",text:"text",tick:"tick",trail:"trail",circle:"circle",square:"square",geoshape:"geoshape"},ARC=Mark.arc,AREA=Mark.area,BAR=Mark.bar,IMAGE=Mark.image,LINE=Mark.line,POINT=Mark.point,RECT=Mark.rect,RULE=Mark.rule,TEXT$1=Mark.text,TICK=Mark.tick,TRAIL=Mark.trail,CIRCLE=Mark.circle,SQUARE=Mark.square,GEOSHAPE=Mark.geoshape,PRIMITIVE_MARKS=
keys$jscomp$0(Mark);toSet(PRIMITIVE_MARKS);const FILL_STROKE_CONFIG="stroke strokeWidth strokeDash strokeDashOffset strokeOpacity strokeJoin strokeMiterLimit fill fillOpacity".split(" "),VL_ONLY_MARK_CONFIG_PROPERTIES=keys$jscomp$0({color:1,filled:1,invalid:1,order:1,radius2:1,theta2:1,timeUnitBand:1,timeUnitBandPosition:1}),MARK_CONFIGS=keys$jscomp$0({mark:1,arc:1,area:1,bar:1,circle:1,image:1,line:1,point:1,rect:1,rule:1,square:1,text:1,tick:1,trail:1,geoshape:1}),BAR_CORNER_RADIUS_INDEX={horizontal:["cornerRadiusTopRight",
"cornerRadiusBottomRight"],vertical:["cornerRadiusTopLeft","cornerRadiusTopRight"]},SORT_BY_CHANNEL_INDEX={x:1,y:1,color:1,fill:1,stroke:1,strokeWidth:1,size:1,shape:1,fillOpacity:1,strokeOpacity:1,opacity:1,text:1},defaultTitleFormatter=(fieldDef,config)=>{switch(config.fieldTitle){case "plain":return fieldDef.field;case "functional":{const {aggregate,bin,timeUnit,field}=fieldDef;isArgmaxDef(aggregate)?fieldDef="".concat(field," for argmax(").concat(aggregate.argmax,")"):isArgminDef(aggregate)?fieldDef=
"".concat(field," for argmin(").concat(aggregate.argmin,")"):(fieldDef=normalizeTimeUnit(timeUnit),fieldDef=(fieldDef=aggregate||(null===fieldDef||void 0===fieldDef?void 0:fieldDef.unit)||(null===fieldDef||void 0===fieldDef?void 0:fieldDef.maxbins)&&"timeunit"||isBinning(bin)&&"bin")?fieldDef.toUpperCase()+"("+field+")":field)}return fieldDef;default:return verbalTitleFormatter(fieldDef,config)}};let titleFormatter=defaultTitleFormatter;const COMPATIBLE={compatible:!0};class CompositeMarkNormalizer{constructor(name,
run){this.name=name;this.run=run}hasMatchingType(spec){return isUnitSpec(spec)?(spec=spec.mark,(isMarkDef(spec)?spec.type:spec)===this.name):!1}}const boxPlotNormalizer=new CompositeMarkNormalizer("boxplot",normalizeBoxPlot),errorBarNormalizer=new CompositeMarkNormalizer("errorbar",normalizeErrorBar),errorBandNormalizer=new CompositeMarkNormalizer("errorband",normalizeErrorBand),compositeMarkRegistry={};add$jscomp$0("boxplot",normalizeBoxPlot,["box","median","outliers","rule","ticks"]);add$jscomp$0("errorbar",
normalizeErrorBar,["ticks","rule"]);add$jscomp$0("errorband",normalizeErrorBand,["band","borders"]);const VL_ONLY_LEGEND_CONFIG=["gradientHorizontalMaxLength","gradientHorizontalMinLength","gradientVerticalMaxLength","gradientVerticalMinLength","unselectedOpacity"],HEADER_TITLE_PROPERTIES_MAP={titleAlign:"align",titleAnchor:"anchor",titleAngle:"angle",titleBaseline:"baseline",titleColor:"color",titleFont:"font",titleFontSize:"fontSize",titleFontStyle:"fontStyle",titleFontWeight:"fontWeight",titleLimit:"limit",
titleLineHeight:"lineHeight",titleOrient:"orient",titlePadding:"offset"},HEADER_LABEL_PROPERTIES_MAP={labelAlign:"align",labelAnchor:"anchor",labelAngle:"angle",labelBaseline:"baseline",labelColor:"color",labelFont:"font",labelFontSize:"fontSize",labelFontStyle:"fontStyle",labelFontWeight:"fontWeight",labelLimit:"limit",labelLineHeight:"lineHeight",labelOrient:"orient",labelPadding:"offset"},HEADER_TITLE_PROPERTIES=keys$jscomp$0(HEADER_TITLE_PROPERTIES_MAP),HEADER_LABEL_PROPERTIES=keys$jscomp$0(HEADER_LABEL_PROPERTIES_MAP),
HEADER_CONFIGS=keys$jscomp$0({header:1,headerRow:1,headerColumn:1,headerFacet:1}),LEGEND_SCALE_CHANNELS="size shape fill stroke strokeDash strokeWidth opacity".split(" "),TOP_LEVEL_PROPERTIES=["background","padding"],COMPOSITION_LAYOUT_PROPERTIES=keys$jscomp$0({align:1,bounds:1,center:1,columns:1,spacing:1}),defaultConfig$1={background:"white",padding:5,timeFormat:"%b %d, %Y",countTitle:"Count of Records",view:{continuousWidth:200,continuousHeight:200,step:20},mark:{color:"#4c78a8",invalid:"filter",
timeUnitBand:1},arc:{},area:{},bar:{binSpacing:1,continuousBandSize:5,timeUnitBandPosition:.5},circle:{},geoshape:{},image:{},line:{},point:{},rect:{binSpacing:0,continuousBandSize:5,timeUnitBandPosition:.5},rule:{color:"black"},square:{},text:{color:"black"},tick:{thickness:1},trail:{},boxplot:{size:14,extent:1.5,box:{},median:{color:"white"},outliers:{},rule:{},ticks:null},errorbar:{center:"mean",rule:!0,ticks:!1},errorband:{band:{opacity:.3},borders:!1},scale:{pointPadding:.5,barBandPaddingInner:.1,
rectBandPaddingInner:0,minBandSize:2,minFontSize:8,maxFontSize:40,minOpacity:.3,maxOpacity:.8,minSize:9,minStrokeWidth:1,maxStrokeWidth:4,quantileCount:4,quantizeCount:4},projection:{},legend:{gradientHorizontalMaxLength:200,gradientHorizontalMinLength:100,gradientVerticalMaxLength:200,gradientVerticalMinLength:64,unselectedOpacity:.35},header:{titlePadding:10,labelPadding:10},headerColumn:{},headerRow:{},headerFacet:{},selection:{single:{on:"click",fields:["_vgsid_"],resolve:"global",empty:"all",
clear:"dblclick"},multi:{on:"click",fields:["_vgsid_"],toggle:"event.shiftKey",resolve:"global",empty:"all",clear:"dblclick"},interval:{on:"[mousedown, window:mouseup] \x3e window:mousemove!",encodings:["x","y"],translate:"[mousedown, window:mouseup] \x3e window:mousemove!",zoom:"wheel!",mark:{fill:"#333",fillOpacity:.125,stroke:"white"},resolve:"global",clear:"dblclick"}},style:{},title:{},facet:{spacing:20},concat:{spacing:20}},tab10="#4c78a8 #f58518 #e45756 #72b7b2 #54a24b #eeca3b #b279a2 #ff9da6 #9d755d #bab0ac".split(" "),
DEFAULT_FONT_SIZE={text:11,guideLabel:10,guideTitle:11,groupTitle:13,groupSubtitle:12},DEFAULT_COLOR={blue:tab10[0],orange:tab10[1],red:tab10[2],teal:tab10[3],green:tab10[4],yellow:tab10[5],purple:tab10[6],pink:tab10[7],brown:tab10[8],gray0:"#000",gray1:"#111",gray2:"#222",gray3:"#333",gray4:"#444",gray5:"#555",gray6:"#666",gray7:"#777",gray8:"#888",gray9:"#999",gray10:"#aaa",gray11:"#bbb",gray12:"#ccc",gray13:"#ddd",gray14:"#eee",gray15:"#fff"},configPropsWithExpr=[...MARK_CONFIGS,...AXIS_CONFIGS,
...HEADER_CONFIGS,"background","padding","legend","lineBreak","scale","style","title","view"],MARK_STYLES=["view",...PRIMITIVE_MARKS],VL_ONLY_CONFIG_PROPERTIES="color fontSize background padding facet concat numberFormat timeFormat countTitle header axisQuantitative axisTemporal axisDiscrete axisPoint axisXBand axisXPoint axisXDiscrete axisXQuantitative axisXTemporal axisYBand axisYPoint axisYDiscrete axisYQuantitative axisYTemporal scale selection overlay".split(" "),VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX=
Object.assign({},{view:["continuousWidth","continuousHeight","discreteWidth","discreteHeight","step"]},{area:["line","point"],bar:["binSpacing","continuousBandSize","discreteBandSize"],rect:["binSpacing","continuousBandSize","discreteBandSize"],line:["point"],tick:["bandSize","thickness"]});class SpecMapper{map(spec,params){return"facet"in spec?this.mapFacet(spec,params):"repeat"in spec?this.mapRepeat(spec,params):"hconcat"in spec?this.mapHConcat(spec,params):"vconcat"in spec?this.mapVConcat(spec,
params):"concat"in spec?this.mapConcat(spec,params):this.mapLayerOrUnit(spec,params)}mapLayerOrUnit(spec,params){if("layer"in spec)return this.mapLayer(spec,params);if(isUnitSpec(spec))return this.mapUnit(spec,params);throw Error(invalidSpec(spec));}mapLayer(spec,params){return Object.assign({},spec,{layer:spec.layer.map(subspec=>this.mapLayerOrUnit(subspec,params))})}mapHConcat(spec,params){return Object.assign({},spec,{hconcat:spec.hconcat.map(subspec=>this.map(subspec,params))})}mapVConcat(spec,
params){return Object.assign({},spec,{vconcat:spec.vconcat.map(subspec=>this.map(subspec,params))})}mapConcat(spec,params){var $jscomp$destructuring$var74=Object.assign({},spec);spec=spec.concat;$jscomp$destructuring$var74=(delete $jscomp$destructuring$var74.concat,$jscomp$destructuring$var74);return Object.assign({},$jscomp$destructuring$var74,{concat:spec.map(subspec=>this.map(subspec,params))})}mapFacet(spec,params){return Object.assign({},spec,{spec:this.map(spec.spec,params)})}mapRepeat(spec,
params){return Object.assign({},spec,{spec:this.map(spec.spec,params)})}}const STACK_OFFSET_INDEX={zero:1,center:1,normalize:1},STACKABLE_MARKS=new Set([ARC,BAR,AREA,RULE,POINT,CIRCLE,SQUARE,LINE,TEXT$1,TICK]),STACK_BY_DEFAULT_MARKS=new Set([BAR,AREA,ARC]);class PathOverlayNormalizer{constructor(){_defineProperty(this,"name","path-overlay")}hasMatchingType(spec,config){if(isUnitSpec(spec)){const {mark,encoding}=spec;spec=isMarkDef(mark)?mark:{type:mark};switch(spec.type){case "line":case "rule":case "trail":return!!getPointOverlay(spec,
config[spec.type],encoding);case "area":return!!getPointOverlay(spec,config[spec.type],encoding)||!!getLineOverlay(spec,config[spec.type])}}return!1}run(spec,params,normalize){const {config}=params;var $jscomp$destructuring$var78=Object.assign({},spec),selection=spec.selection;const projection=spec.projection;var mark=spec.mark;spec=spec.encoding;$jscomp$destructuring$var78=(delete $jscomp$destructuring$var78.selection,delete $jscomp$destructuring$var78.projection,delete $jscomp$destructuring$var78.mark,
delete $jscomp$destructuring$var78.encoding,$jscomp$destructuring$var78);spec=normalizeEncoding(spec,config);mark=isMarkDef(mark)?mark:{type:mark};const pointOverlay=getPointOverlay(mark,config[mark.type],spec),lineOverlay="area"===mark.type&&getLineOverlay(mark,config[mark.type]);selection=[Object.assign({},selection?{selection}:{},{mark:dropLineAndPoint(Object.assign({},"area"===mark.type&&void 0===mark.opacity&&void 0===mark.fillOpacity?{opacity:.7}:{},mark)),encoding:omit(spec,["shape"])})];const stackProps=
stack$jscomp$1(mark,spec);let overlayEncoding=spec;if(stackProps){const {fieldChannel:stackFieldChannel,offset}=stackProps;overlayEncoding=Object.assign({},spec,{[stackFieldChannel]:Object.assign({},spec[stackFieldChannel],offset?{stack:offset}:{})})}lineOverlay&&selection.push(Object.assign({},projection?{projection}:{},{mark:Object.assign({},{type:"line"},pick(mark,["clip","interpolate","tension","tooltip"]),lineOverlay),encoding:overlayEncoding}));pointOverlay&&selection.push(Object.assign({},
projection?{projection}:{},{mark:Object.assign({},{type:"point",opacity:1,filled:!0},pick(mark,["clip","tooltip"]),pointOverlay),encoding:overlayEncoding}));return normalize(Object.assign({},$jscomp$destructuring$var78,{layer:selection}),Object.assign({},params,{config:dropLineAndPointFromConfig(config)}))}}class RangeStepNormalizer{constructor(){_defineProperty(this,"name","RangeStep")}hasMatchingType(spec){if(isUnitSpec(spec)&&spec.encoding)for(const channel of POSITION_SCALE_CHANNELS){const def=
spec.encoding[channel];if(def&&isFieldOrDatumDef(def)){var _def$scale;if(null===def||void 0===def?0:null===(_def$scale=def.scale)||void 0===_def$scale?0:_def$scale.rangeStep)return!0}}return!1}run(spec){const sizeMixins={};let encoding=Object.assign({},spec.encoding);for(const channel of POSITION_SCALE_CHANNELS){const sizeType=getSizeChannel(channel);var def=encoding[channel];if(def&&isFieldOrDatumDef(def)){var _def$scale2;if(null===def||void 0===def?0:null===(_def$scale2=def.scale)||void 0===_def$scale2?
0:_def$scale2.rangeStep){var $jscomp$destructuring$var80=Object.assign({},def);def=def.scale;$jscomp$destructuring$var80=(delete $jscomp$destructuring$var80.scale,$jscomp$destructuring$var80);var $jscomp$destructuring$var82=Object.assign({},def);$jscomp$destructuring$var82=(delete $jscomp$destructuring$var82.rangeStep,$jscomp$destructuring$var82);sizeMixins[sizeType]={step:def.rangeStep};warn('Scale\'s "rangeStep" is deprecated and will be removed in Vega-Lite 5.0. Please use "width"/"height": {"step": ...} instead. See https://vega.github.io/vega-lite/docs/size.html.');
encoding=Object.assign({},encoding,{[channel]:Object.assign({},$jscomp$destructuring$var80,isEmpty($jscomp$destructuring$var82)?{}:{scale:$jscomp$destructuring$var82})})}}}return Object.assign({},sizeMixins,spec,{encoding})}}class RuleForRangedLineNormalizer{constructor(){_defineProperty(this,"name","RuleForRangedLine")}hasMatchingType(spec){if(isUnitSpec(spec)){const {encoding,mark}=spec;if("line"===mark)for(const channel of SECONDARY_RANGE_CHANNEL)if(spec=getMainRangeChannel(channel),spec=encoding[spec],
encoding[channel]&&(isFieldDef(spec)&&!isBinned(spec.bin)||isDatumDef(spec)))return!0}return!1}run(spec,params,normalize){var {encoding}=spec,hasX2=!!encoding.x2;encoding="Line mark is for continuous lines and thus cannot be used with ".concat(hasX2&&encoding.y2?"x2 and y2":hasX2?"x2":"y2",". We will use the rule mark (line segments) instead.");warn(encoding);return normalize(Object.assign({},spec,{mark:"rule"}),params)}}class CoreNormalizer extends SpecMapper{constructor(...args){super(...args);
_defineProperty(this,"nonFacetUnitNormalizers",[boxPlotNormalizer,errorBarNormalizer,errorBandNormalizer,new PathOverlayNormalizer,new RuleForRangedLineNormalizer,new RangeStepNormalizer])}map(spec,params){if(isUnitSpec(spec)){const hasRow=channelHasField(spec.encoding,"row"),hasColumn=channelHasField(spec.encoding,"column"),hasFacet=channelHasField(spec.encoding,"facet");if(hasRow||hasColumn||hasFacet)return this.mapFacetedUnit(spec,params)}return super.map(spec,params)}mapUnit(spec,params){const {parentEncoding,
parentProjection}=params;var encoding=replaceRepeaterInEncoding(spec.encoding,params.repeater);spec=Object.assign({},spec,encoding?{encoding}:{});if(parentEncoding||parentProjection)return this.mapUnitWithParentEncodingOrProjection(spec,params);encoding=this.mapLayerOrUnit.bind(this);for(const unitNormalizer of this.nonFacetUnitNormalizers)if(unitNormalizer.hasMatchingType(spec,params.config))return unitNormalizer.run(spec,params,encoding);return spec}mapRepeat(spec,params){return!isArray(spec.repeat)&&
spec.repeat.layer?this.mapLayerRepeat(spec,params):this.mapNonLayerRepeat(spec,params)}mapLayerRepeat(spec,params){var $jscomp$destructuring$var86=Object.assign({},spec);const repeat=spec.repeat,childSpec=spec.spec;$jscomp$destructuring$var86=(delete $jscomp$destructuring$var86.repeat,delete $jscomp$destructuring$var86.spec,$jscomp$destructuring$var86);const {row,column,layer}=repeat,{repeater={},repeaterPrefix=""}=params;return row||column?this.mapRepeat(Object.assign({},spec,{repeat:Object.assign({},
row?{row}:{},column?{column}:{}),spec:{repeat:{layer},spec:childSpec}}),params):Object.assign({},$jscomp$destructuring$var86,{layer:layer.map(layerValue=>{var childRepeater=Object.assign({},repeater,{layer:layerValue});layerValue=(childSpec.name||"")+repeaterPrefix+"child__layer_".concat(varName(layerValue));childRepeater=this.mapLayerOrUnit(childSpec,Object.assign({},params,{repeater:childRepeater,repeaterPrefix:layerValue}));childRepeater.name=layerValue;return childRepeater})})}mapNonLayerRepeat(spec,
params){var _childSpec$data,$jscomp$destructuring$var87=spec,$jscomp$destructuring$var88=Object.assign({},$jscomp$destructuring$var87);const repeat=$jscomp$destructuring$var87.repeat,childSpec=$jscomp$destructuring$var87.spec;$jscomp$destructuring$var87=$jscomp$destructuring$var87.data;$jscomp$destructuring$var88=(delete $jscomp$destructuring$var88.repeat,delete $jscomp$destructuring$var88.spec,delete $jscomp$destructuring$var88.data,$jscomp$destructuring$var88);!isArray(repeat)&&spec.columns&&(spec=
omit(spec,["columns"]),warn(columnsNotSupportByRowCol("repeat")));const concat=[],{repeater={},repeaterPrefix=""}=params,row=!isArray(repeat)&&repeat.row||[repeater?repeater.row:null],column=!isArray(repeat)&&repeat.column||[repeater?repeater.column:null];var repeatValues=isArray(repeat)&&repeat||[repeater?repeater.repeat:null];for(const repeatValue of repeatValues)for(const rowValue of row)for(const columnValue of column){var childRepeater={repeat:repeatValue,row:rowValue,column:columnValue,layer:repeater.layer};
repeatValues=(childSpec.name||"")+repeaterPrefix+"child__"+(isArray(repeat)?"".concat(varName(repeatValue)):(repeat.row?"row_".concat(varName(rowValue)):"")+(repeat.column?"column_".concat(varName(columnValue)):""));childRepeater=this.map(childSpec,Object.assign({},params,{repeater:childRepeater,repeaterPrefix:repeatValues}));childRepeater.name=repeatValues;concat.push(omit(childRepeater,["data"]))}spec=isArray(repeat)?spec.columns:repeat.column?repeat.column.length:1;return Object.assign({},{data:null!==
(_childSpec$data=childSpec.data)&&void 0!==_childSpec$data?_childSpec$data:$jscomp$destructuring$var87,align:"all"},$jscomp$destructuring$var88,{columns:spec,concat})}mapFacet(spec,params){const {facet}=spec;isFacetMapping(facet)&&spec.columns&&(spec=omit(spec,["columns"]),warn(columnsNotSupportByRowCol("facet")));return super.mapFacet(spec,params)}mapUnitWithParentEncodingOrProjection(spec,params){const {encoding,projection}=spec,{parentEncoding,parentProjection,config}=params,mergedProjection=mergeProjection({parentProjection,
projection});params=mergeEncoding({parentEncoding,encoding:replaceRepeaterInEncoding(encoding,params.repeater)});return this.mapUnit(Object.assign({},spec,mergedProjection?{projection:mergedProjection}:{},params?{encoding:params}:{}),{config})}mapFacetedUnit(spec,params){var $jscomp$destructuring$var89=spec.encoding,$jscomp$destructuring$var90=Object.assign({},$jscomp$destructuring$var89),row=$jscomp$destructuring$var89.row;const column=$jscomp$destructuring$var89.column;$jscomp$destructuring$var89=
$jscomp$destructuring$var89.facet;const encoding=(delete $jscomp$destructuring$var90.row,delete $jscomp$destructuring$var90.column,delete $jscomp$destructuring$var90.facet,$jscomp$destructuring$var90);var $jscomp$destructuring$var92=Object.assign({},spec);$jscomp$destructuring$var90=spec.mark;const width=spec.width,projection=spec.projection,height=spec.height,view=spec.view;spec=spec.selection;$jscomp$destructuring$var92=(delete $jscomp$destructuring$var92.mark,delete $jscomp$destructuring$var92.width,
delete $jscomp$destructuring$var92.projection,delete $jscomp$destructuring$var92.height,delete $jscomp$destructuring$var92.view,delete $jscomp$destructuring$var92.selection,delete $jscomp$destructuring$var92.encoding,$jscomp$destructuring$var92);const {facetMapping,layout}=this.getFacetMappingAndLayout({row,column,facet:$jscomp$destructuring$var89},params);row=replaceRepeaterInEncoding(encoding,params.repeater);return this.mapFacet(Object.assign({},$jscomp$destructuring$var92,layout,{facet:facetMapping,
spec:Object.assign({},width?{width}:{},height?{height}:{},view?{view}:{},projection?{projection}:{},{mark:$jscomp$destructuring$var90,encoding:row},spec?{selection:spec}:{})}),params)}getFacetMappingAndLayout(facets,params){const {row,column,facet}=facets;if(row||column){facet&&(params=[...row?["row"]:[],...column?["column"]:[]],params="Facet encoding dropped as ".concat(params.join(" and ")," ").concat(1<params.length?"are":"is"," also specified."),warn(params));params={};var layout={};for(var channel of["row",
"column"]){const def=facets[channel];if(def){var $jscomp$destructuring$var94=Object.assign({},def);$jscomp$destructuring$var94=(delete $jscomp$destructuring$var94.align,delete $jscomp$destructuring$var94.center,delete $jscomp$destructuring$var94.spacing,delete $jscomp$destructuring$var94.columns,$jscomp$destructuring$var94);params[channel]=$jscomp$destructuring$var94;for(var prop of["align","center","spacing"])if(void 0!==def[prop]){var _layout$prop;layout[prop]=null!==(_layout$prop=layout[prop])&&
void 0!==_layout$prop?_layout$prop:{};layout[prop][channel]=def[prop]}}}return{facetMapping:params,layout}}layout=Object.assign({},facet);facets=facet.align;_layout$prop=facet.center;channel=facet.spacing;prop=facet.columns;layout=(delete layout.align,delete layout.center,delete layout.spacing,delete layout.columns,layout);params=(params=params.repeater)?isFacetMapping(layout)?replaceRepeaterInMapping(layout,params):replaceRepeaterInFieldDef(layout,params):layout;return{facetMapping:params,layout:Object.assign({},
facets?{align:facets}:{},_layout$prop?{center:_layout$prop}:{},channel?{spacing:channel}:{},prop?{columns:prop}:{})}}mapLayer(spec,$jscomp$destructuring$var97){var $jscomp$destructuring$var99=Object.assign({},$jscomp$destructuring$var97),parentEncoding=$jscomp$destructuring$var97.parentEncoding;$jscomp$destructuring$var97=$jscomp$destructuring$var97.parentProjection;$jscomp$destructuring$var99=(delete $jscomp$destructuring$var99.parentEncoding,delete $jscomp$destructuring$var99.parentProjection,$jscomp$destructuring$var99);
var $jscomp$destructuring$var101=Object.assign({},spec);const encoding=spec.encoding;spec=spec.projection;$jscomp$destructuring$var101=(delete $jscomp$destructuring$var101.encoding,delete $jscomp$destructuring$var101.projection,$jscomp$destructuring$var101);parentEncoding=Object.assign({},$jscomp$destructuring$var99,{parentEncoding:mergeEncoding({parentEncoding,encoding,layer:!0}),parentProjection:mergeProjection({parentProjection:$jscomp$destructuring$var97,projection:spec})});return super.mapLayer($jscomp$destructuring$var101,
parentEncoding)}}const normalizer=new CoreNormalizer;class Split{constructor(explicit,implicit){explicit=void 0===explicit?{}:explicit;implicit=void 0===implicit?{}:implicit;this.explicit=explicit;this.implicit=implicit}clone(){return new Split(duplicate(this.explicit),duplicate(this.implicit))}combine(){return Object.assign({},this.explicit,this.implicit)}get(key){return getFirstDefined(this.explicit[key],this.implicit[key])}getWithExplicit(key){return void 0!==this.explicit[key]?{explicit:!0,value:this.explicit[key]}:
void 0!==this.implicit[key]?{explicit:!1,value:this.implicit[key]}:{explicit:!1,value:void 0}}setWithExplicit(key,value){void 0!==value.value&&this.set(key,value.value,value.explicit)}set(key,value,explicit){delete this[explicit?"implicit":"explicit"][key];this[explicit?"explicit":"implicit"][key]=value;return this}copyKeyFromSplit(key,s){void 0!==s.explicit[key]?this.set(key,s.explicit[key],!0):void 0!==s.implicit[key]&&this.set(key,s.implicit[key],!1)}copyKeyFromObject(key,s){void 0!==s[key]&&this.set(key,
s[key],!0)}copyAll(other){for(const key of keys$jscomp$0(other.combine())){const val=other.getWithExplicit(key);this.setWithExplicit(key,val)}}}class AncestorParse extends Split{constructor(explicit,implicit,parseNothing){explicit=void 0===explicit?{}:explicit;implicit=void 0===implicit?{}:implicit;parseNothing=void 0===parseNothing?!1:parseNothing;super(explicit,implicit);this.explicit=explicit;this.implicit=implicit;this.parseNothing=parseNothing}clone(){const clone=super.clone();clone.parseNothing=
this.parseNothing;return clone}}let DataSourceType;(function(DataSourceType){DataSourceType[DataSourceType.Raw=0]="Raw";DataSourceType[DataSourceType.Main=1]="Main";DataSourceType[DataSourceType.Row=2]="Row";DataSourceType[DataSourceType.Column=3]="Column";DataSourceType[DataSourceType.Lookup=4]="Lookup"})(DataSourceType||(DataSourceType={}));const ILLEGAL=/[[\]{}]/,DEFAULT_MARKS={"*":1,arc:1,area:1,group:1,image:1,line:1,path:1,rect:1,rule:1,shape:1,symbol:1,text:1,trail:1};let DEFAULT_SOURCE,MARKS;
const ALIGNED_X_CHANNEL={left:"x",center:"xc",right:"x2"},BASELINED_Y_CHANNEL={top:"y",middle:"yc",bottom:"y2"},ALWAYS_IGNORE=new Set(["aria"]),nearest={has:selCmpt=>"interval"!==selCmpt.type&&selCmpt.nearest,parse:(model,selCmpt)=>{if(selCmpt.events)for(const s of selCmpt.events)s.markname=model.getName("voronoi")},marks:(model,selCmpt,marks)=>{const {x,y}=selCmpt.project.hasChannel;selCmpt=model.mark;if(isPathMark(selCmpt))return warn('The "nearest" transform is not supported for '.concat(selCmpt,
" marks.")),marks;selCmpt={name:model.getName("voronoi"),type:"path",interactive:!0,from:{data:model.getName("marks")},encode:{update:Object.assign({},{fill:{value:"transparent"},strokeWidth:{value:.35},stroke:{value:"transparent"},isVoronoi:{value:!0}},tooltip(model,{reactiveGeom:!0}))},transform:[{type:"voronoi",x:{expr:x||!y?"datum.datum.x || 0":"0"},y:{expr:y||!x?"datum.datum.y || 0":"0"},size:[model.getSizeSignalRef("width"),model.getSizeSignalRef("height")]}]};let index=0,exists=!1;marks.forEach((mark,
i)=>{var _mark$name;mark=null!==(_mark$name=mark.name)&&void 0!==_mark$name?_mark$name:"";mark===model.component.mark[0].name?index=i:0<=mark.indexOf("voronoi")&&(exists=!0)});exists||marks.splice(index+1,0,selCmpt);return marks}};class DataFlowNode{constructor(parent,debugName){this.debugName=debugName;_defineProperty(this,"_children",[]);_defineProperty(this,"_parent",null);_defineProperty(this,"_hash",void 0);parent&&(this.parent=parent)}clone(){throw Error("Cannot clone node");}get parent(){return this._parent}set parent(parent){(this._parent=
parent)&&parent.addChild(this)}get children(){return this._children}numChildren(){return this._children.length}addChild(child,loc){-1<this._children.indexOf(child)?warn("Attempt to add the same child twice."):void 0!==loc?this._children.splice(loc,0,child):this._children.push(child)}removeChild(oldChild){oldChild=this._children.indexOf(oldChild);this._children.splice(oldChild,1);return oldChild}remove(){let loc=this._parent.removeChild(this);for(const child of this._children)child._parent=this._parent,
this._parent.addChild(child,loc++)}insertAsParentOf(other){const parent=other.parent;parent.removeChild(this);this.parent=parent;other.parent=this}swapWithParent(){const parent=this._parent,newParent=parent.parent;for(const child of this._children)child.parent=parent;this._children=[];parent.removeChild(this);parent.parent.removeChild(parent);this.parent=newParent;parent.parent=this}}class OutputNode extends DataFlowNode{clone(){const cloneObj=new this.constructor;cloneObj.debugName="clone_"+this.debugName;
cloneObj._source=this._source;cloneObj._name="clone_"+this._name;cloneObj.type=this.type;cloneObj.refCounts=this.refCounts;cloneObj.refCounts[cloneObj._name]=0;return cloneObj}constructor(parent,source,type,refCounts){super(parent,source);this.type=type;this.refCounts=refCounts;_defineProperty(this,"_source",void 0);_defineProperty(this,"_name",void 0);this._source=this._name=source;!this.refCounts||this._name in this.refCounts||(this.refCounts[this._name]=0)}dependentFields(){return new Set}producedFields(){return new Set}hash(){void 0===
this._hash&&(this._hash="Output ".concat(uniqueId()));return this._hash}getSource(){this.refCounts[this._name]++;return this._source}isRequired(){return!!this.refCounts[this._name]}setSource(source){this._source=source}}class TimeUnitNode extends DataFlowNode{clone(){return new TimeUnitNode(null,duplicate(this.formula))}constructor(parent,formula){super(parent);this.formula=formula}static makeFromEncoding(parent,model){const formula=model.reduceFieldDef((timeUnitComponent,fieldDef,channel)=>{const {field,
timeUnit}=fieldDef,channelDef2=isUnitModel(model)?model.encoding[getSecondaryRangeChannel(channel)]:void 0;channel=isUnitModel(model)&&hasBand(channel,fieldDef,channelDef2,model.stack,model.markDef,model.config);timeUnit&&(fieldDef=vgField(fieldDef,{forAs:!0}),timeUnitComponent[hash({as:fieldDef,field,timeUnit})]=Object.assign({},{as:fieldDef,field,timeUnit},channel?{band:!0}:{}));return timeUnitComponent},{});return isEmpty(formula)?null:new TimeUnitNode(parent,formula)}static makeFromTransform(parent,
t){var $jscomp$destructuring$var117=Object.assign({},t);t=Object.assign({},$jscomp$destructuring$var117);$jscomp$destructuring$var117=$jscomp$destructuring$var117.timeUnit;t=(delete t.timeUnit,t);$jscomp$destructuring$var117=normalizeTimeUnit($jscomp$destructuring$var117);t=Object.assign({},t,{timeUnit:$jscomp$destructuring$var117});return new TimeUnitNode(parent,{[hash(t)]:t})}merge(other){this.formula=Object.assign({},this.formula);for(const key in other.formula)if(!this.formula[key]||other.formula[key].band)this.formula[key]=
other.formula[key];for(const child of other.children)other.removeChild(child),child.parent=this;other.remove()}removeFormulas(fields){const newFormula={};for(const $jscomp$destructuring$var119 of entries(this.formula)){const [key,timeUnit]=$jscomp$destructuring$var119;fields.has(timeUnit.as)||(newFormula[key]=timeUnit)}this.formula=newFormula}producedFields(){return new Set(vals$jscomp$0(this.formula).map(f=>f.as))}dependentFields(){return new Set(vals$jscomp$0(this.formula).map(f=>f.field))}hash(){return"TimeUnit ".concat(hash(this.formula))}assemble(){const transforms=
[];for(const f of vals$jscomp$0(this.formula)){const {field,as,timeUnit}=f;var $jscomp$destructuring$var120=normalizeTimeUnit(timeUnit),$jscomp$destructuring$var121=Object.assign({},$jscomp$destructuring$var120);const unit=$jscomp$destructuring$var120.unit;$jscomp$destructuring$var120=$jscomp$destructuring$var120.utc;$jscomp$destructuring$var121=(delete $jscomp$destructuring$var121.unit,delete $jscomp$destructuring$var121.utc,$jscomp$destructuring$var121);transforms.push(Object.assign({},{field:replacePathInField(field),
type:"timeunit"},unit?{units:getTimeUnitParts(unit)}:{},$jscomp$destructuring$var120?{timezone:"utc"}:{},$jscomp$destructuring$var121,{as:[as,"".concat(as,"_end")]}))}return transforms}}class SelectionProjectionComponent{constructor(...items){_defineProperty(this,"hasChannel",void 0);_defineProperty(this,"hasField",void 0);_defineProperty(this,"timeUnit",void 0);_defineProperty(this,"items",void 0);this.items=items;this.hasChannel={};this.hasField={}}}const inputBindings={has:selCmpt=>"single"===
selCmpt.type&&"global"===selCmpt.resolve&&selCmpt.bind&&"scales"!==selCmpt.bind&&!isLegendBinding(selCmpt.bind),parse:(model,selCmpt,selDef,origDef)=>{origDef.on||delete selCmpt.events;origDef.clear||delete selCmpt.clear},topLevelSignals:(model,selCmpt,signals)=>{const name=selCmpt.name;model=selCmpt.project;const bind=selCmpt.bind,init=selCmpt.init&&selCmpt.init[0],datum=nearest.has(selCmpt)?"(item().isVoronoi ? datum.datum : datum)":"datum";model.items.forEach((p,i)=>{const sgname=varName("".concat(name,
"_").concat(p.field));if(!signals.filter(s=>s.name===sgname).length){var _ref,_bind$p$field;signals.unshift(Object.assign({},{name:sgname},init?{init:assembleInit(init[i])}:{value:null},{on:selCmpt.events?[{events:selCmpt.events,update:"datum \x26\x26 item().mark.marktype !\x3d\x3d 'group' ? ".concat(datum,"[").concat($(p.field),"] : null")}]:[],bind:null!==(_ref=null!==(_bind$p$field=bind[p.field])&&void 0!==_bind$p$field?_bind$p$field:bind[p.channel])&&void 0!==_ref?_ref:bind}))}});return signals},
signals:(model,selCmpt,signals)=>{const name=selCmpt.name;var proj=selCmpt.project;model=signals.filter(s=>s.name===name+"_tuple")[0];selCmpt=name+"_tuple_fields";proj=proj.items.map(p=>varName("".concat(name,"_").concat(p.field)));const valid=proj.map(v=>"".concat(v," !\x3d\x3d null")).join(" \x26\x26 ");proj.length&&(model.update="".concat(valid," ? {fields: ").concat(selCmpt,", values: [").concat(proj.join(", "),"]} : null"));delete model.value;delete model.on;return signals}},toggle={has:selCmpt=>
"multi"===selCmpt.type&&!!selCmpt.toggle,signals:(model,selCmpt,signals)=>signals.concat({name:selCmpt.name+"_toggle",value:!1,on:[{events:selCmpt.events,update:selCmpt.toggle}]}),modifyExpr:(model,selCmpt)=>{const tpl=selCmpt.name+"_tuple",signal=selCmpt.name+"_toggle";return"".concat(signal," ? null : ").concat(tpl,", ")+("global"===selCmpt.resolve?"".concat(signal," ? null : true, "):"".concat(signal," ? null : {unit: ").concat(unitName(model),"}, "))+"".concat(signal," ? ").concat(tpl," : null")}},
scaleBindings={has:selCmpt=>"interval"===selCmpt.type&&"global"===selCmpt.resolve&&selCmpt.bind&&"scales"===selCmpt.bind,parse:(model,selCmpt)=>{const bound=selCmpt.scales=[];for(const proj of selCmpt.project.items){var channel=proj.channel;if(!SCALE_CHANNEL_INDEX[channel])continue;const scaleType=(channel=model.getScaleComponent(channel))?channel.get("type"):void 0;channel&&scaleType in CONTINUOUS_DOMAIN_INDEX?(channel.set("selectionExtent",{selection:selCmpt.name,field:proj.field},!0),bound.push(proj)):
warn("Scale bindings are currently only supported for scales with unbinned, continuous domains.")}},topLevelSignals:(model,selCmpt,signals)=>{const bound=selCmpt.scales.filter(proj=>0===signals.filter(s=>s.name===proj.signals.data).length);if(!model.parent||isTopLevelLayer(model)||0===bound.length)return signals;model=signals.filter(s=>s.name===selCmpt.name)[0];let update=model.update;if(0<=update.indexOf("vlSelectionResolve"))model.update="{".concat(bound.map(proj=>"".concat($(proj.field),": ").concat(proj.signals.data)).join(", "),
"}");else{for(const proj of bound){const mapping="".concat($(proj.field),": ").concat(proj.signals.data);0>update.indexOf(mapping)&&(update="".concat(update.substring(0,update.length-1),", ").concat(mapping,"}"))}model.update=update}return signals.concat(bound.map(proj=>({name:proj.signals.data})))},signals:(model,selCmpt,signals)=>{if(model.parent&&!isTopLevelLayer(model))for(const proj of selCmpt.scales)model=signals.filter(s=>s.name===proj.signals.data)[0],model.push="outer",delete model.value,
delete model.update;return signals}},legendBindings={has:selCmpt=>{const spec="global"===selCmpt.resolve&&selCmpt.bind&&isLegendBinding(selCmpt.bind);selCmpt=1===selCmpt.project.items.length&&"_vgsid_"!==selCmpt.project.items[0].field;spec&&!selCmpt&&warn("Legend bindings are only supported for selections over an individual field or encoding channel.");return spec&&selCmpt},parse:(model,selCmpt,selDef,origDef)=>{origDef.on||delete selCmpt.events;origDef.clear||delete selCmpt.clear;if(origDef.on||
origDef.clear)for(const evt of selCmpt.events){var _evt$filter;evt.filter=array$jscomp$0(null!==(_evt$filter=evt.filter)&&void 0!==_evt$filter?_evt$filter:[]);0>evt.filter.indexOf('event.item \x26\x26 indexof(event.item.mark.role, "legend") \x3c 0')&&evt.filter.push('event.item \x26\x26 indexof(event.item.mark.role, "legend") \x3c 0')}model=isLegendStreamBinding(selCmpt.bind)?selCmpt.bind.legend:"click";model=isString(model)?eventSelector(model,"view"):array$jscomp$0(model);selCmpt.bind={legend:{merge:model}}},
topLevelSignals:(model,selCmpt,signals)=>{model=selCmpt.name;const stream=isLegendStreamBinding(selCmpt.bind)&&selCmpt.bind.legend,markName=name=>s=>{s=duplicate(s);s.markname=name;return s};for(const proj of selCmpt.project.items){if(!proj.hasLegend)continue;var prefix="".concat(varName(proj.field),"_legend");const sgName="".concat(model,"_").concat(prefix);0===signals.filter(s=>s.name===sgName).length&&(prefix=stream.merge.map(markName("".concat(prefix,"_symbols"))).concat(stream.merge.map(markName("".concat(prefix,
"_labels")))).concat(stream.merge.map(markName("".concat(prefix,"_entries")))),signals.unshift(Object.assign({},{name:sgName},selCmpt.init?{}:{value:null},{on:[{events:prefix,update:"datum.value || item().items[0].items[0].datum.value",force:!0},{events:stream.merge,update:"!event.item || !datum ? null : ".concat(sgName),force:!0}]})))}return signals},signals:(model,selCmpt,signals)=>{const name=selCmpt.name;var proj=selCmpt.project;model=signals.find(s=>s.name===name+"_tuple");var fields=name+"_tuple_fields";
proj=proj.items.filter(p=>p.hasLegend).map(p=>varName("".concat(name,"_").concat(varName(p.field),"_legend")));const valid=proj.map(v=>"".concat(v," !\x3d\x3d null")).join(" \x26\x26 ");fields="".concat(valid," ? {fields: ").concat(fields,", values: [").concat(proj.join(", "),"]} : null");selCmpt.events&&0<proj.length?model.on.push({events:proj.map(signal=>({signal})),update:fields}):0<proj.length&&(model.update=fields,delete model.value,delete model.on);model=signals.find(s=>s.name===name+"_toggle");
fields=isLegendStreamBinding(selCmpt.bind)&&selCmpt.bind.legend;model&&(selCmpt.events?model.on.push(Object.assign({},model.on[0],{events:fields})):model.on[0].events=fields);return signals}},compilers=[{has:()=>!0,parse:(model,selCmpt,selDef)=>{var _selCmpt$project;const name=selCmpt.name,proj=null!==(_selCmpt$project=selCmpt.project)&&void 0!==_selCmpt$project?_selCmpt$project:selCmpt.project=new SelectionProjectionComponent,parsed={};_selCmpt$project={};const signals=new Set,signalName=(p,range)=>
{p="visual"===range?p.channel:p.field;let sg=varName("".concat(name,"_").concat(p));for(let counter=1;signals.has(sg);counter++)sg=varName("".concat(name,"_").concat(p,"_").concat(counter));signals.add(sg);return{[range]:sg}};if(!selDef.fields&&!selDef.encodings){const cfg=model.config.selection[selDef.type];if(selDef.init)for(const init of array$jscomp$0(selDef.init))for(const key of keys$jscomp$0(init))SINGLE_DEF_UNIT_CHANNEL_INDEX[key]?(selDef.encodings||(selDef.encodings=[])).push(key):"interval"===
selDef.type?(warn('Interval selections should be initialized using "x" and/or "y" keys.'),selDef.encodings=cfg.encodings):(selDef.fields||(selDef.fields=[])).push(key);else selDef.encodings=cfg.encodings,selDef.fields=cfg.fields}for(var field of null!==(_selDef$fields=selDef.fields)&&void 0!==_selDef$fields?_selDef$fields:[]){var _selDef$fields;_selDef$fields={type:"E",field};_selDef$fields.signals=Object.assign({},signalName(_selDef$fields,"data"));proj.items.push(_selDef$fields);proj.hasField[field]=
_selDef$fields}for(const channel of null!==(_selDef$encodings=selDef.encodings)&&void 0!==_selDef$encodings?_selDef$encodings:[]){var _selDef$encodings;(field=model.fieldDef(channel))?(_selDef$encodings=field.field,field.aggregate?warn(cannotProjectAggregate(channel,field.aggregate)):_selDef$encodings?(field.timeUnit&&(_selDef$encodings=model.vgField(channel),_selDef$fields={timeUnit:field.timeUnit,as:_selDef$encodings,field:field.field},_selCmpt$project[hash(_selDef$fields)]=_selDef$fields),parsed[_selDef$encodings]||
(_selDef$fields="E","interval"===selCmpt.type?model.getScaleComponent(channel).get("type")in CONTINUOUS_DOMAIN_INDEX&&(_selDef$fields="R"):field.bin&&(_selDef$fields="R-RE"),field={field:_selDef$encodings,channel,type:_selDef$fields},field.signals=Object.assign({},signalName(field,"data"),signalName(field,"visual")),proj.items.push(parsed[_selDef$encodings]=field),proj.hasField[_selDef$encodings]=proj.hasChannel[channel]=parsed[_selDef$encodings])):warn(cannotProjectOnChannelWithoutField(channel))):
warn(cannotProjectOnChannelWithoutField(channel))}selDef.init&&(model=i=>proj.items.map(p=>void 0!==i[p.channel]?i[p.channel]:i[p.field]),"interval"===selDef.type?selCmpt.init=model(selDef.init):(selDef=array$jscomp$0(selDef.init),selCmpt.init=selDef.map(model)));isEmpty(_selCmpt$project)||(proj.timeUnit=new TimeUnitNode(null,_selCmpt$project))},signals:(model,selCmpt,allSignals)=>{const name=selCmpt.name+"_tuple_fields";return 0<allSignals.filter(s=>s.name===name).length?allSignals:allSignals.concat({name,
value:selCmpt.project.items.map(proj=>{proj=Object.assign({},proj);proj=(delete proj.signals,delete proj.hasLegend,proj);proj.field=replacePathInField(proj.field);return proj})})}},toggle,scaleBindings,legendBindings,{has:selCmpt=>"interval"===selCmpt.type&&selCmpt.translate,signals:(model,selCmpt,signals)=>{const name=selCmpt.name,hasScales=scaleBindings.has(selCmpt),anchor=name+"_translate_anchor",{x,y}=selCmpt.project.hasChannel;let events=eventSelector(selCmpt.translate,"scope");hasScales||(events=
events.map(e=>(e.between[0].markname=name+"_brush",e)));signals.push({name:anchor,value:{},on:[{events:events.map(e=>e.between[0]),update:"{x: x(unit), y: y(unit)"+(void 0!==x?", extent_x: "+(hasScales?domain$1(model,"x"):"slice(".concat(x.signals.visual,")")):"")+(void 0!==y?", extent_y: "+(hasScales?domain$1(model,"y"):"slice(".concat(y.signals.visual,")")):"")+"}"}]},{name:name+"_translate_delta",value:{},on:[{events,update:"{x: ".concat(anchor,".x - x(unit), y: ").concat(anchor,".y - y(unit)}")}]});
void 0!==x&&onDelta(model,selCmpt,x,"width",signals);void 0!==y&&onDelta(model,selCmpt,y,"height",signals);return signals}},{has:selCmpt=>"interval"===selCmpt.type&&selCmpt.zoom,signals:(model,selCmpt,signals)=>{const name=selCmpt.name,hasScales=scaleBindings.has(selCmpt),delta=name+"_zoom_delta",{x,y}=selCmpt.project.hasChannel,sx=$(model.scaleName("x")),sy=$(model.scaleName("y"));let events=eventSelector(selCmpt.zoom,"scope");hasScales||(events=events.map(e=>(e.markname=name+"_brush",e)));signals.push({name:name+
"_zoom_anchor",on:[{events,update:hasScales?"{"+[sx?"x: invert(".concat(sx,", x(unit))"):"",sy?"y: invert(".concat(sy,", y(unit))"):""].filter(expr=>!!expr).join(", ")+"}":"{x: x(unit), y: y(unit)}"}]},{name:delta,on:[{events,force:!0,update:"pow(1.001, event.deltaY * pow(16, event.deltaMode))"}]});void 0!==x&&onDelta$1(model,selCmpt,x,"width",signals);void 0!==y&&onDelta$1(model,selCmpt,y,"height",signals);return signals}},inputBindings,nearest,{has:selCmpt=>void 0!==selCmpt.clear&&!1!==selCmpt.clear,
parse:(model,selCmpt,selDef)=>{selDef.clear&&(selCmpt.clear=isString(selDef.clear)?eventSelector(selDef.clear,"scope"):selDef.clear)},topLevelSignals:(model,selCmpt,signals)=>{if(inputBindings.has(selCmpt))for(const proj of selCmpt.project.items)model=signals.findIndex(n=>n.name===varName("".concat(selCmpt.name,"_").concat(proj.field))),-1!==model&&signals[model].on.push({events:selCmpt.clear,update:"null"});return signals},signals:(model,selCmpt,signals)=>{function addClear(idx,update){-1!==idx&&
signals[idx].on&&signals[idx].on.push({events:selCmpt.clear,update})}if("interval"===selCmpt.type)for(const proj of selCmpt.project.items)model=signals.findIndex(n=>n.name===proj.signals.visual),addClear(model,"[0, 0]"),-1===model&&(model=signals.findIndex(n=>n.name===proj.signals.data),addClear(model,"null"));else model=signals.findIndex(n=>n.name===selCmpt.name+"_tuple"),addClear(model,"null"),toggle.has(selCmpt)&&(model=signals.findIndex(n=>n.name===selCmpt.name+"_toggle"),addClear(model,"false"));
return signals}}],compilers$1={single:{signals:singleOrMultiSignals,modifyExpr:(model,selCmpt)=>selCmpt.name+"_tuple, "+("global"===selCmpt.resolve?"true":"{unit: ".concat(unitName(model),"}"))},multi:{signals:singleOrMultiSignals,modifyExpr:(model,selCmpt)=>selCmpt.name+"_tuple, "+("global"===selCmpt.resolve?"null":"{unit: ".concat(unitName(model),"}"))},interval:{signals:(model,selCmpt)=>{const name=selCmpt.name;var fieldsSg=name+"_tuple_fields",hasScales=scaleBindings.has(selCmpt);const signals=
[],dataSignals=[],scaleTriggers=[];if(selCmpt.translate&&!hasScales){const filterExpr="!event.item || event.item.mark.name !\x3d\x3d ".concat($(name+"_brush"));events$jscomp$0(selCmpt,(on,evt)=>{var _evt$between$0$filter;evt=array$jscomp$0(null!==(_evt$between$0$filter=evt.between[0].filter)&&void 0!==_evt$between$0$filter?_evt$between$0$filter:evt.between[0].filter=[]);0>evt.indexOf(filterExpr)&&evt.push(filterExpr);return on})}selCmpt.project.items.forEach((proj,i)=>{const channel=proj.channel;
if("x"!==channel&&"y"!==channel)warn("Interval selections only support x and y encoding channels.");else{i=channelSignals(model,selCmpt,proj,selCmpt.init?selCmpt.init[i]:null);var dname=proj.signals.data;proj=proj.signals.visual;var scaleName=$(model.scaleName(channel)),toNum=model.getScaleComponent(channel).get("type")in CONTINUOUS_DOMAIN_INDEX?"+":"";signals.push(...i);dataSignals.push(dname);scaleTriggers.push({scaleName:model.scaleName(channel),expr:"(!isArray(".concat(dname,") || ")+"(".concat(toNum,
"invert(").concat(scaleName,", ").concat(proj,")[0] \x3d\x3d\x3d ").concat(toNum).concat(dname,"[0] \x26\x26 ")+"".concat(toNum,"invert(").concat(scaleName,", ").concat(proj,")[1] \x3d\x3d\x3d ").concat(toNum).concat(dname,"[1]))")})}});hasScales||signals.push({name:name+"_scale_trigger",value:{},on:[{events:scaleTriggers.map(t=>({scale:t.scaleName})),update:scaleTriggers.map(t=>t.expr).join(" \x26\x26 ")+" ? ".concat(name+"_scale_trigger"," : {}")}]});hasScales=selCmpt.init;fieldsSg="unit: ".concat(unitName(model),
", fields: ").concat(fieldsSg,", values");return signals.concat(Object.assign({},{name:name+"_tuple"},hasScales?{init:"{".concat(fieldsSg,": ").concat(assembleInit(hasScales),"}")}:{},{on:[{events:[{signal:dataSignals.join(" || ")}],update:dataSignals.join(" \x26\x26 ")+" ? {".concat(fieldsSg,": [").concat(dataSignals,"]} : null")}]}))},modifyExpr:(model,selCmpt)=>selCmpt.name+"_tuple, "+("global"===selCmpt.resolve?"true":"{unit: ".concat(unitName(model),"}")),marks:(model,selCmpt,marks)=>{const name=
selCmpt.name,{x,y}=selCmpt.project.hasChannel,xvname=x&&x.signals.visual,yvname=y&&y.signals.visual;var store="data(".concat($(selCmpt.name+"_store"),")");if(scaleBindings.has(selCmpt))return marks;const update={x:void 0!==x?{signal:"".concat(xvname,"[0]")}:{value:0},y:void 0!==y?{signal:"".concat(yvname,"[0]")}:{value:0},x2:void 0!==x?{signal:"".concat(xvname,"[1]")}:{field:{group:"width"}},y2:void 0!==y?{signal:"".concat(yvname,"[1]")}:{field:{group:"height"}}};if("global"===selCmpt.resolve)for(var key of keys$jscomp$0(update))update[key]=
[Object.assign({},{test:"".concat(store,".length \x26\x26 ").concat(store,"[0].unit \x3d\x3d\x3d ").concat(unitName(model))},update[key]),{value:0}];key=selCmpt.mark;store=Object.assign({},key);model=key.fill;selCmpt=key.fillOpacity;key=key.cursor;const stroke=(delete store.fill,delete store.fillOpacity,delete store.cursor,store);store=keys$jscomp$0(stroke).reduce((def,k)=>{def[k]=[{test:[void 0!==x&&"".concat(xvname,"[0] !\x3d\x3d ").concat(xvname,"[1]"),void 0!==y&&"".concat(yvname,"[0] !\x3d\x3d ").concat(yvname,
"[1]")].filter(t=>t).join(" \x26\x26 "),value:stroke[k]},{value:null}];return def},{});return[{name:name+"_brush_bg",type:"rect",clip:!0,encode:{enter:{fill:{value:model},fillOpacity:{value:selCmpt}},update}},...marks,{name:name+"_brush",type:"rect",clip:!0,encode:{enter:Object.assign({},key?{cursor:{value:key}}:{},{fill:{value:"transparent"}}),update:Object.assign({},update,store)}}]}}};ASTNode.prototype.visit=function(visitor){let c,i,n;if(visitor(this))return 1;c=children$jscomp$0(this);i=0;for(n=
c.length;i<n;++i)if(c[i].visit(visitor))return 1};var source$jscomp$0,index$jscomp$0,length$jscomp$0,lookahead,RegexNonAsciiIdentifierStart=/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
RegexNonAsciiIdentifierPart=/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
const keywords={"if":1,"in":1,"do":1,"var":1,"for":1,"new":1,"try":1,let:1,"this":1,"else":1,"case":1,"void":1,"with":1,"enum":1,"while":1,"break":1,"catch":1,"throw":1,"const":1,yield:1,"class":1,"super":1,"return":1,"typeof":1,"delete":1,"switch":1,"export":1,"import":1,"public":1,"static":1,"default":1,"finally":1,"extends":1,"package":1,"private":1,"function":1,"continue":1,"debugger":1,"interface":1,"protected":1,"instanceof":1,"implements":1},legalKeywords={"if":1};class FilterNode extends DataFlowNode{clone(){return new FilterNode(null,
this.model,duplicate(this.filter))}constructor(parent,model,filter){super(parent);this.model=model;this.filter=filter;_defineProperty(this,"expr",void 0);_defineProperty(this,"_dependentFields",void 0);this.expr=expression$jscomp$0(this.model,this.filter,this);this._dependentFields=getDependentFields(this.expr)}dependentFields(){return this._dependentFields}producedFields(){return new Set}assemble(){return{type:"filter",expr:this.expr}}hash(){return"Filter ".concat(this.expr)}}const axisRules={scale:$jscomp$destructuring$var139=>
{var {model,channel}=$jscomp$destructuring$var139;return model.scaleName(channel)},format:$jscomp$destructuring$var140=>{var {fieldOrDatumDef,config,axis}=$jscomp$destructuring$var140;const {format,formatType}=axis;return guideFormat(fieldOrDatumDef,fieldOrDatumDef.type,format,formatType,config,!0)},formatType:$jscomp$destructuring$var141=>{var {axis,fieldOrDatumDef,scaleType}=$jscomp$destructuring$var141;({formatType:$jscomp$destructuring$var141}=axis);return guideFormatType($jscomp$destructuring$var141,
fieldOrDatumDef,scaleType)},grid:$jscomp$destructuring$var142=>{var {fieldOrDatumDef,axis,scaleType}=$jscomp$destructuring$var142;if(isFieldDef(fieldOrDatumDef)&&isBinned(fieldOrDatumDef.bin))return!1;var _axis$grid;return null!==(_axis$grid=axis.grid)&&void 0!==_axis$grid?_axis$grid:!(scaleType in DISCRETE_DOMAIN_INDEX)&&isFieldDef(fieldOrDatumDef)&&!isBinning(null===fieldOrDatumDef||void 0===fieldOrDatumDef?void 0:fieldOrDatumDef.bin)},gridScale:$jscomp$destructuring$var143=>{var {model,channel}=
$jscomp$destructuring$var143;$jscomp$destructuring$var143="x"===channel?"y":"x";$jscomp$destructuring$var143=model.getScaleComponent($jscomp$destructuring$var143)?model.scaleName($jscomp$destructuring$var143):void 0;return $jscomp$destructuring$var143},labelAlign:$jscomp$destructuring$var144=>{var {axis,labelAngle,orient,channel}=$jscomp$destructuring$var144;return axis.labelAlign||defaultLabelAlign(labelAngle,orient,channel)},labelAngle:$jscomp$destructuring$var145=>{({labelAngle:$jscomp$destructuring$var145}=
$jscomp$destructuring$var145);return $jscomp$destructuring$var145},labelBaseline:$jscomp$destructuring$var146=>{var {axis,labelAngle,orient,channel}=$jscomp$destructuring$var146;return axis.labelBaseline||defaultLabelBaseline(labelAngle,orient,channel)},labelFlush:$jscomp$destructuring$var147=>{var {axis,fieldOrDatumDef,channel}=$jscomp$destructuring$var147,_axis$labelFlush;$jscomp$destructuring$var147=null!==(_axis$labelFlush=axis.labelFlush)&&void 0!==_axis$labelFlush?_axis$labelFlush:"x"===channel&&
contains(["quantitative","temporal"],fieldOrDatumDef.type)?!0:void 0;return $jscomp$destructuring$var147},labelOverlap:$jscomp$destructuring$var148=>{var {axis,fieldOrDatumDef,scaleType}=$jscomp$destructuring$var148,_axis$labelOverlap;if(null!==(_axis$labelOverlap=axis.labelOverlap)&&void 0!==_axis$labelOverlap)$jscomp$destructuring$var148=_axis$labelOverlap;else{$jscomp$destructuring$var148=fieldOrDatumDef.type;_axis$labelOverlap=isFieldDef(fieldOrDatumDef)&&!!fieldOrDatumDef.timeUnit;var sort=isFieldDef(fieldOrDatumDef)?
fieldOrDatumDef.sort:void 0;$jscomp$destructuring$var148=_axis$labelOverlap&&!isObject(sort)||"nominal"!==$jscomp$destructuring$var148&&"ordinal"!==$jscomp$destructuring$var148?"log"===scaleType||"symlog"===scaleType?"greedy":!0:void 0}return $jscomp$destructuring$var148},orient:$jscomp$destructuring$var149=>{({orient:$jscomp$destructuring$var149}=$jscomp$destructuring$var149);return $jscomp$destructuring$var149},tickCount:$jscomp$destructuring$var150=>{var {channel,model,axis,fieldOrDatumDef,scaleType}=
$jscomp$destructuring$var150,_axis$tickCount;$jscomp$destructuring$var150=($jscomp$destructuring$var150="x"===channel?"width":"y"===channel?"height":void 0)?model.getSizeSignalRef($jscomp$destructuring$var150):void 0;if(null===(_axis$tickCount=axis.tickCount)||void 0===_axis$tickCount)a:{var {fieldOrDatumDef:fieldOrDatumDef$jscomp$0,scaleType:scaleType$jscomp$0,size,values:vals}={fieldOrDatumDef,scaleType,size:$jscomp$destructuring$var150,values:axis.values};if(vals||scaleType$jscomp$0 in DISCRETE_DOMAIN_INDEX||
"log"===scaleType$jscomp$0)_axis$tickCount=void 0;else{if(isFieldDef(fieldOrDatumDef$jscomp$0)){var _normalizeTimeUnit;if(isBinning(fieldOrDatumDef$jscomp$0.bin)){_axis$tickCount={signal:"ceil(".concat(size.signal,"/10)")};break a}if(fieldOrDatumDef$jscomp$0.timeUnit&&contains(["month","hours","day","quarter"],null===(_normalizeTimeUnit=normalizeTimeUnit(fieldOrDatumDef$jscomp$0.timeUnit))||void 0===_normalizeTimeUnit?void 0:_normalizeTimeUnit.unit)){_axis$tickCount=void 0;break a}}_axis$tickCount=
{signal:"ceil(".concat(size.signal,"/40)")}}}return _axis$tickCount},title:$jscomp$destructuring$var151=>{var {axis,model,channel}=$jscomp$destructuring$var151;if(void 0!==axis.title)return axis.title;$jscomp$destructuring$var151=getFieldDefTitle(model,channel);if(void 0!==$jscomp$destructuring$var151)return $jscomp$destructuring$var151;$jscomp$destructuring$var151=model.typedFieldDef(channel);const fieldDef2=model.fieldDef("x"===channel?"x2":"y2");return mergeTitleFieldDefs($jscomp$destructuring$var151?
[toFieldDefBase($jscomp$destructuring$var151)]:[],isFieldDef(fieldDef2)?[toFieldDefBase(fieldDef2)]:[])},values:$jscomp$destructuring$var152=>{var {axis,fieldOrDatumDef}=$jscomp$destructuring$var152;$jscomp$destructuring$var152=axis.values;$jscomp$destructuring$var152=isArray($jscomp$destructuring$var152)?valueArray(fieldOrDatumDef,$jscomp$destructuring$var152):isSignalRef($jscomp$destructuring$var152)?$jscomp$destructuring$var152:void 0;return $jscomp$destructuring$var152},zindex:$jscomp$destructuring$var153=>
{var {axis,fieldOrDatumDef,mark}=$jscomp$destructuring$var153,_axis$zindex;$jscomp$destructuring$var153=null!==(_axis$zindex=axis.zindex)&&void 0!==_axis$zindex?_axis$zindex:"rect"===mark&&isDiscrete(fieldOrDatumDef)?1:0;return $jscomp$destructuring$var153}};class CalculateNode extends DataFlowNode{clone(){return new CalculateNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;_defineProperty(this,"_dependentFields",void 0);this._dependentFields=
getDependentFields(this.transform.calculate)}static parseAllForSortIndex(parent,model){model.forEachFieldDef((fieldDef,channel)=>{if(isScaleFieldDef(fieldDef)&&isSortArray(fieldDef.sort)){const {field,timeUnit}=fieldDef;var sort=fieldDef.sort;sort=sort.map((sortValue,i)=>"".concat(fieldFilterExpression({field,timeUnit,equal:sortValue})," ? ").concat(i," : ")).join("")+sort.length;parent=new CalculateNode(parent,{calculate:sort,as:sortArrayIndexField(fieldDef,channel,{forAs:!0})})}});return parent}producedFields(){return new Set([this.transform.as])}dependentFields(){return this._dependentFields}assemble(){return{type:"formula",
expr:this.transform.calculate,as:this.transform.as}}hash(){return"Calculate ".concat(hash(this.transform))}}const HEADER_CHANNELS=["row","column"],HEADER_TYPES=["header","footer"],LAYOUT_TITLE_BAND={column:{start:0,end:1},row:{start:1,end:0}},LEGEND_COMPONENT_PROPERTY_INDEX=Object.assign({},{aria:1,clipHeight:1,columnPadding:1,columns:1,cornerRadius:1,description:1,direction:1,fillColor:1,format:1,formatType:1,gradientLength:1,gradientOpacity:1,gradientStrokeColor:1,gradientStrokeWidth:1,gradientThickness:1,
gridAlign:1,labelAlign:1,labelBaseline:1,labelColor:1,labelFont:1,labelFontSize:1,labelFontStyle:1,labelFontWeight:1,labelLimit:1,labelOffset:1,labelOpacity:1,labelOverlap:1,labelPadding:1,labelSeparation:1,legendX:1,legendY:1,offset:1,orient:1,padding:1,rowPadding:1,strokeColor:1,symbolDash:1,symbolDashOffset:1,symbolFillColor:1,symbolLimit:1,symbolOffset:1,symbolOpacity:1,symbolSize:1,symbolStrokeColor:1,symbolStrokeWidth:1,symbolType:1,tickCount:1,tickMinStep:1,title:1,titleAlign:1,titleAnchor:1,
titleBaseline:1,titleColor:1,titleFont:1,titleFontSize:1,titleFontStyle:1,titleFontWeight:1,titleLimit:1,titleLineHeight:1,titleOpacity:1,titleOrient:1,titlePadding:1,type:1,values:1,zindex:1},{disable:1,labelExpr:1,selections:1,opacity:1,shape:1,stroke:1,fill:1,size:1,strokeWidth:1,strokeDash:1,encode:1}),LEGEND_COMPONENT_PROPERTIES=keys$jscomp$0(LEGEND_COMPONENT_PROPERTY_INDEX);class LegendComponent extends Split{}const legendEncodeRules={symbols:function(symbolsSpec,$jscomp$destructuring$var155){var {fieldOrDatumDef,
model,channel,legendCmpt,legendType}=$jscomp$destructuring$var155,_legendCmpt$get,_legendCmpt$get2,_legendCmpt$get3,_getMaxValue;if("symbol"===legendType){var {markDef,encoding,config,mark}=model,filled=markDef.filled&&"trail"!==mark;$jscomp$destructuring$var155=Object.assign({},applyMarkConfig({},model,FILL_STROKE_CONFIG),color$jscomp$0(model,{filled}));var symbolOpacity=null!==(_legendCmpt$get=legendCmpt.get("symbolOpacity"))&&void 0!==_legendCmpt$get?_legendCmpt$get:config.legend.symbolOpacity;
_legendCmpt$get=null!==(_legendCmpt$get2=legendCmpt.get("symbolFillColor"))&&void 0!==_legendCmpt$get2?_legendCmpt$get2:config.legend.symbolFillColor;_legendCmpt$get2=null!==(_legendCmpt$get3=legendCmpt.get("symbolStrokeColor"))&&void 0!==_legendCmpt$get3?_legendCmpt$get3:config.legend.symbolStrokeColor;_legendCmpt$get3=void 0===symbolOpacity?null!==(_getMaxValue=getMaxValue(encoding.opacity))&&void 0!==_getMaxValue?_getMaxValue:markDef.opacity:void 0;if($jscomp$destructuring$var155.fill)if("fill"===
channel||filled&&"color"===channel)delete $jscomp$destructuring$var155.fill;else if($jscomp$destructuring$var155.fill.field)if(_legendCmpt$get)delete $jscomp$destructuring$var155.fill;else{var _config$legend$symbol;$jscomp$destructuring$var155.fill=signalOrValueRef(null!==(_config$legend$symbol=config.legend.symbolBaseFillColor)&&void 0!==_config$legend$symbol?_config$legend$symbol:"black");$jscomp$destructuring$var155.fillOpacity=signalOrValueRef(null!==_legendCmpt$get3&&void 0!==_legendCmpt$get3?
_legendCmpt$get3:1)}else if(isArray($jscomp$destructuring$var155.fill)){var _ref,_getFirstConditionVal,_encoding$fill;if(_getMaxValue=null!==(_ref=null!==(_getFirstConditionVal=getFirstConditionValue(null!==(_encoding$fill=encoding.fill)&&void 0!==_encoding$fill?_encoding$fill:encoding.color))&&void 0!==_getFirstConditionVal?_getFirstConditionVal:markDef.fill)&&void 0!==_ref?_ref:filled&&markDef.color)$jscomp$destructuring$var155.fill=signalOrValueRef(_getMaxValue)}$jscomp$destructuring$var155.stroke&&
("stroke"===channel||!filled&&"color"===channel?delete $jscomp$destructuring$var155.stroke:$jscomp$destructuring$var155.stroke.field||_legendCmpt$get2?delete $jscomp$destructuring$var155.stroke:isArray($jscomp$destructuring$var155.stroke)&&(_ref=getFirstDefined(getFirstConditionValue(encoding.stroke||encoding.color),markDef.stroke,filled?markDef.color:void 0))&&($jscomp$destructuring$var155.stroke={value:_ref}));"opacity"!==channel&&((_ref=isFieldDef(fieldOrDatumDef)&&selectedCondition(model,legendCmpt,
fieldOrDatumDef))?$jscomp$destructuring$var155.opacity=[Object.assign({},{test:_ref},signalOrValueRef(null!==_legendCmpt$get3&&void 0!==_legendCmpt$get3?_legendCmpt$get3:1)),signalOrValueRef(config.legend.unselectedOpacity)]:_legendCmpt$get3&&($jscomp$destructuring$var155.opacity=signalOrValueRef(_legendCmpt$get3)));$jscomp$destructuring$var155=Object.assign({},$jscomp$destructuring$var155,symbolsSpec);return isEmpty($jscomp$destructuring$var155)?void 0:$jscomp$destructuring$var155}},gradient:function(gradientSpec,
$jscomp$destructuring$var156){var {model,legendType,legendCmpt}=$jscomp$destructuring$var156,_legendCmpt$get4;if("gradient"===legendType){var {config,markDef,encoding}=model;$jscomp$destructuring$var156={};var opacity=void 0===(null!==(_legendCmpt$get4=legendCmpt.get("gradientOpacity"))&&void 0!==_legendCmpt$get4?_legendCmpt$get4:config.legend.gradientOpacity)?getMaxValue(encoding.opacity)||markDef.opacity:void 0;opacity&&($jscomp$destructuring$var156.opacity=signalOrValueRef(opacity));$jscomp$destructuring$var156=
Object.assign({},$jscomp$destructuring$var156,gradientSpec);return isEmpty($jscomp$destructuring$var156)?void 0:$jscomp$destructuring$var156}},labels:function(specifiedlabelsSpec,$jscomp$destructuring$var157){var {fieldOrDatumDef,model,channel,legendCmpt}=$jscomp$destructuring$var157;$jscomp$destructuring$var157=model.legend(channel)||{};const config=model.config;var condition=isFieldDef(fieldOrDatumDef)?selectedCondition(model,legendCmpt,fieldOrDatumDef):void 0;condition=condition?[{test:condition,
value:1},{value:config.legend.unselectedOpacity}]:void 0;const {format,formatType}=$jscomp$destructuring$var157;$jscomp$destructuring$var157=isCustomFormatType(formatType)?formatCustomType({fieldOrDatumDef,field:"datum.value",format,formatType,config}):void 0;specifiedlabelsSpec=Object.assign({},condition?{opacity:condition}:{},$jscomp$destructuring$var157?{text:$jscomp$destructuring$var157}:{},specifiedlabelsSpec);return isEmpty(specifiedlabelsSpec)?void 0:specifiedlabelsSpec},entries:function(entriesSpec,
$jscomp$destructuring$var158){({legendCmpt:$jscomp$destructuring$var158}=$jscomp$destructuring$var158);$jscomp$destructuring$var158=$jscomp$destructuring$var158.get("selections");return(null===$jscomp$destructuring$var158||void 0===$jscomp$destructuring$var158?0:$jscomp$destructuring$var158.length)?Object.assign({},entriesSpec,{fill:{value:"transparent"}}):entriesSpec}},legendRules={direction:$jscomp$destructuring$var159=>{({direction:$jscomp$destructuring$var159}=$jscomp$destructuring$var159);return $jscomp$destructuring$var159},
format:$jscomp$destructuring$var160=>{var {fieldOrDatumDef,legend,config}=$jscomp$destructuring$var160;const {format,formatType}=legend;return guideFormat(fieldOrDatumDef,fieldOrDatumDef.type,format,formatType,config,!1)},formatType:$jscomp$destructuring$var161=>{var {legend,fieldOrDatumDef,scaleType}=$jscomp$destructuring$var161;({formatType:$jscomp$destructuring$var161}=legend);return guideFormatType($jscomp$destructuring$var161,fieldOrDatumDef,scaleType)},gradientLength:params=>{var _ref,_legend$gradientLengt;
const {legend,legendConfig}=params;if(null!==(_ref=null!==(_legend$gradientLengt=legend.gradientLength)&&void 0!==_legend$gradientLengt?_legend$gradientLengt:legendConfig.gradientLength)&&void 0!==_ref)params=_ref;else{{var {legendConfig:legendConfig$jscomp$0,model,direction,orient,scaleType}=params;const {gradientHorizontalMaxLength,gradientHorizontalMinLength,gradientVerticalMaxLength,gradientVerticalMinLength}=legendConfig$jscomp$0;params=scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX?"horizontal"===
direction?"top"===orient||"bottom"===orient?gradientLengthSignal(model,"width",gradientHorizontalMinLength,gradientHorizontalMaxLength):gradientHorizontalMinLength:gradientLengthSignal(model,"height",gradientVerticalMinLength,gradientVerticalMaxLength):void 0}}return params},labelOverlap:$jscomp$destructuring$var162=>{var {legend,legendConfig,scaleType}=$jscomp$destructuring$var162,_ref2,_legend$labelOverlap;$jscomp$destructuring$var162=null!==(_ref2=null!==(_legend$labelOverlap=legend.labelOverlap)&&
void 0!==_legend$labelOverlap?_legend$labelOverlap:legendConfig.labelOverlap)&&void 0!==_ref2?_ref2:contains(["quantile","threshold","log","symlog"],scaleType)?"greedy":void 0;return $jscomp$destructuring$var162},symbolType:$jscomp$destructuring$var163=>{var {legend,markDef,channel,encoding}=$jscomp$destructuring$var163,_legend$symbolType;if(null!==(_legend$symbolType=legend.symbolType)&&void 0!==_legend$symbolType)var JSCompiler_temp=_legend$symbolType;else a:{$jscomp$destructuring$var163=markDef.type;
_legend$symbolType=markDef.shape;if("shape"!==channel&&(_legend$symbolType=null!==(JSCompiler_temp=getFirstConditionValue(encoding.shape))&&void 0!==JSCompiler_temp?JSCompiler_temp:_legend$symbolType)){JSCompiler_temp=_legend$symbolType;break a}switch($jscomp$destructuring$var163){case "bar":case "rect":case "image":case "square":JSCompiler_temp="square";break a;case "line":case "trail":case "rule":JSCompiler_temp="stroke";break a;case "arc":case "point":case "circle":case "tick":case "geoshape":case "area":case "text":JSCompiler_temp=
"circle";break a}JSCompiler_temp=void 0}return JSCompiler_temp},title:$jscomp$destructuring$var164=>{var {fieldOrDatumDef,config}=$jscomp$destructuring$var164;return title$jscomp$0(fieldOrDatumDef,config,{allowDisabling:!0})},type:$jscomp$destructuring$var165=>{var {legendType,scaleType,channel}=$jscomp$destructuring$var165;if(isColorChannel(channel)&&scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX){if("gradient"===legendType)return}else if("symbol"===legendType)return;return legendType},values:$jscomp$destructuring$var166=>
{var {fieldOrDatumDef,legend}=$jscomp$destructuring$var166;$jscomp$destructuring$var166=legend.values;$jscomp$destructuring$var166=isArray($jscomp$destructuring$var166)?valueArray(fieldOrDatumDef,$jscomp$destructuring$var166):isSignalRef($jscomp$destructuring$var166)?$jscomp$destructuring$var166:void 0;return $jscomp$destructuring$var166}},PROJECTION_PROPERTIES="type clipAngle clipExtent center rotate precision reflectX reflectY coefficient distance fraction lobes parallel radius ratio spacing tilt".split(" ");
class ProjectionComponent extends Split{constructor(name,specifiedProjection,size,data){super(Object.assign({},specifiedProjection),{name});this.specifiedProjection=specifiedProjection;this.size=size;this.data=data;_defineProperty(this,"merged",!1)}get isFit(){return!!this.data}}class BinNode extends DataFlowNode{clone(){return new BinNode(null,duplicate(this.bins))}constructor(parent,bins){super(parent);this.bins=bins}static makeFromEncoding(parent,model){const bins=model.reduceFieldDef((binComponentIndex,
fieldDef,channel)=>{if(isTypedFieldDef(fieldDef)&&isBinning(fieldDef.bin)){const {key,binComponent}=createBinComponent(fieldDef,fieldDef.bin,model);binComponentIndex[key]=Object.assign({},binComponent,binComponentIndex[key],rangeFormula(model,fieldDef,channel,model.config))}return binComponentIndex},{});return isEmpty(bins)?null:new BinNode(parent,bins)}static makeFromTransform(parent,t,model){const {key,binComponent}=createBinComponent(t,t.bin,model);return new BinNode(parent,{[key]:binComponent})}merge(other,
renameSignal){for(const key of keys$jscomp$0(other.bins))key in this.bins?(renameSignal(other.bins[key].signal,this.bins[key].signal),this.bins[key].as=unique([...this.bins[key].as,...other.bins[key].as],hash)):this.bins[key]=other.bins[key];for(const child of other.children)other.removeChild(child),child.parent=this;other.remove()}producedFields(){return new Set(vals$jscomp$0(this.bins).map(c=>c.as).flat(2))}dependentFields(){return new Set(vals$jscomp$0(this.bins).map(c=>c.field))}hash(){return"Bin ".concat(hash(this.bins))}assemble(){return vals$jscomp$0(this.bins).flatMap(bin=>
{const transform=[],[binAs,...remainingAs]=bin.as;var $jscomp$destructuring$var172=bin.bin,$jscomp$destructuring$var173=Object.assign({},$jscomp$destructuring$var172);$jscomp$destructuring$var172=$jscomp$destructuring$var172.extent;$jscomp$destructuring$var173=(delete $jscomp$destructuring$var173.extent,$jscomp$destructuring$var173);$jscomp$destructuring$var173=Object.assign({},{type:"bin",field:replacePathInField(bin.field),as:binAs,signal:bin.signal},isSelectionExtent($jscomp$destructuring$var172)?
{extent:null}:{extent:$jscomp$destructuring$var172},bin.span?{span:{signal:"span(".concat(bin.span,")")}}:{},$jscomp$destructuring$var173);!$jscomp$destructuring$var172&&bin.extentSignal&&(transform.push({type:"extent",field:replacePathInField(bin.field),signal:bin.extentSignal}),$jscomp$destructuring$var173.extent={signal:bin.extentSignal});transform.push($jscomp$destructuring$var173);for(const as of remainingAs)for($jscomp$destructuring$var172=0;2>$jscomp$destructuring$var172;$jscomp$destructuring$var172++)transform.push({type:"formula",
expr:vgField({field:binAs[$jscomp$destructuring$var172]},{expr:"datum"}),as:as[$jscomp$destructuring$var172]});bin.formula&&transform.push({type:"formula",expr:bin.formula,as:bin.formulaAs});return transform})}}class AggregateNode extends DataFlowNode{clone(){return new AggregateNode(null,new Set(this.dimensions),duplicate(this.measures))}constructor(parent,dimensions,measures){super(parent);this.dimensions=dimensions;this.measures=measures}get groupBy(){return this.dimensions}static makeFromEncoding(parent,
model){let isAggregate=!1;model.forEachFieldDef(fd=>{fd.aggregate&&(isAggregate=!0)});const meas={},dims=new Set;if(!isAggregate)return null;model.forEachFieldDef((fieldDef,channel)=>{const {aggregate,field}=fieldDef;if(aggregate)if("count"===aggregate){var _meas$;meas["*"]=null!==(_meas$=meas["*"])&&void 0!==_meas$?_meas$:{};meas["*"].count=new Set([vgField(fieldDef,{forAs:!0})])}else{if(isArgminDef(aggregate)||isArgmaxDef(aggregate)){var _meas$argField;fieldDef=isArgminDef(aggregate)?"argmin":"argmax";
_meas$=aggregate[fieldDef];meas[_meas$]=null!==(_meas$argField=meas[_meas$])&&void 0!==_meas$argField?_meas$argField:{};meas[_meas$][fieldDef]=new Set([vgField({op:fieldDef,field:_meas$},{forAs:!0})])}else{var _meas$field;meas[field]=null!==(_meas$field=meas[field])&&void 0!==_meas$field?_meas$field:{};meas[field][aggregate]=new Set([vgField(fieldDef,{forAs:!0})])}if(SCALE_CHANNEL_INDEX[channel]&&"unaggregated"===model.scaleDomain(channel)){var _meas$field2;meas[field]=null!==(_meas$field2=meas[field])&&
void 0!==_meas$field2?_meas$field2:{};meas[field].min=new Set([vgField({field,aggregate:"min"},{forAs:!0})]);meas[field].max=new Set([vgField({field,aggregate:"max"},{forAs:!0})])}}else _meas$argField=isUnitModel(model)?model.encoding[getSecondaryRangeChannel(channel)]:void 0,isTypedFieldDef(fieldDef)&&isUnitModel(model)&&hasBand(channel,fieldDef,_meas$argField,model.stack,model.markDef,model.config)?(dims.add(vgField(fieldDef,{})),dims.add(vgField(fieldDef,{suffix:"end"})),fieldDef.bin&&binRequiresRange(fieldDef,
channel)&&dims.add(vgField(fieldDef,{binSuffix:"range"}))):channel in GEO_POSIITON_CHANNEL_INDEX?(channel=getPositionChannelFromLatLong(channel),dims.add(model.getName(channel))):dims.add(vgField(fieldDef))});return 0===dims.size+keys$jscomp$0(meas).length?null:new AggregateNode(parent,dims,meas)}static makeFromTransform(parent,t){const dims=new Set,meas={};for(const s of t.aggregate){const {op,field,as}=s;if(op)if("count"===op){var _meas$2;meas["*"]=null!==(_meas$2=meas["*"])&&void 0!==_meas$2?_meas$2:
{};meas["*"].count=new Set([as?as:vgField(s,{forAs:!0})])}else{var _meas$field3;meas[field]=null!==(_meas$field3=meas[field])&&void 0!==_meas$field3?_meas$field3:{};meas[field][op]=new Set([as?as:vgField(s,{forAs:!0})])}}for(const s of null!==(_t$groupby=t.groupby)&&void 0!==_t$groupby?_t$groupby:[]){var _t$groupby;dims.add(s)}return 0===dims.size+keys$jscomp$0(meas).length?null:new AggregateNode(parent,dims,meas)}merge(other){if(setEqual(this.dimensions,other.dimensions)){var parentMeasures=this.measures;
other=other.measures;for(const field of keys$jscomp$0(other)){const ops=other[field];for(const op of keys$jscomp$0(ops))if(field in parentMeasures){var _parentMeasures$field;parentMeasures[field][op]=new Set([...null!==(_parentMeasures$field=parentMeasures[field][op])&&void 0!==_parentMeasures$field?_parentMeasures$field:[],...ops[op]])}else parentMeasures[field]={[op]:ops[op]}}return!0}current.debug(...["different dimensions, cannot merge"]);return!1}addDimensions(fields){fields.forEach(this.dimensions.add,
this.dimensions)}dependentFields(){return new Set([...this.dimensions,...keys$jscomp$0(this.measures)])}producedFields(){const out=new Set;for(const field of keys$jscomp$0(this.measures))for(const op of keys$jscomp$0(this.measures[field])){const m=this.measures[field][op];0===m.size?out.add("".concat(op,"_").concat(field)):m.forEach(out.add,out)}return out}hash(){return"Aggregate ".concat(hash({dimensions:this.dimensions,measures:this.measures}))}assemble(){const ops=[],fields=[],as=[];for(const field of keys$jscomp$0(this.measures))for(const op of keys$jscomp$0(this.measures[field]))for(const alias of this.measures[field][op])as.push(alias),
ops.push(op),fields.push("*"===field?null:replacePathInField(field));return{type:"aggregate",groupby:[...this.dimensions].map(replacePathInField),ops,fields,as}}}class FacetNode extends DataFlowNode{constructor(parent,model,name,data){super(parent);this.model=model;this.name=name;this.data=data;_defineProperty(this,"column",void 0);_defineProperty(this,"row",void 0);_defineProperty(this,"facet",void 0);_defineProperty(this,"childModel",void 0);for(const channel of FACET_CHANNELS)if(parent=model.facet[channel]){const {bin,
sort}=parent;this[channel]=Object.assign({},{name:model.getName("".concat(channel,"_domain")),fields:[vgField(parent),...isBinning(bin)?[vgField(parent,{binSuffix:"end"})]:[]]},isSortField(sort)?{sortField:sort}:isArray(sort)?{sortIndexField:sortArrayIndexField(parent,channel)}:{})}this.childModel=model.child}hash(){let out="Facet";for(const channel of FACET_CHANNELS)this[channel]&&(out+=" ".concat(channel.charAt(0),":").concat(hash(this[channel])));return out}get fields(){const f=[];for(const channel of FACET_CHANNELS){var _this$channel;
(null===(_this$channel=this[channel])||void 0===_this$channel?0:_this$channel.fields)&&f.push(...this[channel].fields)}return f}dependentFields(){const depFields=new Set(this.fields);for(const channel of FACET_CHANNELS)this[channel]&&(this[channel].sortField&&depFields.add(this[channel].sortField.field),this[channel].sortIndexField&&depFields.add(this[channel].sortIndexField));return depFields}producedFields(){return new Set}getSource(){return this.name}getChildIndependentFieldsWithStep(){const childIndependentFieldsWithStep=
{};for(const channel of POSITION_SCALE_CHANNELS){var childScaleComponent=this.childModel.component.scales[channel];if(childScaleComponent&&!childScaleComponent.merged){var type=childScaleComponent.get("type");childScaleComponent=childScaleComponent.get("range");type in DISCRETE_DOMAIN_INDEX&&isVgRangeStep(childScaleComponent)&&(type=assembleDomain(this.childModel,channel),(type=getFieldFromDomain(type))?childIndependentFieldsWithStep[channel]=type:warn(unknownField(channel)))}}return childIndependentFieldsWithStep}assembleRowColumnHeaderData(channel,
crossedDataName,childIndependentFieldsWithStep){const childChannel={row:"y",column:"x"}[channel],fields=[],ops=[],as=[];childIndependentFieldsWithStep&&childIndependentFieldsWithStep[childChannel]&&(crossedDataName?(fields.push("distinct_".concat(childIndependentFieldsWithStep[childChannel])),ops.push("max")):(fields.push(childIndependentFieldsWithStep[childChannel]),ops.push("distinct")),as.push("distinct_".concat(childIndependentFieldsWithStep[childChannel])));const {sortField,sortIndexField}=this[channel];
if(sortField){const {op="min",field}=sortField;fields.push(field);ops.push(op);as.push(vgField(sortField,{forAs:!0}))}else sortIndexField&&(fields.push(sortIndexField),ops.push("max"),as.push(sortIndexField));return{name:this[channel].name,source:null!==crossedDataName&&void 0!==crossedDataName?crossedDataName:this.data,transform:[Object.assign({},{type:"aggregate",groupby:this[channel].fields},fields.length?{fields,ops,as}:{})]}}assembleFacetHeaderData(childIndependentFieldsWithStep){const {columns}=
this.model.layout,{layoutHeaders}=this.model.component,data=[],hasSharedAxis={};for(const headerChannel of HEADER_CHANNELS){for(const headerType of HEADER_TYPES){var _ref,headers=null!==(_ref=layoutHeaders[headerChannel]&&layoutHeaders[headerChannel][headerType])&&void 0!==_ref?_ref:[];for(const header of headers){var _header$axes;if(0<(null===(_header$axes=header.axes)||void 0===_header$axes?void 0:_header$axes.length)){hasSharedAxis[headerChannel]=!0;break}}}hasSharedAxis[headerChannel]&&(headers=
'length(data("'.concat(this.facet.name,'"))'),headers="row"===headerChannel?columns?{signal:"ceil(".concat(headers," / ").concat(columns,")")}:1:columns?{signal:"min(".concat(headers,", ").concat(columns,")")}:{signal:headers},data.push({name:"".concat(this.facet.name,"_").concat(headerChannel),transform:[{type:"sequence",start:0,stop:headers}]}))}const {row,column}=hasSharedAxis;(row||column)&&data.unshift(this.assembleRowColumnHeaderData("facet",null,childIndependentFieldsWithStep));return data}assemble(){const data=
[];var crossedDataName=null;const childIndependentFieldsWithStep=this.getChildIndependentFieldsWithStep(),{column,row,facet}=this;if(column&&row&&(childIndependentFieldsWithStep.x||childIndependentFieldsWithStep.y)){var _childIndependentFiel,_childIndependentFiel2;crossedDataName="cross_".concat(this.column.name,"_").concat(this.row.name);const fields=[].concat(null!==(_childIndependentFiel=childIndependentFieldsWithStep.x)&&void 0!==_childIndependentFiel?_childIndependentFiel:[],null!==(_childIndependentFiel2=
childIndependentFieldsWithStep.y)&&void 0!==_childIndependentFiel2?_childIndependentFiel2:[]);_childIndependentFiel=fields.map(()=>"distinct");data.push({name:crossedDataName,source:this.data,transform:[{type:"aggregate",groupby:this.fields,fields,ops:_childIndependentFiel}]})}for(const channel of["column","row"])this[channel]&&data.push(this.assembleRowColumnHeaderData(channel,crossedDataName,childIndependentFieldsWithStep));facet&&(crossedDataName=this.assembleFacetHeaderData(childIndependentFieldsWithStep))&&
data.push(...crossedDataName);return data}}class ParseNode extends DataFlowNode{clone(){return new ParseNode(null,duplicate(this._parse))}constructor(parent,parse){super(parent);_defineProperty(this,"_parse",void 0);this._parse=parse}hash(){return"Parse ".concat(hash(this._parse))}static makeExplicit(parent,model,ancestorParse){let explicit={};model=model.data;!isGenerator(model)&&model&&model.format&&model.format.parse&&(explicit=model.format.parse);return this.makeWithAncestors(parent,explicit,
{},ancestorParse)}static makeWithAncestors(parent,explicit,implicit,ancestorParse){for(var field of keys$jscomp$0(implicit)){const parsedAs=ancestorParse.getWithExplicit(field);void 0!==parsedAs.value&&(parsedAs.explicit||parsedAs.value===implicit[field]||"derived"===parsedAs.value||"flatten"===implicit[field]?delete implicit[field]:warn(differentParse(field,implicit[field],parsedAs.value)))}for(var field$jscomp$0 of keys$jscomp$0(explicit))field=ancestorParse.get(field$jscomp$0),void 0!==field&&
(field===explicit[field$jscomp$0]?delete explicit[field$jscomp$0]:warn(differentParse(field$jscomp$0,explicit[field$jscomp$0],field)));explicit=new Split(explicit,implicit);ancestorParse.copyAll(explicit);implicit={};for(const key of keys$jscomp$0(explicit.combine()))field$jscomp$0=explicit.get(key),null!==field$jscomp$0&&(implicit[key]=field$jscomp$0);return 0===keys$jscomp$0(implicit).length||ancestorParse.parseNothing?null:new ParseNode(parent,implicit)}get parse(){return this._parse}merge(other){this._parse=
Object.assign({},this._parse,other.parse);other.remove()}assembleFormatParse(){const formatParse={};for(const field of keys$jscomp$0(this._parse)){const p=this._parse[field];1===accessPathDepth(field)&&(formatParse[field]=p)}return formatParse}producedFields(){return new Set(keys$jscomp$0(this._parse))}dependentFields(){return new Set(keys$jscomp$0(this._parse))}assembleTransforms(onlyNested){onlyNested=void 0===onlyNested?!1:onlyNested;return keys$jscomp$0(this._parse).filter(field=>onlyNested?1<
accessPathDepth(field):!0).map(field=>{const expr=parseExpression$1(field,this._parse[field]);return expr?{type:"formula",expr,as:removePathFromField(field)}:null}).filter(t=>null!==t)}}class IdentifierNode extends DataFlowNode{clone(){return new IdentifierNode(null)}constructor(parent){super(parent)}dependentFields(){return new Set}producedFields(){return new Set(["_vgsid_"])}hash(){return"Identifier"}assemble(){return{type:"identifier",as:"_vgsid_"}}}class GraticuleNode extends DataFlowNode{clone(){return new GraticuleNode(null,
this.params)}constructor(parent,params){super(parent);this.params=params}dependentFields(){return new Set}producedFields(){}hash(){return"Graticule ".concat(hash(this.params))}assemble(){return Object.assign({},{type:"graticule"},!0===this.params?{}:this.params)}}class SequenceNode extends DataFlowNode{clone(){return new SequenceNode(null,this.params)}constructor(parent,params){super(parent);this.params=params}dependentFields(){return new Set}producedFields(){var _this$params$as;return new Set([null!==
(_this$params$as=this.params.as)&&void 0!==_this$params$as?_this$params$as:"data"])}hash(){return"Hash ".concat(hash(this.params))}assemble(){return Object.assign({},{type:"sequence"},this.params)}}class SourceNode extends DataFlowNode{constructor(data){var _data;super(null);_defineProperty(this,"_data",void 0);_defineProperty(this,"_name",void 0);_defineProperty(this,"_generator",void 0);data=null!==(_data=data)&&void 0!==_data?_data:{name:"source"};let format;isGenerator(data)||(format=data.format?
Object.assign({},omit(data.format,["parse"])):{});if("values"in data)this._data={values:data.values};else if("url"in data)this._data={url:data.url},format.type||(_data=/(?:\.([^.]+))?$/.exec(data.url)[1],contains(["json","csv","tsv","dsv","topojson"],_data)||(_data="json"),format.type=_data);else if("sphere"in data)this._data={values:[{type:"Sphere"}]};else if(isNamedData(data)||isGenerator(data))this._data={};this._generator=isGenerator(data);data.name&&(this._name=data.name);format&&!isEmpty(format)&&
(this._data.format=format)}dependentFields(){return new Set}producedFields(){}get data(){return this._data}hasName(){return!!this._name}get isGenerator(){return this._generator}get dataName(){return this._name}set dataName(name){this._name=name}set parent(parent){throw Error("Source nodes have to be roots.");}remove(){throw Error("Source nodes are roots and cannot be removed.");}hash(){throw Error("Cannot hash sources");}assemble(){return Object.assign({},{name:this._name},this._data,{transform:[]})}}
var _modified=new WeakMap;class Optimizer{constructor(){_modified.set(this,{writable:!0,value:void 0});_classPrivateFieldSet(this,_modified,!1)}setModified(){_classPrivateFieldSet(this,_modified,!0)}get modifiedFlag(){var JSCompiler_inline_result=_modified.get(this);if(!JSCompiler_inline_result)throw new TypeError("attempted to get private field on non-instance");JSCompiler_inline_result=JSCompiler_inline_result.get?JSCompiler_inline_result.get.call(this):JSCompiler_inline_result.value;return JSCompiler_inline_result}}
class BottomUpOptimizer extends Optimizer{getNodeDepths(node,depth,depths){depths.set(node,depth);for(const child of node.children)this.getNodeDepths(child,depth+1,depths);return depths}optimize(node){node=[...this.getNodeDepths(node,0,new Map).entries()].sort((a,b)=>b[1]-a[1]);for(const tuple of node)this.run(tuple[0]);return this.modifiedFlag}}class TopDownOptimizer extends Optimizer{optimize(node){this.run(node);for(const child of node.children)this.optimize(child);return this.modifiedFlag}}class MergeIdenticalNodes extends TopDownOptimizer{mergeNodes(parent,
nodes){const mergedNode=nodes.shift();for(const node of nodes)parent.removeChild(node),node.parent=mergedNode,node.remove()}run(node){const hashes=node.children.map(x=>x.hash()),buckets={};for(let i=0;i<hashes.length;i++)void 0===buckets[hashes[i]]?buckets[hashes[i]]=[node.children[i]]:buckets[hashes[i]].push(node.children[i]);for(const k of keys$jscomp$0(buckets))1<buckets[k].length&&(this.setModified(),this.mergeNodes(node,buckets[k]))}}class RemoveUnnecessaryIdentifierNodes extends TopDownOptimizer{constructor(model){super();
_defineProperty(this,"requiresSelectionId",void 0);this.requiresSelectionId=model&&requiresSelectionId(model)}run(node){!(node instanceof IdentifierNode)||this.requiresSelectionId&&(isDataSourceNode(node.parent)||node.parent instanceof AggregateNode||node.parent instanceof ParseNode)||(this.setModified(),node.remove())}}class RemoveDuplicateTimeUnits extends Optimizer{optimize(node){this.run(node,new Set);return this.modifiedFlag}run(node,timeUnitFields){let producedFields=new Set;node instanceof
TimeUnitNode&&(producedFields=node.producedFields(),hasIntersection(producedFields,timeUnitFields)&&(this.setModified(),node.removeFormulas(timeUnitFields),0===node.producedFields.length&&node.remove()));for(const child of node.children)this.run(child,new Set([...timeUnitFields,...producedFields]))}}class RemoveUnnecessaryOutputNodes extends TopDownOptimizer{constructor(){super()}run(node){node instanceof OutputNode&&!node.isRequired()&&(this.setModified(),node.remove())}}class MoveParseUp extends BottomUpOptimizer{run(node){if(!(isDataSourceNode(node)||
1<node.numChildren()))for(const child of node.children)child instanceof ParseNode&&(node instanceof ParseNode?(this.setModified(),node.merge(child)):fieldIntersection(node.producedFields(),child.dependentFields())||(this.setModified(),child.swapWithParent()))}}class MergeParse extends BottomUpOptimizer{run(node){const originalChildren=[...node.children];var parseChildren=node.children.filter(child=>child instanceof ParseNode);if(1<node.numChildren()&&1<=parseChildren.length){const commonParse={};
var conflictingParse=new Set;for(const parseNode of parseChildren){parseChildren=parseNode.parse;for(const k of keys$jscomp$0(parseChildren))k in commonParse?commonParse[k]!==parseChildren[k]&&conflictingParse.add(k):commonParse[k]=parseChildren[k]}for(const field of conflictingParse)delete commonParse[field];if(!isEmpty(commonParse)){this.setModified();conflictingParse=new ParseNode(node,commonParse);for(const childNode of originalChildren){if(childNode instanceof ParseNode)for(const key of keys$jscomp$0(commonParse))delete childNode.parse[key];
node.removeChild(childNode);childNode.parent=conflictingParse;childNode instanceof ParseNode&&0===keys$jscomp$0(childNode.parse).length&&childNode.remove()}}}}}class RemoveUnusedSubtrees extends BottomUpOptimizer{run(node){node instanceof OutputNode||0<node.numChildren()||node instanceof FacetNode||node instanceof SourceNode||(this.setModified(),node.remove())}}class MergeTimeUnits extends BottomUpOptimizer{run(node){node=node.children.filter(x=>x instanceof TimeUnitNode);const combination=node.pop();
for(const timeUnit of node)this.setModified(),combination.merge(timeUnit)}}class MergeAggregates extends BottomUpOptimizer{run(node){var aggChildren=node.children.filter(child=>child instanceof AggregateNode);const groupedAggregates={};for(var agg$jscomp$0 of aggChildren)aggChildren=hash(agg$jscomp$0.groupBy),aggChildren in groupedAggregates||(groupedAggregates[aggChildren]=[]),groupedAggregates[aggChildren].push(agg$jscomp$0);for(const group of keys$jscomp$0(groupedAggregates))if(agg$jscomp$0=groupedAggregates[group],
1<agg$jscomp$0.length){aggChildren=agg$jscomp$0.pop();for(const agg of agg$jscomp$0)aggChildren.merge(agg)&&(node.removeChild(agg),agg.parent=aggChildren,agg.remove(),this.setModified())}}}class MergeBins extends BottomUpOptimizer{constructor(model){super();this.model=model}run(node){var moveBinsUp=!(isDataSourceNode(node)||node instanceof FilterNode||node instanceof ParseNode||node instanceof IdentifierNode);const promotableBins=[],remainingBins=[];for(const child of node.children)child instanceof
BinNode&&(moveBinsUp&&!fieldIntersection(node.producedFields(),child.dependentFields())?promotableBins.push(child):remainingBins.push(child));if(0<promotableBins.length){moveBinsUp=promotableBins.pop();for(const bin of promotableBins)moveBinsUp.merge(bin,this.model.renameSignal.bind(this.model));this.setModified();node instanceof BinNode?node.merge(moveBinsUp,this.model.renameSignal.bind(this.model)):moveBinsUp.swapWithParent()}if(1<remainingBins.length){node=remainingBins.pop();for(const bin of remainingBins)node.merge(bin,
this.model.renameSignal.bind(this.model));this.setModified()}}}class MergeOutputs extends BottomUpOptimizer{run(node){var children=[...node.children];if(some(children,child=>child instanceof OutputNode)&&!(1>=node.numChildren())){var otherChildren=[];for(const child of children)if(child instanceof OutputNode){for(children=child;1===children.numChildren();){const [theChild]=children.children;if(theChild instanceof OutputNode)children=theChild;else break}otherChildren.push(...children.children);if(mainOutput)node.removeChild(child),
child.parent=mainOutput.parent,mainOutput.parent.removeChild(mainOutput),mainOutput.parent=children,this.setModified();else var mainOutput=children}else otherChildren.push(child);if(otherChildren.length){this.setModified();for(const child of otherChildren)child.parent.removeChild(child),child.parent=mainOutput}}}}class JoinAggregateTransformNode extends DataFlowNode{clone(){return new JoinAggregateTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=
transform}addDimensions(fields){this.transform.groupby=unique(this.transform.groupby.concat(fields),d=>d)}dependentFields(){const out=new Set;this.transform.groupby&&this.transform.groupby.forEach(out.add,out);this.transform.joinaggregate.map(w=>w.field).filter(f=>void 0!==f).forEach(out.add,out);return out}producedFields(){return new Set(this.transform.joinaggregate.map(this.getDefaultName))}getDefaultName(joinAggregateFieldDef){var _joinAggregateFieldDe;return null!==(_joinAggregateFieldDe=joinAggregateFieldDef.as)&&
void 0!==_joinAggregateFieldDe?_joinAggregateFieldDe:vgField(joinAggregateFieldDef)}hash(){return"JoinAggregateTransform ".concat(hash(this.transform))}assemble(){const fields=[],ops=[],as=[];for(var joinaggregate of this.transform.joinaggregate)ops.push(joinaggregate.op),as.push(this.getDefaultName(joinaggregate)),fields.push(void 0===joinaggregate.field?null:joinaggregate.field);joinaggregate=this.transform.groupby;return Object.assign({},{type:"joinaggregate",as,ops,fields},void 0!==joinaggregate?
{groupby:joinaggregate}:{})}}class StackNode extends DataFlowNode{clone(){return new StackNode(null,duplicate(this._stack))}constructor(parent,stack){super(parent);_defineProperty(this,"_stack",void 0);this._stack=stack}static makeFromTransform(parent,stackTransform){const {stack,groupby,as,offset="zero"}=stackTransform;var sortFields=[];const sortOrder=[];if(void 0!==stackTransform.sort)for(const sortField of stackTransform.sort)sortFields.push(sortField.field),sortOrder.push(getFirstDefined(sortField.order,
"ascending"));sortFields={field:sortFields,order:sortOrder};stackTransform=isValidAsArray(as)?as:isString(as)?[as,as+"_end"]:[stackTransform.stack+"_start",stackTransform.stack+"_end"];return new StackNode(parent,{stackField:stack,groupby,offset,sort:sortFields,facetby:[],as:stackTransform})}static makeFromEncoding(parent,model){var stackProperties=model.stack,{encoding}=model;if(!stackProperties)return null;const {groupbyChannel,fieldChannel,offset,impute}=stackProperties;let dimensionFieldDef;groupbyChannel&&
(dimensionFieldDef=getFieldDef(encoding[groupbyChannel]));stackProperties=getStackByFields(model);encoding=model.encoding.order;encoding=isArray(encoding)||isFieldDef(encoding)?sortParams(encoding):stackProperties.reduce((s,field)=>{s.field.push(field);s.order.push("y"===fieldChannel?"descending":"ascending");return s},{field:[],order:[]});return new StackNode(parent,{dimensionFieldDef,stackField:model.vgField(fieldChannel),facetby:[],stackby:stackProperties,sort:encoding,offset,impute,as:[model.vgField(fieldChannel,
{suffix:"start",forAs:!0}),model.vgField(fieldChannel,{suffix:"end",forAs:!0})]})}get stack(){return this._stack}addDimensions(fields){this._stack.facetby.push(...fields)}dependentFields(){const out=new Set;out.add(this._stack.stackField);this.getGroupbyFields().forEach(out.add,out);this._stack.facetby.forEach(out.add,out);this._stack.sort.field.forEach(out.add,out);return out}producedFields(){return new Set(this._stack.as)}hash(){return"Stack ".concat(hash(this._stack))}getGroupbyFields(){const {dimensionFieldDef,
impute,groupby}=this._stack;return dimensionFieldDef?dimensionFieldDef.bin?impute?[vgField(dimensionFieldDef,{binSuffix:"mid"})]:[vgField(dimensionFieldDef,{}),vgField(dimensionFieldDef,{binSuffix:"end"})]:[vgField(dimensionFieldDef)]:null!==groupby&&void 0!==groupby?groupby:[]}assemble(){const transform=[],{facetby,dimensionFieldDef,stackField:field,stackby,sort,offset,impute,as}=this._stack;if(impute&&dimensionFieldDef){const {band=.5,bin}=dimensionFieldDef;bin&&transform.push({type:"formula",expr:"".concat(band,
"*")+vgField(dimensionFieldDef,{expr:"datum"})+"+".concat(1-band,"*")+vgField(dimensionFieldDef,{expr:"datum",binSuffix:"end"}),as:vgField(dimensionFieldDef,{binSuffix:"mid",forAs:!0})});transform.push({type:"impute",field,groupby:[...stackby,...facetby],key:vgField(dimensionFieldDef,{binSuffix:"mid"}),method:"value",value:0})}transform.push({type:"stack",groupby:[...this.getGroupbyFields(),...facetby],field,sort,as,offset});return transform}}class WindowTransformNode extends DataFlowNode{clone(){return new WindowTransformNode(null,
duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){this.transform.groupby=unique(this.transform.groupby.concat(fields),d=>d)}dependentFields(){var _this$transform$group,_this$transform$sort;const out=new Set;(null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[]).forEach(out.add,out);(null!==(_this$transform$sort=this.transform.sort)&&void 0!==_this$transform$sort?_this$transform$sort:
[]).forEach(m=>out.add(m.field));this.transform.window.map(w=>w.field).filter(f=>void 0!==f).forEach(out.add,out);return out}producedFields(){return new Set(this.transform.window.map(this.getDefaultName))}getDefaultName(windowFieldDef){var _windowFieldDef$as;return null!==(_windowFieldDef$as=windowFieldDef.as)&&void 0!==_windowFieldDef$as?_windowFieldDef$as:vgField(windowFieldDef)}hash(){return"WindowTransform ".concat(hash(this.transform))}assemble(){const fields=[],ops=[],as=[],params=[];for(var window of this.transform.window)ops.push(window.op),
as.push(this.getDefaultName(window)),params.push(void 0===window.param?null:window.param),fields.push(void 0===window.field?null:window.field);window=this.transform.frame;const groupby=this.transform.groupby;if(window&&null===window[0]&&null===window[1]&&ops.every(o=>isAggregateOp(o)))return Object.assign({},{type:"joinaggregate",as,ops,fields},void 0!==groupby?{groupby}:{});const sortFields=[],sortOrder=[];if(void 0!==this.transform.sort)for(const sortField of this.transform.sort){var _sortField$order;
sortFields.push(sortField.field);sortOrder.push(null!==(_sortField$order=sortField.order)&&void 0!==_sortField$order?_sortField$order:"ascending")}_sortField$order=this.transform.ignorePeers;return Object.assign({},{type:"window",params,as,ops,fields,sort:{field:sortFields,order:sortOrder}},void 0!==_sortField$order?{ignorePeers:_sortField$order}:{},void 0!==groupby?{groupby}:{},void 0!==window?{frame:window}:{})}}class SignalRefWrapper{constructor(exprGenerator){_defineProperty(this,"signal",void 0);
Object.defineProperty(this,"signal",{enumerable:!0,get:exprGenerator})}static fromName(rename,signalName){return new SignalRefWrapper(()=>rename(signalName))}}class ScaleComponent extends Split{constructor(name,typeWithExplicit){super({},{name});_defineProperty(this,"merged",!1);this.setWithExplicit("type",typeWithExplicit)}domainDefinitelyIncludesZero(){return!1!==this.get("zero")?!0:some(this.get("domains"),d=>isArray(d)&&2===d.length&&0>=d[0]&&0<=d[1])}}const RANGE_PROPERTIES=["range","scheme"],
scaleRules={bins:$jscomp$destructuring$var178=>{var {model,fieldOrDatumDef}=$jscomp$destructuring$var178;return isFieldDef(fieldOrDatumDef)?bins$jscomp$1(model,fieldOrDatumDef):void 0},interpolate:$jscomp$destructuring$var179=>{var {channel,fieldOrDatumDef}=$jscomp$destructuring$var179;$jscomp$destructuring$var179=fieldOrDatumDef.type;$jscomp$destructuring$var179=contains(["color","fill","stroke"],channel)&&"nominal"!==$jscomp$destructuring$var179?"hcl":void 0;return $jscomp$destructuring$var179},
nice:$jscomp$destructuring$var180=>{var {scaleType,channel,fieldOrDatumDef}=$jscomp$destructuring$var180;var _getFieldDef;$jscomp$destructuring$var180=(null===(_getFieldDef=getFieldDef(fieldOrDatumDef))||void 0===_getFieldDef?0:_getFieldDef.bin)||contains([ScaleType.TIME,ScaleType.UTC],scaleType)?void 0:channel in POSITION_SCALE_CHANNEL_INDEX?!0:void 0;return $jscomp$destructuring$var180},padding:$jscomp$destructuring$var181=>{var {channel,scaleType,fieldOrDatumDef,markDef,config}=$jscomp$destructuring$var181;
a:{$jscomp$destructuring$var181=config.scale;var barConfig=config.bar;if(channel in POSITION_SCALE_CHANNEL_INDEX){if(scaleType in CONTINUOUS_TO_CONTINUOUS_INDEX){if(void 0!==$jscomp$destructuring$var181.continuousPadding){$jscomp$destructuring$var181=$jscomp$destructuring$var181.continuousPadding;break a}const {type,orient}=markDef;if("bar"===type&&(!isFieldDef(fieldOrDatumDef)||!fieldOrDatumDef.bin&&!fieldOrDatumDef.timeUnit)&&("vertical"===orient&&"x"===channel||"horizontal"===orient&&"y"===channel)){$jscomp$destructuring$var181=
barConfig.continuousBandSize;break a}}if(scaleType===ScaleType.POINT){$jscomp$destructuring$var181=$jscomp$destructuring$var181.pointPadding;break a}}$jscomp$destructuring$var181=void 0}return $jscomp$destructuring$var181},paddingInner:$jscomp$destructuring$var182=>{var {scalePadding,channel,markDef,config}=$jscomp$destructuring$var182;if(void 0!==scalePadding)$jscomp$destructuring$var182=void 0;else if(channel in POSITION_SCALE_CHANNEL_INDEX){const {bandPaddingInner,barBandPaddingInner,rectBandPaddingInner}=
config.scale;$jscomp$destructuring$var182=getFirstDefined(bandPaddingInner,"bar"===markDef.type?barBandPaddingInner:rectBandPaddingInner)}else $jscomp$destructuring$var182=void 0;return $jscomp$destructuring$var182},paddingOuter:$jscomp$destructuring$var183=>{var {scalePadding,channel,scaleType,scalePaddingInner,config}=$jscomp$destructuring$var183;void 0!==scalePadding?$jscomp$destructuring$var183=void 0:channel in POSITION_SCALE_CHANNEL_INDEX&&scaleType===ScaleType.BAND?({bandPaddingOuter:$jscomp$destructuring$var183}=
config.scale,$jscomp$destructuring$var183=getFirstDefined($jscomp$destructuring$var183,isSignalRef(scalePaddingInner)?{signal:"".concat(scalePaddingInner.signal,"/2")}:scalePaddingInner/2)):$jscomp$destructuring$var183=void 0;return $jscomp$destructuring$var183},reverse:$jscomp$destructuring$var184=>{var {fieldOrDatumDef,scaleType,channel,config}=$jscomp$destructuring$var184;$jscomp$destructuring$var184=isFieldDef(fieldOrDatumDef)?fieldOrDatumDef.sort:void 0;var scaleConfig=config.scale;$jscomp$destructuring$var184=
"x"===channel&&void 0!==scaleConfig.xReverse?scaleType in CONTINUOUS_DOMAIN_INDEX&&"descending"===$jscomp$destructuring$var184?isSignalRef(scaleConfig.xReverse)?{signal:"!".concat(scaleConfig.xReverse.signal)}:!scaleConfig.xReverse:scaleConfig.xReverse:scaleType in CONTINUOUS_DOMAIN_INDEX&&"descending"===$jscomp$destructuring$var184?!0:void 0;return $jscomp$destructuring$var184},zero:$jscomp$destructuring$var185=>{var {channel,fieldOrDatumDef,domain,markDef,scaleType}=$jscomp$destructuring$var185;
a:if(domain&&"unaggregated"!==domain&&scaleType in CONTINUOUS_DOMAIN_INDEX){if(isArray(domain)&&($jscomp$destructuring$var185=domain[domain.length-1],0>=domain[0]&&0<=$jscomp$destructuring$var185)){$jscomp$destructuring$var185=!0;break a}$jscomp$destructuring$var185=!1}else if("size"!==channel||"quantitative"!==fieldOrDatumDef.type||scaleType in CONTINUOUS_TO_DISCRETE_INDEX)if(isFieldDef(fieldOrDatumDef)&&fieldOrDatumDef.bin||!contains([...POSITION_SCALE_CHANNELS,...POLAR_POSITION_SCALE_CHANNELS],
channel))$jscomp$destructuring$var185=!1;else{const {orient,type}=markDef;$jscomp$destructuring$var185=contains(["bar","area","line","trail"],type)&&("horizontal"===orient&&"y"===channel||"vertical"===orient&&"x"===channel)?!1:!0}else $jscomp$destructuring$var185=!0;return $jscomp$destructuring$var185}},scaleTypeTieBreaker=tieBreakByComparing((st1,st2)=>SCALE_PRECEDENCE_INDEX[st1]-SCALE_PRECEDENCE_INDEX[st2]);class NameMap{constructor(){_defineProperty(this,"nameMap",void 0);this.nameMap={}}rename(oldName,
newName){this.nameMap[oldName]=newName}has(name){return void 0!==this.nameMap[name]}get(name){for(;this.nameMap[name]&&name!==this.nameMap[name];)name=this.nameMap[name];return name}}class Model{constructor(spec,type,parent,parentGivenName,config,resolve,view){var _spec$name,_spec$transform;this.type=type;this.parent=parent;this.config=config;_defineProperty(this,"name",void 0);_defineProperty(this,"size",void 0);_defineProperty(this,"title",void 0);_defineProperty(this,"description",void 0);_defineProperty(this,
"data",void 0);_defineProperty(this,"transforms",void 0);_defineProperty(this,"layout",void 0);_defineProperty(this,"scaleNameMap",void 0);_defineProperty(this,"projectionNameMap",void 0);_defineProperty(this,"signalNameMap",void 0);_defineProperty(this,"component",void 0);_defineProperty(this,"view",void 0);_defineProperty(this,"children",[]);_defineProperty(this,"correctDataNames",mark=>{mark.from&&mark.from.data&&(mark.from.data=this.lookupDataSource(mark.from.data));mark.from&&mark.from.facet&&
mark.from.facet.data&&(mark.from.facet.data=this.lookupDataSource(mark.from.facet.data));return mark});this.parent=parent;this.config=config;this.view=replaceExprRefInIndex(view);this.name=null!==(_spec$name=spec.name)&&void 0!==_spec$name?_spec$name:parentGivenName;this.title=isText(spec.title)?{text:spec.title}:spec.title?this.initTitle(spec.title):void 0;this.scaleNameMap=parent?parent.scaleNameMap:new NameMap;this.projectionNameMap=parent?parent.projectionNameMap:new NameMap;this.signalNameMap=
parent?parent.signalNameMap:new NameMap;this.data=spec.data;this.description=spec.description;this.transforms=normalizeTransform(null!==(_spec$transform=spec.transform)&&void 0!==_spec$transform?_spec$transform:[]);this.layout="layer"===type||"unit"===type?{}:extractCompositionLayout(spec,type,config);this.component={data:{sources:parent?parent.component.data.sources:[],outputNodes:parent?parent.component.data.outputNodes:{},outputNodeRefCounts:parent?parent.component.data.outputNodeRefCounts:{},
isFaceted:"facet"in spec||parent&&parent.component.data.isFaceted&&void 0===spec.data},layoutSize:new Split,layoutHeaders:{row:{},column:{},facet:{}},mark:null,resolve:Object.assign({},{scale:{},axis:{},legend:{}},resolve?duplicate(resolve):{}),selection:null,scales:null,projection:null,axes:{},legends:{}}}initTitle(title){const props=keys$jscomp$0(title),titleInternal={text:signalRefOrValue(title.text)};for(const prop of props)titleInternal[prop]=signalRefOrValue(title[prop]);return titleInternal}get width(){return this.getSizeSignalRef("width")}get height(){return this.getSizeSignalRef("height")}parse(){this.parseScale();
this.parseLayoutSize();this.renameTopLevelLayoutSizeSignal();this.parseSelections();this.parseProjection();this.parseData();this.parseAxesAndHeaders();this.parseLegends();this.parseMarkGroup()}parseScale(){var {ignoreRange}={};parseScaleCore(this);isUnitModel(this)?parseUnitScaleDomain(this):parseNonUnitScaleDomain(this);for(const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES)parseScaleProperty(this,prop);ignoreRange||parseScaleRange(this)}parseProjection(){parseProjection(this)}renameTopLevelLayoutSizeSignal(){"width"!==
this.getName("width")&&this.renameSignal(this.getName("width"),"width");"height"!==this.getName("height")&&this.renameSignal(this.getName("height"),"height")}parseLegends(){parseLegend(this)}assembleGroupStyle(){if("unit"===this.type||"layer"===this.type){var _this$view$style,_this$view;return null!==(_this$view$style=null===(_this$view=this.view)||void 0===_this$view?void 0:_this$view.style)&&void 0!==_this$view$style?_this$view$style:"cell"}}assembleEncodeFromView(view){view=Object.assign({},view);
view=(delete view.style,view);const e={};for(const property of keys$jscomp$0(view)){const value=view[property];void 0!==value&&(e[property]=signalOrValueRef(value))}return e}assembleGroupEncodeEntry(isTopLevel){let encodeEntry={};this.view&&(encodeEntry=this.assembleEncodeFromView(this.view));if(!isTopLevel&&(this.description&&(encodeEntry.description=signalOrValueRef(this.description)),"unit"===this.type||"layer"===this.type)){var _encodeEntry;return Object.assign({},{width:this.getSizeSignalRef("width"),
height:this.getSizeSignalRef("height")},null!==(_encodeEntry=encodeEntry)&&void 0!==_encodeEntry?_encodeEntry:{})}return isEmpty(encodeEntry)?void 0:encodeEntry}assembleLayout(){if(this.layout){var $jscomp$destructuring$var189=this.layout,$jscomp$destructuring$var190=Object.assign({},$jscomp$destructuring$var189);$jscomp$destructuring$var189=$jscomp$destructuring$var189.spacing;$jscomp$destructuring$var190=(delete $jscomp$destructuring$var190.spacing,$jscomp$destructuring$var190);var {component,config}=
this;{var headerComponentIndex=component.layoutHeaders;const titleBand={};for(JSCompiler_inline_result of FACET_CHANNELS){var headerComponent=headerComponentIndex[JSCompiler_inline_result];if(null===headerComponent||void 0===headerComponent?0:headerComponent.facetFieldDef){const {titleAnchor,titleOrient}=getHeaderProperties(["titleAnchor","titleOrient"],headerComponent.facetFieldDef.header,config,JSCompiler_inline_result);headerComponent=getHeaderChannel(JSCompiler_inline_result,titleOrient);const band=
LAYOUT_TITLE_BAND[headerComponent][titleAnchor];void 0!==band&&(titleBand[headerComponent]=band)}}var JSCompiler_inline_result=isEmpty(titleBand)?void 0:titleBand}return Object.assign({},{padding:$jscomp$destructuring$var189},this.assembleDefaultLayout(),$jscomp$destructuring$var190,JSCompiler_inline_result?{titleBand:JSCompiler_inline_result}:{})}}assembleDefaultLayout(){return{}}assembleHeaderMarks(){const {layoutHeaders}=this.component;let headerMarks=[];for(const channel of FACET_CHANNELS)layoutHeaders[channel].title&&
headerMarks.push(assembleTitleGroup(this,channel));for(const channel of HEADER_CHANNELS)headerMarks=headerMarks.concat(assembleHeaderGroups(this,channel));return headerMarks}assembleAxes(){return assembleAxes(this.component.axes,this.config)}assembleLegends(){return assembleLegends(this)}assembleProjections(){var JSCompiler_inline_result=isLayerModel(this)||isConcatModel(this)?assembleProjectionsForModelAndChildren(this):assembleProjectionForModel(this);return JSCompiler_inline_result}assembleTitle(){var _this$title,
$jscomp$destructuring$var191=null!==(_this$title=this.title)&&void 0!==_this$title?_this$title:{};_this$title=Object.assign({},$jscomp$destructuring$var191);$jscomp$destructuring$var191=$jscomp$destructuring$var191.encoding;_this$title=(delete _this$title.encoding,_this$title);$jscomp$destructuring$var191=Object.assign({},extractTitleConfig(this.config.title).nonMark,_this$title,$jscomp$destructuring$var191?{encode:{update:$jscomp$destructuring$var191}}:{});if($jscomp$destructuring$var191.text){if(contains(["unit",
"layer"],this.type)){if(contains(["middle",void 0],$jscomp$destructuring$var191.anchor)){var _title$frame;$jscomp$destructuring$var191.frame=null!==(_title$frame=$jscomp$destructuring$var191.frame)&&void 0!==_title$frame?_title$frame:"group"}}else{var _title$anchor;$jscomp$destructuring$var191.anchor=null!==(_title$anchor=$jscomp$destructuring$var191.anchor)&&void 0!==_title$anchor?_title$anchor:"start"}return isEmpty($jscomp$destructuring$var191)?void 0:$jscomp$destructuring$var191}}assembleGroup(signals){signals=
void 0===signals?[]:signals;const group={};signals=signals.concat(this.assembleSignals());0<signals.length&&(group.signals=signals);if(signals=this.assembleLayout())group.layout=signals;group.marks=[].concat(this.assembleHeaderMarks(),this.assembleMarks());signals=!this.parent||isFacetModel(this.parent)?assembleScales(this):[];0<signals.length&&(group.scales=signals);signals=this.assembleAxes();0<signals.length&&(group.axes=signals);signals=this.assembleLegends();0<signals.length&&(group.legends=
signals);return group}getName(text){return varName((this.name?this.name+"_":"")+text)}getDataName(type){return this.getName(DataSourceType[type].toLowerCase())}requestDataName(name){name=this.getDataName(name);const refCounts=this.component.data.outputNodeRefCounts;refCounts[name]=(refCounts[name]||0)+1;return name}getSizeSignalRef(layoutSizeType){if(isFacetModel(this.parent)){var sizeType=getSizeTypeFromLayoutSizeType(layoutSizeType),channel=getPositionScaleChannel(sizeType);if((sizeType=this.component.scales[channel])&&
!sizeType.merged){var type=sizeType.get("type");const range=sizeType.get("range");if(type in DISCRETE_DOMAIN_INDEX&&isVgRangeStep(range)){layoutSizeType=sizeType.get("name");type=assembleDomain(this,channel);if(type=getFieldFromDomain(type))return channel=vgField({aggregate:"distinct",field:type},{expr:"datum"}),{signal:sizeExpr(layoutSizeType,sizeType,channel)};warn(unknownField(channel));return null}}}return{signal:this.signalNameMap.get(this.getName(layoutSizeType))}}lookupDataSource(name){const node=
this.component.data.outputNodes[name];return node?node.getSource():name}getSignalName(oldSignalName){return this.signalNameMap.get(oldSignalName)}renameSignal(oldName,newName){this.signalNameMap.rename(oldName,newName)}renameScale(oldName,newName){this.scaleNameMap.rename(oldName,newName)}renameProjection(oldName,newName){this.projectionNameMap.rename(oldName,newName)}scaleName(originalScaleName,parse){if(parse)return this.getName(originalScaleName);if(CHANNEL_INDEX[originalScaleName]&&SCALE_CHANNEL_INDEX[originalScaleName]&&
this.component.scales[originalScaleName]||this.scaleNameMap.has(this.getName(originalScaleName)))return this.scaleNameMap.get(this.getName(originalScaleName))}projectionName(parse){if(parse)return this.getName("projection");if(this.component.projection&&!this.component.projection.merged||this.projectionNameMap.has(this.getName("projection")))return this.projectionNameMap.get(this.getName("projection"))}getScaleComponent(channel){if(!this.component.scales)throw Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
const localScaleComponent=this.component.scales[channel];return localScaleComponent&&!localScaleComponent.merged?localScaleComponent:this.parent?this.parent.getScaleComponent(channel):void 0}getSelectionComponent(variableName,origName){let sel=this.component.selection[variableName];!sel&&this.parent&&(sel=this.parent.getSelectionComponent(variableName,origName));if(!sel)throw Error('Cannot find a selection named "'.concat(origName,'".'));return sel}hasAxisOrientSignalRef(){var _this$component$axes$,
_this$component$axes$2;return(null===(_this$component$axes$=this.component.axes.x)||void 0===_this$component$axes$?void 0:_this$component$axes$.some(a=>a.hasOrientSignalRef()))||(null===(_this$component$axes$2=this.component.axes.y)||void 0===_this$component$axes$2?void 0:_this$component$axes$2.some(a=>a.hasOrientSignalRef()))}}class ModelWithField extends Model{vgField(channel,opt){opt=void 0===opt?{}:opt;if(channel=this.fieldDef(channel))return vgField(channel,opt)}reduceFieldDef(f,init){return reduce(this.getMapping(),
(acc,cd,c)=>(cd=getFieldDef(cd))?f(acc,cd,c):acc,init)}forEachFieldDef(f,t){forEach(this.getMapping(),(cd,c)=>{(cd=getFieldDef(cd))&&f(cd,c)},t)}}class DensityTransformNode extends DataFlowNode{clone(){return new DensityTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?
_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:"value",null!==(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:"density"]}dependentFields(){var _this$transform$group;return new Set([this.transform.density,...null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[]])}producedFields(){return new Set(this.transform.as)}hash(){return"DensityTransform ".concat(hash(this.transform))}assemble(){var $jscomp$destructuring$var193=
this.transform,$jscomp$destructuring$var194=Object.assign({},$jscomp$destructuring$var193);$jscomp$destructuring$var193=$jscomp$destructuring$var193.density;$jscomp$destructuring$var194=(delete $jscomp$destructuring$var194.density,$jscomp$destructuring$var194);return Object.assign({},{type:"kde",field:$jscomp$destructuring$var193},$jscomp$destructuring$var194)}}class FilterInvalidNode extends DataFlowNode{clone(){return new FilterInvalidNode(null,Object.assign({},this.filter))}constructor(parent,
filter){super(parent);this.filter=filter}static make(parent,model){const {config,mark,markDef}=model;if("filter"!==getMarkPropOrConfig("invalid",markDef,config))return null;const filter=model.reduceFieldDef((aggregator,fieldDef,channel)=>{(channel=!!SCALE_CHANNEL_INDEX[channel]&&model.getScaleComponent(channel))&&channel.get("type")in CONTINUOUS_DOMAIN_INDEX&&"count"!==fieldDef.aggregate&&!isPathMark(mark)&&(aggregator[fieldDef.field]=fieldDef);return aggregator},{});return keys$jscomp$0(filter).length?
new FilterInvalidNode(parent,filter):null}dependentFields(){return new Set(keys$jscomp$0(this.filter))}producedFields(){return new Set}hash(){return"FilterInvalid ".concat(hash(this.filter))}assemble(){const filters=keys$jscomp$0(this.filter).reduce((vegaFilters,field)=>{field=this.filter[field];const ref=vgField(field,{expr:"datum"});null!==field&&("temporal"===field.type?vegaFilters.push("(isDate(".concat(ref,") || (isValid(").concat(ref,") \x26\x26 isFinite(+").concat(ref,")))")):"quantitative"===
field.type&&(vegaFilters.push("isValid(".concat(ref,")")),vegaFilters.push("isFinite(+".concat(ref,")"))));return vegaFilters},[]);return 0<filters.length?{type:"filter",expr:filters.join(" \x26\x26 ")}:null}}class FlattenTransformNode extends DataFlowNode{clone(){return new FlattenTransformNode(this.parent,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform;this.transform=duplicate(transform);const {flatten,as=[]}=this.transform;this.transform.as=flatten.map((f,
i)=>{var _as$i;return null!==(_as$i=as[i])&&void 0!==_as$i?_as$i:f})}dependentFields(){return new Set(this.transform.flatten)}producedFields(){return new Set(this.transform.as)}hash(){return"FlattenTransform ".concat(hash(this.transform))}assemble(){const {flatten:fields,as}=this.transform;return{type:"flatten",fields,as}}}class FoldTransformNode extends DataFlowNode{clone(){return new FoldTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,
_specifiedAs$2;super(parent);this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:"key",null!==(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:"value"]}dependentFields(){return new Set(this.transform.fold)}producedFields(){return new Set(this.transform.as)}hash(){return"FoldTransform ".concat(hash(this.transform))}assemble(){const {fold,
as}=this.transform;return{type:"fold",fields:fold,as}}}class GeoJSONNode extends DataFlowNode{clone(){return new GeoJSONNode(null,duplicate(this.fields),this.geojson,this.signal)}static parseAll(parent,model){if(model.component.projection&&!model.component.projection.isFit)return parent;let geoJsonCounter=0;for(var coordinates of[["longitude","latitude"],["longitude2","latitude2"]]){const pair=coordinates.map(channel=>{channel=getFieldOrDatumDef(model.encoding[channel]);return isFieldDef(channel)?
channel.field:isDatumDef(channel)?{expr:"".concat(channel.datum)}:isValueDef(channel)?{expr:"".concat(channel.value)}:void 0});if(pair[0]||pair[1])parent=new GeoJSONNode(parent,pair,null,model.getName("geojson_".concat(geoJsonCounter++)))}model.channelHasField("shape")&&(coordinates=model.typedFieldDef("shape"),"geojson"===coordinates.type&&(parent=new GeoJSONNode(parent,null,coordinates.field,model.getName("geojson_".concat(geoJsonCounter++)))));return parent}constructor(parent,fields,geojson,signal){super(parent);
this.fields=fields;this.geojson=geojson;this.signal=signal}dependentFields(){var _this$fields;const fields=(null!==(_this$fields=this.fields)&&void 0!==_this$fields?_this$fields:[]).filter(isString);return new Set([...this.geojson?[this.geojson]:[],...fields])}producedFields(){return new Set}hash(){return"GeoJSON ".concat(this.geojson," ").concat(this.signal," ").concat(hash(this.fields))}assemble(){return Object.assign({},{type:"geojson"},this.fields?{fields:this.fields}:{},this.geojson?{geojson:this.geojson}:
{},{signal:this.signal})}}class GeoPointNode extends DataFlowNode{clone(){return new GeoPointNode(null,this.projection,duplicate(this.fields),duplicate(this.as))}constructor(parent,projection,fields,as){super(parent);this.projection=projection;this.fields=fields;this.as=as}static parseAll(parent,model){if(!model.projectionName())return parent;for(const coordinates of[["longitude","latitude"],["longitude2","latitude2"]]){const pair=coordinates.map(channel=>{channel=getFieldOrDatumDef(model.encoding[channel]);
return isFieldDef(channel)?channel.field:isDatumDef(channel)?{expr:"".concat(channel.datum)}:isValueDef(channel)?{expr:"".concat(channel.value)}:void 0}),suffix="longitude2"===coordinates[0]?"2":"";if(pair[0]||pair[1])parent=new GeoPointNode(parent,model.projectionName(),pair,[model.getName("x"+suffix),model.getName("y"+suffix)])}return parent}dependentFields(){return new Set(this.fields.filter(isString))}producedFields(){return new Set(this.as)}hash(){return"Geopoint ".concat(this.projection," ").concat(hash(this.fields),
" ").concat(hash(this.as))}assemble(){return{type:"geopoint",projection:this.projection,fields:this.fields,as:this.as}}}class ImputeNode extends DataFlowNode{clone(){return new ImputeNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}dependentFields(){var _this$transform$group;return new Set([this.transform.impute,this.transform.key,...null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:
[]])}producedFields(){return new Set([this.transform.impute])}processSequence(keyvals){const {start=0,stop,step}=keyvals;keyvals=[start,stop,...step?[step]:[]].join();return{signal:"sequence(".concat(keyvals,")")}}static makeFromTransform(parent,imputeTransform){return new ImputeNode(parent,imputeTransform)}static makeFromEncoding(parent,model){const encoding=model.encoding;var xDef=encoding.x;const yDef=encoding.y;if(isFieldDef(xDef)&&isFieldDef(yDef)){const imputedChannel=xDef.impute?xDef:yDef.impute?
yDef:void 0;if(void 0===imputedChannel)return;xDef=xDef.impute?yDef:yDef.impute?xDef:void 0;const {method,value,frame,keyvals}=imputedChannel.impute;model=pathGroupingFields(model.mark,encoding);return new ImputeNode(parent,Object.assign({},{impute:imputedChannel.field,key:xDef.field},method?{method}:{},void 0!==value?{value}:{},frame?{frame}:{},void 0!==keyvals?{keyvals}:{},model.length?{groupby:model}:{}))}return null}hash(){return"Impute ".concat(hash(this.transform))}assemble(){const {impute,
key,keyvals,method,groupby,value,frame=[null,null]}=this.transform,imputeTransform=Object.assign({},{type:"impute",field:impute,key},keyvals?{keyvals:void 0!==(null===keyvals||void 0===keyvals?void 0:keyvals.stop)?this.processSequence(keyvals):keyvals}:{},{method:"value"},groupby?{groupby}:{},{value:method&&"value"!==method?null:value});if(method&&"value"!==method){const deriveNewField=Object.assign({},{type:"window",as:["imputed_".concat(impute,"_value")],ops:[method],fields:[impute],frame,ignorePeers:!1},
groupby?{groupby}:{}),replaceOriginal={type:"formula",expr:"datum.".concat(impute," \x3d\x3d\x3d null ? datum.imputed_").concat(impute,"_value : datum.").concat(impute),as:impute};return[imputeTransform,deriveNewField,replaceOriginal]}return[imputeTransform]}}class LoessTransformNode extends DataFlowNode{clone(){return new LoessTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);this.transform=transform;this.transform=
duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:transform.on,null!==(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:transform.loess]}dependentFields(){var _this$transform$group;return new Set([this.transform.loess,this.transform.on,...null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?
_this$transform$group:[]])}producedFields(){return new Set(this.transform.as)}hash(){return"LoessTransform ".concat(hash(this.transform))}assemble(){var $jscomp$destructuring$var195=this.transform,$jscomp$destructuring$var196=Object.assign({},$jscomp$destructuring$var195);const loess=$jscomp$destructuring$var195.loess;$jscomp$destructuring$var195=$jscomp$destructuring$var195.on;$jscomp$destructuring$var196=(delete $jscomp$destructuring$var196.loess,delete $jscomp$destructuring$var196.on,$jscomp$destructuring$var196);
return Object.assign({},{type:"loess",x:$jscomp$destructuring$var195,y:loess},$jscomp$destructuring$var196)}}class LookupNode extends DataFlowNode{clone(){return new LookupNode(null,duplicate(this.transform),this.secondary)}constructor(parent,transform,secondary){super(parent);this.transform=transform;this.secondary=secondary}static make(parent,model,transform,counter){const sources=model.component.data.sources,{from}=transform;var fromOutputNode=null;if("data"in from)fromOutputNode=findSource(from.data,
sources),fromOutputNode||(fromOutputNode=new SourceNode(from.data),sources.push(fromOutputNode)),counter=model.getName("lookup_".concat(counter)),fromOutputNode=new OutputNode(fromOutputNode,counter,DataSourceType.Lookup,model.component.data.outputNodeRefCounts),model.component.data.outputNodes[counter]=fromOutputNode;else if("selection"in from&&(counter=from.selection,transform=Object.assign({},{as:counter},transform),fromOutputNode=model.getSelectionComponent(varName(counter),counter).materialized,
!fromOutputNode))throw Error('Cannot define and lookup the "'.concat(counter,'" selection in the same view. ')+"Try moving the lookup into a second, layered view?");return new LookupNode(parent,transform,fromOutputNode.getSource())}dependentFields(){return new Set([this.transform.lookup])}producedFields(){return new Set(this.transform.as?array$jscomp$0(this.transform.as):this.transform.from.fields)}hash(){return"Lookup ".concat(hash({transform:this.transform,secondary:this.secondary}))}assemble(){if(this.transform.from.fields)var foreign=
Object.assign({},{values:this.transform.from.fields},this.transform.as?{as:array$jscomp$0(this.transform.as)}:{});else foreign=this.transform.as,isString(foreign)||(warn('If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.'),foreign="_lookup"),foreign={as:[foreign]};return Object.assign({},{type:"lookup",from:this.secondary,key:this.transform.from.key,fields:[this.transform.lookup]},foreign,this.transform.default?{default:this.transform.default}:
{})}}class QuantileTransformNode extends DataFlowNode{clone(){return new QuantileTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:"prob",null!==
(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:"value"]}dependentFields(){var _this$transform$group;return new Set([this.transform.quantile,...null!==(_this$transform$group=this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[]])}producedFields(){return new Set(this.transform.as)}hash(){return"QuantileTransform ".concat(hash(this.transform))}assemble(){var $jscomp$destructuring$var197=this.transform,$jscomp$destructuring$var198=Object.assign({},$jscomp$destructuring$var197);
$jscomp$destructuring$var197=$jscomp$destructuring$var197.quantile;$jscomp$destructuring$var198=(delete $jscomp$destructuring$var198.quantile,$jscomp$destructuring$var198);return Object.assign({},{type:"quantile",field:$jscomp$destructuring$var197},$jscomp$destructuring$var198)}}class RegressionTransformNode extends DataFlowNode{clone(){return new RegressionTransformNode(null,duplicate(this.transform))}constructor(parent,transform){var _this$transform$as,_specifiedAs$,_specifiedAs$2;super(parent);
this.transform=transform;this.transform=duplicate(transform);parent=null!==(_this$transform$as=this.transform.as)&&void 0!==_this$transform$as?_this$transform$as:[void 0,void 0];this.transform.as=[null!==(_specifiedAs$=parent[0])&&void 0!==_specifiedAs$?_specifiedAs$:transform.on,null!==(_specifiedAs$2=parent[1])&&void 0!==_specifiedAs$2?_specifiedAs$2:transform.regression]}dependentFields(){var _this$transform$group;return new Set([this.transform.regression,this.transform.on,...null!==(_this$transform$group=
this.transform.groupby)&&void 0!==_this$transform$group?_this$transform$group:[]])}producedFields(){return new Set(this.transform.as)}hash(){return"RegressionTransform ".concat(hash(this.transform))}assemble(){var $jscomp$destructuring$var199=this.transform,$jscomp$destructuring$var200=Object.assign({},$jscomp$destructuring$var199);const regression=$jscomp$destructuring$var199.regression;$jscomp$destructuring$var199=$jscomp$destructuring$var199.on;$jscomp$destructuring$var200=(delete $jscomp$destructuring$var200.regression,
delete $jscomp$destructuring$var200.on,$jscomp$destructuring$var200);return Object.assign({},{type:"regression",x:$jscomp$destructuring$var199,y:regression},$jscomp$destructuring$var200)}}class PivotTransformNode extends DataFlowNode{clone(){return new PivotTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}addDimensions(fields){var _this$transform$group;this.transform.groupby=unique((null!==(_this$transform$group=this.transform.groupby)&&
void 0!==_this$transform$group?_this$transform$group:[]).concat(fields),d=>d)}producedFields(){}dependentFields(){var _this$transform$group2;return new Set([this.transform.pivot,this.transform.value,...null!==(_this$transform$group2=this.transform.groupby)&&void 0!==_this$transform$group2?_this$transform$group2:[]])}hash(){return"PivotTransform ".concat(hash(this.transform))}assemble(){const {pivot,value,groupby,limit,op}=this.transform;return Object.assign({},{type:"pivot",field:pivot,value},void 0!==
limit?{limit}:{},void 0!==op?{op}:{},void 0!==groupby?{groupby}:{})}}class SampleTransformNode extends DataFlowNode{clone(){return new SampleTransformNode(null,duplicate(this.transform))}constructor(parent,transform){super(parent);this.transform=transform}dependentFields(){return new Set}producedFields(){return new Set}hash(){return"SampleTransform ".concat(hash(this.transform))}assemble(){return{type:"sample",size:this.transform.sample}}}class FacetModel extends ModelWithField{constructor(spec,parent,
parentGivenName,config){super(spec,"facet",parent,parentGivenName,config,spec.resolve);_defineProperty(this,"facet",void 0);_defineProperty(this,"child",void 0);_defineProperty(this,"children",void 0);this.child=buildModel(spec.spec,this,this.getName("child"),void 0,config);this.children=[this.child];this.facet=this.initFacet(spec.facet)}initFacet(facet){if(!isFacetMapping(facet))return{facet:this.initFacetFieldDef(facet,"facet")};var channels=keys$jscomp$0(facet);const normalizedFacet={};for(const channel of channels){if(!contains(["row",
"column"],channel)){warn(incompatibleChannel(channel,"facet"));break}channels=facet[channel];if(void 0===channels.field){warn(emptyFieldDef(channels,channel));break}normalizedFacet[channel]=this.initFacetFieldDef(channels,channel)}return normalizedFacet}initFacetFieldDef(fieldDef,channel){var $jscomp$destructuring$var203=Object.assign({},fieldDef);fieldDef=fieldDef.header;$jscomp$destructuring$var203=(delete $jscomp$destructuring$var203.header,$jscomp$destructuring$var203);channel=initFieldDef($jscomp$destructuring$var203,
channel);fieldDef&&(channel.header=replaceExprRefInIndex(fieldDef));return channel}channelHasField(channel){return!!this.facet[channel]}fieldDef(channel){return this.facet[channel]}parseData(){this.component.data=parseData(this);this.child.parseData()}parseLayoutSize(){parseChildrenLayoutSize(this)}parseSelections(){this.child.parseSelections();this.component.selection=this.child.component.selection}parseMarkGroup(){this.child.parseMarkGroup()}parseAxesAndHeaders(){this.child.parseAxesAndHeaders();
for(const channel of FACET_CHANNELS){{var _fieldDef$header=void 0,channel$jscomp$0=channel;const {facet,config,child,component}=this;if(this.channelHasField(channel$jscomp$0)){const fieldDef=facet[channel$jscomp$0];var titleConfig=getHeaderProperty("title",null,config,channel$jscomp$0);titleConfig=title$jscomp$0(fieldDef,config,{allowDisabling:!0,includeDefault:void 0===titleConfig||!!titleConfig});child.component.layoutHeaders[channel$jscomp$0].title&&(titleConfig=isArray(titleConfig)?titleConfig.join(", "):
titleConfig,titleConfig+=" / "+child.component.layoutHeaders[channel$jscomp$0].title,child.component.layoutHeaders[channel$jscomp$0].title=null);var labelOrient=getHeaderProperty("labelOrient",fieldDef,config,channel$jscomp$0);const header=null!==(_fieldDef$header=fieldDef.header)&&void 0!==_fieldDef$header?_fieldDef$header:{};_fieldDef$header=getFirstDefined(header.labels,config.header.labels,!0);labelOrient=contains(["bottom","right"],labelOrient)?"footer":"header";component.layoutHeaders[channel$jscomp$0]=
{title:titleConfig,facetFieldDef:fieldDef,[labelOrient]:"facet"===channel$jscomp$0?[]:[makeHeaderComponent(this,channel$jscomp$0,_fieldDef$header)]}}}}mergeChildAxis(this,"x");mergeChildAxis(this,"y")}assembleSelectionTopLevelSignals(signals){return this.child.assembleSelectionTopLevelSignals(signals)}assembleSignals(){this.child.assembleSignals();return[]}assembleSelectionData(data){return this.child.assembleSelectionData(data)}getHeaderLayoutMixins(){const layoutMixins={};for(const channel of FACET_CHANNELS)for(const headerType of HEADER_TYPES){const layoutHeaderComponent=
this.component.layoutHeaders[channel];var headerComponent=layoutHeaderComponent[headerType],{facetFieldDef}=layoutHeaderComponent;if(facetFieldDef&&(facetFieldDef=getHeaderProperty("titleOrient",facetFieldDef.header,this.config,channel),contains(["right","bottom"],facetFieldDef))){var _layoutMixins$titleAn;facetFieldDef=getHeaderChannel(channel,facetFieldDef);layoutMixins.titleAnchor=null!==(_layoutMixins$titleAn=layoutMixins.titleAnchor)&&void 0!==_layoutMixins$titleAn?_layoutMixins$titleAn:{};layoutMixins.titleAnchor[facetFieldDef]=
"end"}if(null===headerComponent||void 0===headerComponent?0:headerComponent[0]){headerComponent="row"===channel?"height":"width";facetFieldDef="header"===headerType?"headerBand":"footerBand";if("facet"!==channel&&!this.child.component.layoutSize.get(headerComponent)){var _layoutMixins$bandTyp;layoutMixins[facetFieldDef]=null!==(_layoutMixins$bandTyp=layoutMixins[facetFieldDef])&&void 0!==_layoutMixins$bandTyp?_layoutMixins$bandTyp:{};layoutMixins[facetFieldDef][channel]=.5}if(layoutHeaderComponent.title){var _layoutMixins$offset;
layoutMixins.offset=null!==(_layoutMixins$offset=layoutMixins.offset)&&void 0!==_layoutMixins$offset?_layoutMixins$offset:{};layoutMixins.offset["row"===channel?"rowTitle":"columnTitle"]=10}}}return layoutMixins}assembleDefaultLayout(){const {column,row}=this.facet,columns=column?this.columnDistinctSignal():row?1:void 0;let align="all";row||"independent"!==this.component.resolve.scale.x?column||"independent"!==this.component.resolve.scale.y||(align="none"):align="none";return Object.assign({},this.getHeaderLayoutMixins(),
columns?{columns}:{},{bounds:"full",align})}assembleLayoutSignals(){return this.child.assembleLayoutSignals()}columnDistinctSignal(){if(!(this.parent&&this.parent instanceof FacetModel)){const facetLayoutDataName=this.getName("column_domain");return{signal:"length(data('".concat(facetLayoutDataName,"'))")}}}assembleGroup(signals){return this.parent&&this.parent instanceof FacetModel?Object.assign({},this.channelHasField("column")?{encode:{update:{columns:{field:vgField(this.facet.column,{prefix:"distinct"})}}}}:
{},super.assembleGroup(signals)):super.assembleGroup(signals)}getCardinalityAggregateForChild(){const fields=[],ops=[],as=[];if(this.child instanceof FacetModel){if(this.child.channelHasField("column")){var field=vgField(this.child.facet.column);fields.push(field);ops.push("distinct");as.push("distinct_".concat(field))}}else for(field of POSITION_SCALE_CHANNELS){var childScaleComponent=this.child.component.scales[field];if(childScaleComponent&&!childScaleComponent.merged){var type=childScaleComponent.get("type");
childScaleComponent=childScaleComponent.get("range");type in DISCRETE_DOMAIN_INDEX&&isVgRangeStep(childScaleComponent)&&(type=assembleDomain(this.child,field),(type=getFieldFromDomain(type))?(fields.push(type),ops.push("distinct"),as.push("distinct_".concat(type))):warn(unknownField(field)))}}return{fields,ops,as}}assembleFacet(){const {name,data}=this.component.data.facetRoot,{row,column}=this.facet,{fields,ops,as}=this.getCardinalityAggregateForChild(),groupby=[];for(var channel of FACET_CHANNELS){var fieldDef=
this.facet[channel];if(fieldDef){groupby.push(vgField(fieldDef));const {bin,sort}=fieldDef;isBinning(bin)&&groupby.push(vgField(fieldDef,{binSuffix:"end"}));if(isSortField(sort)){const {field,op="min"}=sort;fieldDef=facetSortFieldName(fieldDef,sort);row&&column?(fields.push(fieldDef),ops.push("max")):(fields.push(field),ops.push(op));as.push(fieldDef)}else isArray(sort)&&(fieldDef=sortArrayIndexField(fieldDef,channel),fields.push(fieldDef),ops.push("max"),as.push(fieldDef))}}channel=!!row&&!!column;
return Object.assign({},{name,data,groupby},channel||0<fields.length?{aggregate:Object.assign({},channel?{cross:channel}:{},fields.length?{fields,ops,as}:{})}:{})}facetSortFields(channel){var {facet}=this;return(facet=facet[channel])?isSortField(facet.sort)?[facetSortFieldName(facet,facet.sort,{expr:"datum"})]:isArray(facet.sort)?[sortArrayIndexField(facet,channel,{expr:"datum"})]:[vgField(facet,{expr:"datum"})]:[]}facetSortOrder(channel){const {facet}=this;return(channel=facet[channel])?({sort:channel}=
channel,[(isSortField(channel)?channel.order:!isArray(channel)&&channel)||"ascending"]):[]}assembleLabelTitle(){const {facet,config}=this;if(facet.facet)return assembleLabelTitle(facet.facet,"facet",config);const ORTHOGONAL_ORIENT={row:["top","bottom"],column:["left","right"]};for(const channel of HEADER_CHANNELS)if(facet[channel]){var _facet$channel;const labelOrient=getHeaderProperty("labelOrient",null===(_facet$channel=facet[channel])||void 0===_facet$channel?void 0:_facet$channel.header,config,
channel);if(contains(ORTHOGONAL_ORIENT[channel],labelOrient))return assembleLabelTitle(facet[channel],channel,config)}}assembleMarks(){const {child}=this,data=assembleFacetData(this.component.data.facetRoot),encodeEntry=child.assembleGroupEncodeEntry(!1),title=this.assembleLabelTitle()||child.assembleTitle(),style=child.assembleGroupStyle();return[Object.assign({},{name:this.getName("cell"),type:"group"},title?{title}:{},style?{style}:{},{from:{facet:this.assembleFacet()},sort:{field:FACET_CHANNELS.map(c=>
this.facetSortFields(c)).flat(),order:FACET_CHANNELS.map(c=>this.facetSortOrder(c)).flat()}},0<data.length?{data}:{},encodeEntry?{encode:{update:encodeEntry}}:{},child.assembleGroup(assembleFacetSignals(this,[])))]}getMapping(){return this.facet}}class ConcatModel extends Model{constructor(spec,parent,parentGivenName,config){var _spec$resolve,_spec$resolve$axis,_spec$resolve2,_spec$resolve2$axis;super(spec,"concat",parent,parentGivenName,config,spec.resolve);_defineProperty(this,"children",void 0);
"shared"!==(null===(_spec$resolve=spec.resolve)||void 0===_spec$resolve?void 0:null===(_spec$resolve$axis=_spec$resolve.axis)||void 0===_spec$resolve$axis?void 0:_spec$resolve$axis.x)&&"shared"!==(null===(_spec$resolve2=spec.resolve)||void 0===_spec$resolve2?void 0:null===(_spec$resolve2$axis=_spec$resolve2.axis)||void 0===_spec$resolve2$axis?void 0:_spec$resolve2$axis.y)||warn("Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).");this.children=
this.getChildren(spec).map((child,i)=>buildModel(child,this,this.getName("concat_"+i),void 0,config))}parseData(){this.component.data=parseData(this);for(const child of this.children)child.parseData()}parseSelections(){this.component.selection={};for(const child of this.children){child.parseSelections();for(const key of keys$jscomp$0(child.component.selection))this.component.selection[key]=child.component.selection[key]}}parseMarkGroup(){for(const child of this.children)child.parseMarkGroup()}parseAxesAndHeaders(){for(const child of this.children)child.parseAxesAndHeaders()}getChildren(spec){return"vconcat"in
spec?spec.vconcat:"hconcat"in spec?spec.hconcat:spec.concat}parseLayoutSize(){{parseChildrenLayoutSize(this);const heightType=void 0===this.layout.columns?"height":"childHeight";parseNonUnitLayoutSizeForChannel(this,1===this.layout.columns?"width":"childWidth");parseNonUnitLayoutSizeForChannel(this,heightType)}}parseAxisGroup(){return null}assembleSelectionTopLevelSignals(signals){return this.children.reduce((sg,child)=>child.assembleSelectionTopLevelSignals(sg),signals)}assembleSignals(){this.children.forEach(child=>
child.assembleSignals());return[]}assembleLayoutSignals(){const layoutSignals=assembleLayoutSignals(this);for(const child of this.children)layoutSignals.push(...child.assembleLayoutSignals());return layoutSignals}assembleSelectionData(data){return this.children.reduce((db,child)=>child.assembleSelectionData(db),data)}assembleMarks(){return this.children.map(child=>{const title=child.assembleTitle(),style=child.assembleGroupStyle(),encodeEntry=child.assembleGroupEncodeEntry(!1);return Object.assign({},
{type:"group",name:child.getName("group")},title?{title}:{},style?{style}:{},encodeEntry?{encode:{update:encodeEntry}}:{},child.assembleGroup())})}assembleDefaultLayout(){const columns=this.layout.columns;return Object.assign({},null!=columns?{columns}:{},{bounds:"full",align:"each"})}}const AXIS_COMPONENT_PROPERTIES_INDEX=Object.assign({},{disable:1,gridScale:1,scale:1},COMMON_AXIS_PROPERTIES_INDEX,{labelExpr:1,encode:1}),AXIS_COMPONENT_PROPERTIES=keys$jscomp$0(AXIS_COMPONENT_PROPERTIES_INDEX);class AxisComponent extends Split{constructor(explicit,
implicit,mainExtracted){explicit=void 0===explicit?{}:explicit;implicit=void 0===implicit?{}:implicit;mainExtracted=void 0===mainExtracted?!1:mainExtracted;super();this.explicit=explicit;this.implicit=implicit;this.mainExtracted=mainExtracted}clone(){return new AxisComponent(duplicate(this.explicit),duplicate(this.implicit),this.mainExtracted)}hasAxisPart(part){if("axis"===part)return!0;if("grid"===part||"title"===part)return!!this.get(part);part=this.get(part);return!(!1===part||null===part)}hasOrientSignalRef(){return isSignalRef(this.explicit.orient)}}
const OPPOSITE_ORIENT={bottom:"top",top:"bottom",left:"right",right:"left"},propsToAlwaysIncludeConfig=new Set("grid translate format formatType orient labelExpr tickCount position tickMinStep".split(" ")),markCompiler={arc:{vgMark:"arc",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"}),pointPosition("x",model,{defaultPos:"mid"}),pointPosition("y",model,{defaultPos:"mid"}),rectPosition(model,"radius",
"arc"),rectPosition(model,"theta","arc"))},area:{vgMark:"area",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"include",size:"ignore",theta:"ignore"}),pointOrRangePosition("x",model,{defaultPos:"zeroOrMin",defaultPos2:"zeroOrMin",range:"horizontal"===model.markDef.orient}),pointOrRangePosition("y",model,{defaultPos:"zeroOrMin",defaultPos2:"zeroOrMin",range:"vertical"===model.markDef.orient}),defined(model))},bar:{vgMark:"rect",encodeEntry:model=>
Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),rectPosition(model,"x","bar"),rectPosition(model,"y","bar"))},circle:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model,"circle")},geoshape:{vgMark:"shape",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"})),postEncodingTransform:model=>{var {encoding}=model;
encoding=encoding.shape;return[Object.assign({},{type:"geoshape",projection:model.projectionName()},encoding&&isFieldDef(encoding)&&"geojson"===encoding.type?{field:vgField(encoding,{expr:"datum"})}:{})]}},image:{vgMark:"image",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"ignore",orient:"ignore",size:"ignore",theta:"ignore"}),rectPosition(model,"x","image"),rectPosition(model,"y","image"),text$jscomp$0(model,"url"))},line:{vgMark:"line",encodeEntry:model=>
Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"ignore",orient:"ignore",theta:"ignore"}),pointPosition("x",model,{defaultPos:"mid"}),pointPosition("y",model,{defaultPos:"mid"}),nonPosition("size",model,{vgChannel:"strokeWidth"}),defined(model))},point:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model)},rect:{vgMark:"rect",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",
theta:"ignore"}),rectPosition(model,"x","rect"),rectPosition(model,"y","rect"))},rule:{vgMark:"rule",encodeEntry:model=>{var {markDef}=model;markDef=markDef.orient;return model.encoding.x||model.encoding.y||model.encoding.latitude||model.encoding.longitude?Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),pointOrRangePosition("x",model,{defaultPos:"horizontal"===markDef?"zeroOrMax":"mid",defaultPos2:"zeroOrMin",
range:"vertical"!==markDef}),pointOrRangePosition("y",model,{defaultPos:"vertical"===markDef?"zeroOrMax":"mid",defaultPos2:"zeroOrMin",range:"horizontal"!==markDef}),nonPosition("size",model,{vgChannel:"strokeWidth"})):{}}},square:{vgMark:"symbol",encodeEntry:model=>encodeEntry(model,"square")},text:{vgMark:"text",encodeEntry:model=>{const {config,encoding}=model;return Object.assign({},baseEncodeEntry(model,{align:"include",baseline:"include",color:"include",size:"ignore",orient:"ignore",theta:"include"}),
pointPosition("x",model,{defaultPos:"mid"}),pointPosition("y",model,{defaultPos:"mid"}),text$jscomp$0(model),nonPosition("size",model,{vgChannel:"fontSize"}),nonPosition("angle",model),valueIfDefined("align",align$jscomp$0(model.markDef,encoding,config)),valueIfDefined("baseline",baseline(model.markDef,encoding,config)),pointPosition("radius",model,{defaultPos:null,isMidPoint:!0}),pointPosition("theta",model,{defaultPos:null,isMidPoint:!0}))}},tick:{vgMark:"rect",encodeEntry:model=>{const {config,
markDef}=model;var orient=markDef.orient;const vgSizeChannel="horizontal"===orient?"width":"height";orient="horizontal"===orient?"height":"width";return Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",orient:"ignore",size:"ignore",theta:"ignore"}),pointPosition("x",model,{defaultPos:"mid",vgChannel:"xc"}),pointPosition("y",model,{defaultPos:"mid",vgChannel:"yc"}),nonPosition("size",model,{defaultValue:defaultSize(model),vgChannel:vgSizeChannel}),{[orient]:signalOrValueRef(getMarkPropOrConfig("thickness",
markDef,config))})}},trail:{vgMark:"trail",encodeEntry:model=>Object.assign({},baseEncodeEntry(model,{align:"ignore",baseline:"ignore",color:"include",size:"include",orient:"ignore",theta:"ignore"}),pointPosition("x",model,{defaultPos:"mid"}),pointPosition("y",model,{defaultPos:"mid"}),nonPosition("size",model),defined(model))}};class UnitModel extends ModelWithField{constructor(spec,parent,parentGivenName,parentGivenSize,config){parentGivenSize=void 0===parentGivenSize?{}:parentGivenSize;super(spec,
"unit",parent,parentGivenName,config,void 0,isFrameMixins(spec)?spec.view:void 0);_defineProperty(this,"markDef",void 0);_defineProperty(this,"encoding",void 0);_defineProperty(this,"specifiedScales",{});_defineProperty(this,"stack",void 0);_defineProperty(this,"specifiedAxes",{});_defineProperty(this,"specifiedLegends",{});_defineProperty(this,"specifiedProjection",{});_defineProperty(this,"selection",{});_defineProperty(this,"children",[]);var markDef=isMarkDef(spec.mark)?Object.assign({},spec.mark):
{type:spec.mark};parent=markDef.type;if(void 0===markDef.filled){({graticule:parentGivenName}={graticule:spec.data&&"graticule"in spec.data});if(parentGivenName)parentGivenName=!1;else{parentGivenName=getMarkConfig("filled",markDef,config);var mark=markDef.type;parentGivenName=getFirstDefined(parentGivenName,mark!==POINT&&mark!==LINE&&mark!==RULE)}markDef.filled=parentGivenName}parentGivenName=this.encoding=initEncoding(spec.encoding||{},parent,markDef.filled,config);markDef=replaceExprRefInIndex(markDef);
mark=getMarkPropOrConfig("orient",markDef,config);markDef.orient=orient$jscomp$1(markDef.type,parentGivenName,mark);void 0!==mark&&mark!==markDef.orient&&(mark='Specified orient "'.concat(markDef.orient,'" overridden with "').concat(mark,'".'),warn(mark));if("bar"===markDef.type&&markDef.orient&&(mark=getMarkPropOrConfig("cornerRadiusEnd",markDef,config),void 0!==mark)){const newProps="horizontal"===markDef.orient&&parentGivenName.x2||"vertical"===markDef.orient&&parentGivenName.y2?["cornerRadius"]:
BAR_CORNER_RADIUS_INDEX[markDef.orient];for(var newProp of newProps)markDef[newProp]=mark;void 0!==markDef.cornerRadiusEnd&&delete markDef.cornerRadiusEnd}void 0===getMarkPropOrConfig("opacity",markDef,config)&&(newProp=contains([POINT,TICK,CIRCLE,SQUARE],markDef.type)&&!isAggregate(parentGivenName)?.7:void 0,markDef.opacity=newProp);void 0===getMarkPropOrConfig("cursor",markDef,config)&&(newProp=markDef,config=parentGivenName.href||newProp.href||getMarkPropOrConfig("href",newProp,config)?"pointer":
newProp.cursor,markDef.cursor=config);this.markDef=config=markDef;parentGivenSize={encoding:parentGivenName,size:isFrameMixins(spec)?Object.assign({},parentGivenSize,spec.width?{width:spec.width}:{},spec.height?{height:spec.height}:{}):parentGivenSize};var {encoding,size}=parentGivenSize;for(const channel of POSITION_SCALE_CHANNELS)parentGivenSize=getSizeChannel(channel),isStep(size[parentGivenSize])&&isContinuousFieldOrDatumDef(encoding[channel])&&(delete size[parentGivenSize],warn(stepDropped(parentGivenSize)));
this.size=size;this.stack=stack$jscomp$1(parent,parentGivenName);this.specifiedScales=this.initScales(parent,parentGivenName);this.specifiedAxes=this.initAxes(parentGivenName);this.specifiedLegends=this.initLegends(parentGivenName);this.specifiedProjection=spec.projection;this.selection=spec.selection}get hasProjection(){const {encoding}=this,isGeoShapeMark=this.mark===GEOSHAPE,hasGeoPosition=encoding&&GEOPOSITION_CHANNELS.some(channel=>isFieldOrDatumDef(encoding[channel]));return isGeoShapeMark||
hasGeoPosition}scaleDomain(channel){return(channel=this.specifiedScales[channel])?channel.domain:void 0}axis(channel){return this.specifiedAxes[channel]}legend(channel){return this.specifiedLegends[channel]}initScales(mark,encoding){return SCALE_CHANNELS.reduce((scales,channel)=>{const fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]);if(fieldOrDatumDef){var _fieldOrDatumDef$scal;scales[channel]=this.initScale(null!==(_fieldOrDatumDef$scal=fieldOrDatumDef.scale)&&void 0!==_fieldOrDatumDef$scal?
_fieldOrDatumDef$scal:{})}return scales},{})}initScale(scale){const {domain,range}=scale;scale=replaceExprRefInIndex(scale);isArray(domain)&&(scale.domain=domain.map(signalRefOrValue));isArray(range)&&(scale.range=range.map(signalRefOrValue));return scale}initAxes(encoding){return POSITION_SCALE_CHANNELS.reduce((_axis,channel)=>{var channelDef=encoding[channel];if(isFieldOrDatumDef(channelDef)||"x"===channel&&isFieldOrDatumDef(encoding.x2)||"y"===channel&&isFieldOrDatumDef(encoding.y2))channelDef=
isFieldOrDatumDef(channelDef)?channelDef.axis:void 0,_axis[channel]=channelDef?this.initAxis(Object.assign({},channelDef)):channelDef;return _axis},{})}initAxis(axis){var props=keys$jscomp$0(axis);const axisInternal={};for(const prop of props)props=axis[prop],axisInternal[prop]=isConditionalAxisValue(props)?signalOrValueRefWithCondition(props):signalRefOrValue(props);return axisInternal}initLegends(encoding){return NONPOSITION_SCALE_CHANNELS.reduce((_legend,channel)=>{var fieldOrDatumDef=getFieldOrDatumDef(encoding[channel]),
JSCompiler_temp;if(JSCompiler_temp=fieldOrDatumDef)a:{switch(channel){case "color":case "fill":case "stroke":case "size":case "shape":case "opacity":case "strokeWidth":case "strokeDash":JSCompiler_temp=!0;break a;case "fillOpacity":case "strokeOpacity":case "angle":JSCompiler_temp=!1;break a}JSCompiler_temp=void 0}JSCompiler_temp&&(fieldOrDatumDef=fieldOrDatumDef.legend,_legend[channel]=fieldOrDatumDef?replaceExprRefInIndex(fieldOrDatumDef):fieldOrDatumDef);return _legend},{})}parseData(){this.component.data=
parseData(this)}parseLayoutSize(){{const {size,component}=this;for(const channel of POSITION_SCALE_CHANNELS){const sizeType=getSizeChannel(channel);if(size[sizeType]){var specifiedSize=size[sizeType];component.layoutSize.set(sizeType,isStep(specifiedSize)?"step":specifiedSize,!0)}else specifiedSize=defaultUnitSize(this,sizeType),component.layoutSize.set(sizeType,specifiedSize,!1)}}}parseSelections(){this.component.selection=parseUnitSelection(this,this.selection)}parseMarkGroup(){this.component.mark=
parseMarkGroups(this)}parseAxesAndHeaders(){this.component.axes=parseUnitAxes(this)}assembleSelectionTopLevelSignals(signals){return assembleTopLevelSignals(this,signals)}assembleSignals(){return[...assembleAxisSignals(this),...assembleUnitSelectionSignals(this,[])]}assembleSelectionData(data){return assembleUnitSelectionData(this,data)}assembleLayout(){return null}assembleLayoutSignals(){return assembleLayoutSignals(this)}assembleMarks(){var _this$component$mark;let marks=null!==(_this$component$mark=
this.component.mark)&&void 0!==_this$component$mark?_this$component$mark:[];this.parent&&isLayerModel(this.parent)||(marks=assembleUnitSelectionMarks(this,marks));return marks.map(this.correctDataNames)}getMapping(){return this.encoding}get mark(){return this.markDef.type}channelHasField(channel){return channelHasField(this.encoding,channel)}fieldDef(channel){return getFieldDef(this.encoding[channel])}typedFieldDef(channel){channel=this.fieldDef(channel);return isTypedFieldDef(channel)?channel:null}}
class LayerModel extends Model{constructor(spec,parent,parentGivenName,parentGivenSize,config){super(spec,"layer",parent,parentGivenName,config,spec.resolve,spec.view);_defineProperty(this,"children",void 0);const layoutSize=Object.assign({},parentGivenSize,spec.width?{width:spec.width}:{},spec.height?{height:spec.height}:{});this.children=spec.layer.map((layer,i)=>{if("layer"in layer)return new LayerModel(layer,this,this.getName("layer_"+i),layoutSize,config);if(isUnitSpec(layer))return new UnitModel(layer,
this,this.getName("layer_"+i),layoutSize,config);throw Error(invalidSpec(layer));})}parseData(){this.component.data=parseData(this);for(const child of this.children)child.parseData()}parseLayoutSize(){parseChildrenLayoutSize(this);parseNonUnitLayoutSizeForChannel(this,"width");parseNonUnitLayoutSizeForChannel(this,"height")}parseSelections(){this.component.selection={};for(const child of this.children){child.parseSelections();for(const key of keys$jscomp$0(child.component.selection))this.component.selection[key]=
child.component.selection[key]}}parseMarkGroup(){for(const child of this.children)child.parseMarkGroup()}parseAxesAndHeaders(){{const {axes,resolve}=this.component,axisCount={top:0,bottom:0,right:0,left:0};for(var child$jscomp$0 of this.children){child$jscomp$0.parseAxesAndHeaders();for(const channel of keys$jscomp$0(child$jscomp$0.component.axes))resolve.axis[channel]=parseGuideResolve(this.component.resolve,channel),"shared"===resolve.axis[channel]&&(axes[channel]=mergeAxisComponents(axes[channel],
child$jscomp$0.component.axes[channel]),axes[channel]||(resolve.axis[channel]="independent",delete axes[channel]))}for(const channel of POSITION_SCALE_CHANNELS){for(const child of this.children)if(child.component.axes[channel]){if("independent"===resolve.axis[channel]){var _axes$channel;axes[channel]=(null!==(_axes$channel=axes[channel])&&void 0!==_axes$channel?_axes$channel:[]).concat(child.component.axes[channel]);for(const axisComponent of child.component.axes[channel]){const {value:orient,explicit}=
axisComponent.getWithExplicit("orient");isSignalRef(orient)||(0<axisCount[orient]&&!explicit&&(child$jscomp$0=OPPOSITE_ORIENT[orient],axisCount[orient]>axisCount[child$jscomp$0]&&axisComponent.set("orient",child$jscomp$0,!1)),axisCount[orient]++)}}delete child.component.axes[channel]}if("independent"===resolve.axis[channel]&&axes[channel]&&1<axes[channel].length)for(const axisCmpt of axes[channel])axisCmpt.get("grid")&&!axisCmpt.explicit.grid&&(axisCmpt.implicit.grid=!1)}}}assembleSelectionTopLevelSignals(signals){return this.children.reduce((sg,
child)=>child.assembleSelectionTopLevelSignals(sg),signals)}assembleSignals(){return this.children.reduce((signals,child)=>signals.concat(child.assembleSignals()),assembleAxisSignals(this))}assembleLayoutSignals(){return this.children.reduce((signals,child)=>signals.concat(child.assembleLayoutSignals()),assembleLayoutSignals(this))}assembleSelectionData(data){return this.children.reduce((db,child)=>child.assembleSelectionData(db),data)}assembleTitle(){let title=super.assembleTitle();if(title)return title;
for(const child of this.children)if(title=child.assembleTitle())return title}assembleLayout(){return null}assembleMarks(){return assembleLayerSelectionMarks(this,this.children.flatMap(child=>child.assembleMarks()))}assembleLegends(){return this.children.reduce((legends,child)=>legends.concat(child.assembleLegends()),assembleLegends(this))}}exports.accessPathDepth=accessPathDepth;exports.accessPathWithDatum=accessPathWithDatum;exports.compile=function(inputSpec,opt){opt=void 0===opt?{}:opt;opt.logger&&
(current=opt.logger);opt.fieldTitle&&(titleFormatter=opt.fieldTitle);try{const config=initConfig(mergeConfig(opt.config,inputSpec.config)),spec=normalize$jscomp$0(inputSpec,config),model=buildModel(spec,null,"",void 0,config);model.parse();{var data=model.component.data,model$jscomp$0=model;checkLinks(data.sources);let firstPassCounter=0,secondPassCounter=0;for(var i=0;5>i&&optimizationDataflowHelper(data,model$jscomp$0,!0);i++)firstPassCounter++;data.sources.map(moveFacetDown);for(i=0;5>i&&optimizationDataflowHelper(data,
model$jscomp$0,!1);i++)secondPassCounter++;checkLinks(data.sources);5===Math.max(firstPassCounter,secondPassCounter)&&warn("Maximum optimization runs(".concat(5,") reached."))}{var autosize=spec.autosize;data=config;model$jscomp$0=model;const width=model$jscomp$0.component.layoutSize.get("width"),height=model$jscomp$0.component.layoutSize.get("height");void 0===autosize?(autosize={type:"pad"},model$jscomp$0.hasAxisOrientSignalRef()&&(autosize.resize=!0)):isString(autosize)&&(autosize={type:autosize});
var JSCompiler_temp;if(JSCompiler_temp=width&&height){var autoSizeType=autosize.type;JSCompiler_temp="fit"===autoSizeType||"fit-x"===autoSizeType||"fit-y"===autoSizeType}if(JSCompiler_temp)if("step"===width&&"step"===height)warn(droppingFit()),autosize.type="pad";else if("step"===width||"step"===height){autoSizeType="step"===width?"width":"height";warn(droppingFit(getPositionScaleChannel(autoSizeType)));JSCompiler_temp=autosize;var JSCompiler_inline_result=(autoSizeType="width"===autoSizeType?"height":
"width","fit-".concat(getPositionScaleChannel(autoSizeType)));JSCompiler_temp.type=JSCompiler_inline_result}var JSCompiler_inline_result$jscomp$0=Object.assign({},1===keys$jscomp$0(autosize).length&&autosize.type?"pad"===autosize.type?{}:{autosize:autosize.type}:{autosize},extractTopLevelProperties(data,!1),extractTopLevelProperties(inputSpec,!0))}return{spec:assembleTopLevelModel(model,JSCompiler_inline_result$jscomp$0,inputSpec.datasets,inputSpec.usermeta),normalized:spec}}finally{opt.logger&&(current=
main$jscomp$0),opt.fieldTitle&&(titleFormatter=defaultTitleFormatter)}};exports.contains=contains;exports.deepEqual=deepEqual;exports.deleteNestedProperty=deleteNestedProperty;exports.duplicate=duplicate;exports.entries=entries;exports.every=every;exports.fieldIntersection=fieldIntersection;exports.flatAccessWithDatum=flatAccessWithDatum;exports.getFirstDefined=getFirstDefined;exports.hasIntersection=hasIntersection;exports.hash=hash;exports.internalField=internalField;exports.isBoolean=isBoolean$1;
exports.isEmpty=isEmpty;exports.isEqual=function(dict,other){const dictKeys=keys$jscomp$0(dict),otherKeys=keys$jscomp$0(other);if(dictKeys.length!==otherKeys.length)return!1;for(const key of dictKeys)if(dict[key]!==other[key])return!1;return!0};exports.isInternalField=isInternalField;exports.isNullOrFalse=isNullOrFalse;exports.isNumeric=isNumeric;exports.keys=keys$jscomp$0;exports.logicalExpr=logicalExpr;exports.mergeDeep=mergeDeep;exports.normalize=normalize$jscomp$0;exports.normalizeAngle=normalizeAngle;
exports.omit=omit;exports.pick=pick;exports.prefixGenerator=prefixGenerator;exports.removePathFromField=removePathFromField;exports.replaceAll=replaceAll;exports.replacePathInField=replacePathInField;exports.resetIdCounter=function(){idCounter=42};exports.setEqual=setEqual;exports.some=some;exports.stringify=stringify;exports.titleCase=titleCase;exports.unique=unique;exports.uniqueId=uniqueId;exports.vals=vals$jscomp$0;exports.varName=varName;exports.version="4.17.0";Object.defineProperty(exports,
"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_lite$build$vega_lite.js.map
