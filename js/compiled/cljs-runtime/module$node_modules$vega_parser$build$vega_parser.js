shadow$provide.module$node_modules$vega_parser$build$vega_parser=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0,require("module$node_modules$vega_util$build$vega_util"),require("module$node_modules$vega_functions$build$vega_functions"),require("module$node_modules$vega_event_selector$build$vega_event_selector"),require("module$node_modules$vega_scale$build$vega_scale"),require("module$node_modules$vega_dataflow$build$vega_dataflow")):
"function"===typeof define&&define.amd?define("exports vega-util vega-functions vega-event-selector vega-scale vega-dataflow".split(" "),factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.vega={},global.vega,global.vega,global.vega,global.vega,global.vega))})(this,function(exports,vegaUtil,vegaFunctions,vegaEventSelector,vegaScale,vegaDataflow){function parseAutosize(spec){return vegaUtil.isObject(spec)?spec:{type:spec||"pad"}}function parsePadding(spec){vegaUtil.isObject(spec)?
spec=spec.signal?spec:{top:+spec.top||0,bottom:+spec.bottom||0,left:+spec.left||0,right:+spec.right||0}:(spec=+spec||0,spec={top:spec,bottom:spec,left:spec,right:spec});return spec}function addEncode(object,name,value,set){return null!=value?(vegaUtil.isObject(value)&&!vegaUtil.isArray(value)||vegaUtil.isArray(value)&&value.length&&vegaUtil.isObject(value[0])?object.update[name]=value:object[set||"enter"][name]={value},1):0}function addEncoders(object,enter,update){for(const name in enter)addEncode(object,
name,enter[name]);for(const name in update)addEncode(object,name,update[name],"update")}function extendEncode(encode,extra,skip){for(const name in extra)skip&&vegaUtil.hasOwnProperty(skip,name)||(encode[name]=vegaUtil.extend(encode[name]||{},extra[name]));return encode}function has(key,encode){return encode&&(encode.enter&&encode.enter[key]||encode.update&&encode.update[key])}function applyDefaults(encode,type,role,style,config){const defaults={},enter={};let update,key$jscomp$0;key$jscomp$0="lineBreak";
"text"!==type||null==config[key$jscomp$0]||has(key$jscomp$0,encode)||applyDefault(defaults,key$jscomp$0,config[key$jscomp$0]);if("legend"==role||String(role).startsWith("axis"))role=null;role="frame"===role?config.group:"mark"===role?vegaUtil.extend({},config.mark,config[type]):null;for(key$jscomp$0 in role)(type=has(key$jscomp$0,encode)||("fill"===key$jscomp$0||"stroke"===key$jscomp$0)&&(has("fill",encode)||has("stroke",encode)))||applyDefault(defaults,key$jscomp$0,role[key$jscomp$0]);vegaUtil.array(style).forEach(name=>
{name=config.style&&config.style[name];for(const key in name)has(key,encode)||applyDefault(defaults,key,name[key])});encode=vegaUtil.extend({},encode);for(key$jscomp$0 in defaults)role=defaults[key$jscomp$0],role.signal?(update=update||{})[key$jscomp$0]=role:enter[key$jscomp$0]=role;encode.enter=vegaUtil.extend(enter,encode.enter);update&&(encode.update=vegaUtil.extend(update,encode.update));return encode}function applyDefault(defaults,key,value){defaults[key]=value&&value.signal?{signal:value.signal}:
{value}}function entry$jscomp$0(enc){if(null!=enc.gradient)return gradient(enc);if(enc.signal)var JSCompiler_temp=`(${enc.signal})`;else enc.color?(JSCompiler_temp=enc.color,JSCompiler_temp=JSCompiler_temp.c?_color("hcl",JSCompiler_temp.h,JSCompiler_temp.c,JSCompiler_temp.l):JSCompiler_temp.h||JSCompiler_temp.s?_color("hsl",JSCompiler_temp.h,JSCompiler_temp.s,JSCompiler_temp.l):JSCompiler_temp.l||JSCompiler_temp.a?_color("lab",JSCompiler_temp.l,JSCompiler_temp.a,JSCompiler_temp.b):JSCompiler_temp.r||
JSCompiler_temp.g||JSCompiler_temp.b?_color("rgb",JSCompiler_temp.r,JSCompiler_temp.g,JSCompiler_temp.b):null):JSCompiler_temp=null!=enc.field?field$jscomp$0(enc.field):void 0!==enc.value?vegaUtil.stringValue(enc.value):void 0;if(null!=enc.scale){{const scale=scaleRef(enc.scale);null!=enc.range?JSCompiler_temp=`lerp(_range(${scale}), ${+enc.range})`:(void 0!==JSCompiler_temp&&(JSCompiler_temp=`_scale(${scale}, ${JSCompiler_temp})`),enc.band&&(JSCompiler_temp=(JSCompiler_temp?JSCompiler_temp+"+":"")+
`_bandwidth(${scale})`+(1===+enc.band?"":"*"+property$jscomp$0(enc.band)),enc.extra&&(JSCompiler_temp=`(datum.extra ? _scale(${scale}, datum.extra.value) : ${JSCompiler_temp})`)),null==JSCompiler_temp&&(JSCompiler_temp="0"))}}void 0===JSCompiler_temp&&(JSCompiler_temp=null);null!=enc.exponent&&(JSCompiler_temp=`pow(${JSCompiler_temp},${property$jscomp$0(enc.exponent)})`);null!=enc.mult&&(JSCompiler_temp+=`*${property$jscomp$0(enc.mult)}`);null!=enc.offset&&(JSCompiler_temp+=`+${property$jscomp$0(enc.offset)}`);
enc.round&&(JSCompiler_temp=`round(${JSCompiler_temp})`);return JSCompiler_temp}function gradient(enc){const args=[enc.start,enc.stop,enc.count].map(_=>null==_?null:vegaUtil.stringValue(_));for(;args.length&&null==vegaUtil.peek(args);)args.pop();args.unshift(scaleRef(enc.gradient));return`gradient(${args.join(",")})`}function property$jscomp$0(property){return vegaUtil.isObject(property)?"("+entry$jscomp$0(property)+")":property}function field$jscomp$0(ref){return resolveField(vegaUtil.isObject(ref)?
ref:{datum:ref})}function resolveField(ref){let object;if(ref.signal){object="datum";var level=ref.signal}else if(ref.group||ref.parent){level=Math.max(1,ref.level||1);for(object="item";0<level--;)object+=".mark.group";ref.parent?(level=ref.parent,object+=".datum"):level=ref.group}else ref.datum?(object="datum",level=ref.datum):vegaUtil.error("Invalid field reference: "+vegaUtil.stringValue(ref));ref.signal||(level=vegaUtil.isString(level)?vegaUtil.splitAccessPath(level).map(vegaUtil.stringValue).join("]["):
resolveField(level));return object+"["+level+"]"}function rule$jscomp$0(enc){let code="";enc.forEach(rule=>{const value=entry$jscomp$0(rule);code+=rule.test?`(${rule.test})?${value}:`:value});":"===vegaUtil.peek(code)&&(code+="null");return code}function parseEncode(encode,type,role,style,scope$jscomp$0,params$jscomp$0){const enc={};params$jscomp$0=params$jscomp$0||{};params$jscomp$0.encoders={$encode:enc};encode=applyDefaults(encode,type,role,style,scope$jscomp$0.config);for(const key in encode){{role=
encode[key];style=type;var params=params$jscomp$0,scope=scope$jscomp$0;const channels={},fields={};for(const name in role)if(null!=role[name]){var JSCompiler_inline_result=role[name];JSCompiler_inline_result=vegaUtil.isArray(JSCompiler_inline_result)?rule$jscomp$0(JSCompiler_inline_result):entry$jscomp$0(JSCompiler_inline_result);channels[name]=parse(JSCompiler_inline_result,scope,params,fields)}role={$expr:{marktype:style,channels},$fields:Object.keys(fields),$output:Object.keys(role)}}enc[key]=
role}return params$jscomp$0}function parse(code,scope,params,fields){code=vegaFunctions.parseExpression(code,scope);code.$fields.forEach(name=>fields[name]=1);vegaUtil.extend(params,code.$params);return code.$expr}function outerError(prefix,name){vegaUtil.error(prefix+' for "outer" push: '+vegaUtil.stringValue(name))}function parseSignal(signal,scope){const name=signal.name;if("outer"===signal.push)scope.signals[name]||outerError("No prior signal definition",name),OUTER_INVALID.forEach(prop=>{void 0!==
signal[prop]&&outerError("Invalid property ",prop)});else{const op=scope.addSignal(name,signal.value);!1===signal.react&&(op.react=!1);signal.bind&&scope.addBinding(name,signal.bind)}}function Entry(type,value,params,parent){this.id=-1;this.type=type;this.value=value;this.params=params;parent&&(this.parent=parent)}function ref$jscomp$0(op){const ref={$ref:op.id};0>op.id&&(op.refs=op.refs||[]).push(ref);return ref}function fieldRef(field,name){return name?{$field:field,$name:name}:{$field:field}}function keyRef(fields,
flat){fields={$key:fields};flat&&(fields.$flat=!0);return fields}function aggrField(op,field){return(op&&op.signal?"$"+op.signal:op||"")+(op&&field?"_":"")+(field&&field.signal?"$"+field.signal:field||"")}function isSignal(_){return _&&_.signal}function hasSignal(_){if(isSignal(_))return!0;if(vegaUtil.isObject(_))for(const key in _)if(hasSignal(_[key]))return!0;return!1}function value$jscomp$0(specValue,defaultValue){return null!=specValue?specValue:defaultValue}function deref(v){return v&&v.signal||
v}function parseStream(stream,scope){return(stream.merge?mergeStream:stream.stream?nestedStream:stream.type?eventStream:vegaUtil.error("Invalid stream specification: "+vegaUtil.stringValue(stream)))(stream,scope)}function eventSource(source){return"scope"===source?"view":source||"view"}function mergeStream(stream,scope){const list=stream.merge.map(s=>parseStream(s,scope));stream=streamParameters({merge:list},stream,scope);return scope.addStream(stream).id}function nestedStream(stream,scope){const id=
parseStream(stream.stream,scope);stream=streamParameters({stream:id},stream,scope);return scope.addStream(stream).id}function eventStream(stream,scope){let id;"timer"===stream.type?(id=scope.event("timer",stream.throttle),stream={between:stream.between,filter:stream.filter}):id=scope.event(eventSource(stream.source),stream.type);stream=streamParameters({stream:id},stream,scope);return 1===Object.keys(stream).length?id:scope.addStream(stream).id}function streamParameters(entry,stream,scope){let param=
stream.between;param&&(2!==param.length&&vegaUtil.error('Stream "between" parameter must have 2 entries: '+vegaUtil.stringValue(stream)),entry.between=[parseStream(param[0],scope),parseStream(param[1],scope)]);param=stream.filter?[].concat(stream.filter):[];(stream.marktype||stream.markname||stream.markrole)&&param.push(filterMark(stream.marktype,stream.markname,stream.markrole));"scope"===stream.source&&param.push("inScope(event.item)");param.length&&(entry.filter=vegaFunctions.parseExpression("("+
param.join(")\x26\x26(")+")",scope).$expr);null!=(param=stream.throttle)&&(entry.throttle=+param);null!=(param=stream.debounce)&&(entry.debounce=+param);stream.consume&&(entry.consume=!0);return entry}function filterMark(type,name,role){return"event.item"+(type&&"*"!==type?"\x26\x26event.item.mark.marktype\x3d\x3d\x3d'"+type+"'":"")+(role?"\x26\x26event.item.mark.role\x3d\x3d\x3d'"+role+"'":"")+(name?"\x26\x26event.item.mark.name\x3d\x3d\x3d'"+name+"'":"")}function parseUpdate(spec,scope,target){const encode=
spec.encode,entry={target};target=spec.events;let update=spec.update,sources=[];target||vegaUtil.error("Signal update missing events specification.");vegaUtil.isString(target)&&(target=vegaEventSelector.selector(target,scope.isSubscope()?"scope":"view"));target=vegaUtil.array(target).filter(s=>s.signal||s.scale?(sources.push(s),0):1);1<sources.length&&(sources=[mergeSources(sources)]);target.length&&sources.push(1<target.length?{merge:target}:target[0]);null!=encode&&(update&&vegaUtil.error("Signal encode and update are mutually exclusive."),
update="encode(item(),"+vegaUtil.stringValue(encode)+")");entry.update=vegaUtil.isString(update)?vegaFunctions.parseExpression(update,scope):null!=update.expr?vegaFunctions.parseExpression(update.expr,scope):null!=update.value?update.value:null!=update.signal?{$expr:OP_VALUE_EXPR,$params:{$value:scope.signalRef(update.signal)}}:vegaUtil.error("Invalid signal update specification.");spec.force&&(entry.options={force:!0});sources.forEach(source=>scope.addUpdate(vegaUtil.extend(streamSource(source,scope),
entry)))}function streamSource(stream,scope){return{source:stream.signal?scope.signalRef(stream.signal):stream.scale?scope.scaleRef(stream.scale):parseStream(stream,scope)}}function mergeSources(sources){return{signal:"["+sources.map(s=>s.scale?'scale("'+s.scale+'")':s.signal)+"]"}}function parseSignalUpdates(signal,scope){const op=scope.getSignal(signal.name);let expr=signal.update;signal.init&&(expr?vegaUtil.error("Signals can not include both init and update expressions."):(expr=signal.init,op.initonly=
!0));expr&&(expr=vegaFunctions.parseExpression(expr,scope),op.update=expr.$expr,op.params=expr.$params);signal.on&&signal.on.forEach(_=>parseUpdate(_,scope,op.id))}function parseLiteral(v,scope){return vegaUtil.isObject(v)?v.signal?scope.signalRef(v.signal):vegaUtil.error("Unsupported object: "+vegaUtil.stringValue(v)):v}function parseArray(v$jscomp$0,scope){return v$jscomp$0.signal?scope.signalRef(v$jscomp$0.signal):v$jscomp$0.map(v=>parseLiteral(v,scope))}function dataLookupError(name){vegaUtil.error("Can not find data set: "+
vegaUtil.stringValue(name))}function parseScaleDomain(domain,spec,scope){if(domain)return domain.signal?scope.signalRef(domain.signal):(vegaUtil.isArray(domain)?explicitDomain:domain.fields?multipleDomain:singularDomain)(domain,spec,scope);null==spec.domainMin&&null==spec.domainMax||vegaUtil.error("No scale domain defined for domainMin/domainMax to override.")}function explicitDomain(domain,spec,scope){return domain.map(v=>parseLiteral(v,scope))}function singularDomain(domain,spec,scope){const data=
scope.getData(domain.data);data||dataLookupError(domain.data);return vegaScale.isDiscrete(spec.type)?data.valuesRef(scope,domain.field,parseSort(domain.sort,!1)):vegaScale.isQuantile(spec.type)?data.domainRef(scope,domain.field):data.extentRef(scope,domain.field)}function multipleDomain(domain,spec,scope){const data$jscomp$0=domain.data,fields=domain.fields.reduce((dom,d)=>{if(vegaUtil.isString(d))d={data:data$jscomp$0,field:d};else if(vegaUtil.isArray(d)||d.signal){{var data=d;d="_:vega:_"+FIELD_REF_ID++;
const coll=Collect({});vegaUtil.isArray(data)?coll.value={$ingest:data}:data.signal&&(data="setdata("+vegaUtil.stringValue(d)+","+data.signal+")",coll.params.input=scope.signalRef(data));scope.addDataPipeline(d,[coll,Sieve({})]);d={data:d,field:"data"}}}dom.push(d);return dom},[]);return(vegaScale.isDiscrete(spec.type)?ordinalMultipleDomain:vegaScale.isQuantile(spec.type)?quantileMultipleDomain:numericMultipleDomain)(domain,scope,fields)}function ordinalMultipleDomain(domain,scope,fields){const sort=
parseSort(domain.sort,!0);domain=fields.map(f=>{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.countsRef(scope,f.field,sort)});const p={groupby:keyFieldRef,pulse:domain};sort&&(domain=sort.op||"count",fields=sort.field?aggrField(domain,sort.field):"count",p.ops=[MULTIDOMAIN_SORT_OPS[domain]],p.fields=[scope.fieldRef(fields)],p.as=[fields]);domain=scope.add(Aggregate(p));domain=scope.add(Collect({pulse:ref$jscomp$0(domain)}));fields=scope.add(Values({field:keyFieldRef,sort:scope.sortRef(sort),
pulse:ref$jscomp$0(domain)}));return ref$jscomp$0(fields)}function parseSort(sort,multidomain){sort&&(sort.field||sort.op?sort.field||"count"===sort.op?multidomain&&sort.field&&sort.op&&!MULTIDOMAIN_SORT_OPS[sort.op]&&vegaUtil.error("Multiple domain scales can not be sorted using "+sort.op):vegaUtil.error("No field provided for sort aggregate op: "+sort.op):vegaUtil.isObject(sort)?sort.field="key":sort={field:"key"});return sort}function quantileMultipleDomain(domain,scope,fields){domain=fields.map(f=>
{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.domainRef(scope,f.field)});return ref$jscomp$0(scope.add(MultiValues({values:domain})))}function numericMultipleDomain(domain,scope,fields){domain=fields.map(f=>{const data=scope.getData(f.data);data||dataLookupError(f.data);return data.extentRef(scope,f.field)});return ref$jscomp$0(scope.add(MultiExtent({extents:domain})))}function parseScaleRange(spec,scope,params){const config=scope.config.range;let range=spec.range;if(range.signal)return scope.signalRef(range.signal);
if(vegaUtil.isString(range)){if(config&&vegaUtil.hasOwnProperty(config,range))return spec=vegaUtil.extend({},spec,{range:config[range]}),parseScaleRange(spec,scope,params);"width"===range?range=[0,{signal:"width"}]:"height"===range?range=vegaScale.isDiscrete(spec.type)?[0,{signal:"height"}]:[{signal:"height"},0]:vegaUtil.error("Unrecognized scale range value: "+vegaUtil.stringValue(range))}else{if(range.scheme){params.scheme=vegaUtil.isArray(range.scheme)?parseArray(range.scheme,scope):parseLiteral(range.scheme,
scope);range.extent&&(params.schemeExtent=parseArray(range.extent,scope));range.count&&(params.schemeCount=parseLiteral(range.count,scope));return}if(range.step){params.rangeStep=parseLiteral(range.step,scope);return}if(vegaScale.isDiscrete(spec.type)&&!vegaUtil.isArray(range))return parseScaleDomain(range,spec,scope);vegaUtil.isArray(range)||vegaUtil.error("Unsupported range type: "+vegaUtil.stringValue(range))}return range.map(v=>(vegaUtil.isArray(v)?parseArray:parseLiteral)(v,scope))}function parseParameter(_$jscomp$0,
name,scope){return vegaUtil.isArray(_$jscomp$0)?_$jscomp$0.map(_=>parseParameter(_,name,scope)):vegaUtil.isObject(_$jscomp$0)?_$jscomp$0.signal?scope.signalRef(_$jscomp$0.signal):"fit"===name?_$jscomp$0:vegaUtil.error("Unsupported parameter object: "+vegaUtil.stringValue(_$jscomp$0)):_$jscomp$0}function guideGroup(mark){mark.type="group";mark.interactive=mark.interactive||!1;return mark}function lookup$jscomp$0(spec,config){const _=(name,dflt)=>value$jscomp$0(spec[name],value$jscomp$0(config[name],
dflt));_.isVertical=s=>"vertical"===value$jscomp$0(spec.direction,config.direction||(s?config.symbolDirection:config.gradientDirection));_.gradientLength=()=>value$jscomp$0(spec.gradientLength,config.gradientLength||config.gradientWidth);_.gradientThickness=()=>value$jscomp$0(spec.gradientThickness,config.gradientThickness||config.gradientHeight);_.entryColumns=()=>value$jscomp$0(spec.columns,value$jscomp$0(config.columns,+_.isVertical(!0)));return _}function getEncoding(name,encode){return(name=
encode&&(encode.update&&encode.update[name]||encode.enter&&encode.enter[name]))&&name.signal?name:name?name.value:null}function anchorExpr(s,e,m){return`item.anchor === '${"start"}' ? ${s} : item.anchor === '${"end"}' ? ${e} : ${m}`}function extendOffset(value,offset){return offset?value?vegaUtil.isObject(value)?Object.assign({},value,{offset:extendOffset(value.offset,offset)}):{value,offset}:offset:value}function guideMark(mark,extras){extras?(mark.name=extras.name,mark.style=extras.style||mark.style,
mark.interactive=!!extras.interactive,mark.encode=extendEncode(mark.encode,extras,Skip)):mark.interactive=!1;return mark}function legendGradient(spec,scale,config,userEncode){spec=lookup$jscomp$0(spec,config);var vertical=spec.isVertical();config=spec.gradientThickness();const length=spec.gradientLength();let enter,stop,width;vertical?(vertical=[0,1],stop=[0,0],width=config,config=length):(vertical=[0,0],stop=[1,0],width=length);scale={enter:enter={opacity:zero$jscomp$0,x:zero$jscomp$0,y:zero$jscomp$0,
width:encoder(width),height:encoder(config)},update:vegaUtil.extend({},enter,{opacity:one,fill:{gradient:scale,start:vertical,stop}}),exit:{opacity:zero$jscomp$0}};addEncoders(scale,{stroke:spec("gradientStrokeColor"),strokeWidth:spec("gradientStrokeWidth")},{opacity:spec("gradientOpacity")});return guideMark({type:"rect",role:"legend-gradient",encode:scale},userEncode)}function legendGradientDiscrete(spec,scale,config,userEncode,dataRef){spec=lookup$jscomp$0(spec,config);const vertical=spec.isVertical();
config=spec.gradientThickness();const length=spec.gradientLength();var u;let v,uu,vv,adjust="";vertical?(u="y",uu="y2",v="x",vv="width",adjust="1-"):(u="x",uu="x2",v="y",vv="height");scale={opacity:zero$jscomp$0,fill:{scale,field:"value"}};scale[u]={signal:adjust+"datum.perc",mult:length};scale[v]=zero$jscomp$0;scale[uu]={signal:adjust+"datum.perc2",mult:length};scale[vv]=encoder(config);u={enter:scale,update:vegaUtil.extend({},scale,{opacity:one}),exit:{opacity:zero$jscomp$0}};addEncoders(u,{stroke:spec("gradientStrokeColor"),
strokeWidth:spec("gradientStrokeWidth")},{opacity:spec("gradientOpacity")});return guideMark({type:"rect",role:"legend-band",key:"value",from:dataRef,encode:u},userEncode)}function legendGradientLabels(spec,config,userEncode,dataRef){const _=lookup$jscomp$0(spec,config);var vertical=_.isVertical();const thickness=encoder(_.gradientThickness()),length=_.gradientLength();let overlap=_("labelOverlap"),enter,update,v,adjust="";const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one,
text:{field:"label"}},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{fill:_("labelColor"),fillOpacity:_("labelOpacity"),font:_("labelFont"),fontSize:_("labelFontSize"),fontStyle:_("labelFontStyle"),fontWeight:_("labelFontWeight"),limit:value$jscomp$0(spec.labelLimit,config.gradientLabelLimit)});vertical?(enter.align={value:"left"},enter.baseline=update.baseline={signal:'datum.perc\x3c\x3d0?"bottom":datum.perc\x3e\x3d1?"top":"middle"'},vertical="y",v="x",adjust="1-"):(enter.align=update.align={signal:'datum.perc\x3c\x3d0?"left":datum.perc\x3e\x3d1?"right":"center"'},
enter.baseline={value:"top"},vertical="x",v="y");enter[vertical]=update[vertical]={signal:adjust+"datum.perc",mult:length};enter[v]=update[v]=thickness;thickness.offset=value$jscomp$0(spec.labelOffset,config.gradientLabelOffset)||0;overlap=overlap?{separation:_("labelSeparation"),method:overlap,order:"datum.index"}:void 0;return guideMark({type:"text",role:"legend-label",style:"guide-label",key:"value",from:dataRef,encode,overlap},userEncode)}function legendSymbolGroups(spec,config,userEncode,dataRef,
columns){var _=lookup$jscomp$0(spec,config);const entries=userEncode.entries,interactive=!(!entries||!entries.interactive),name=entries?entries.name:void 0,height=_("clipHeight"),symbolOffset=_("symbolOffset"),valueRef={data:"value"},xSignal=`(${columns}) ? datum.${"offset"} : datum.${"size"}`,yEncode=height?encoder(height):{field:"size"},ncols=`max(1, ${columns})`;let enter,update;yEncode.mult=.5;var encode={enter:enter={opacity:zero$jscomp$0,x:{signal:xSignal,mult:.5,offset:symbolOffset},y:yEncode},
update:update={opacity:one,x:enter.x,y:enter.y},exit:{opacity:zero$jscomp$0}};let baseFill=null,baseStroke=null;spec.fill||(baseFill=config.symbolBaseFillColor,baseStroke=config.symbolBaseStrokeColor);addEncoders(encode,{fill:_("symbolFillColor",baseFill),shape:_("symbolType"),size:_("symbolSize"),stroke:_("symbolStrokeColor",baseStroke),strokeDash:_("symbolDash"),strokeDashOffset:_("symbolDashOffset"),strokeWidth:_("symbolStrokeWidth")},{opacity:_("symbolOpacity")});LegendScales.forEach(scale=>{spec[scale]&&
(update[scale]=enter[scale]={scale:spec[scale],field:"value"})});config=guideMark({type:"symbol",role:"legend-symbol",key:"value",from:valueRef,clip:height?!0:void 0,encode},userEncode.symbols);encode=encoder(symbolOffset);encode.offset=_("labelOffset");encode={enter:enter={opacity:zero$jscomp$0,x:{signal:xSignal,offset:encode},y:yEncode},update:update={opacity:one,text:{field:"label"},x:enter.x,y:enter.y},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{align:_("labelAlign"),baseline:_("labelBaseline"),
fill:_("labelColor"),fillOpacity:_("labelOpacity"),font:_("labelFont"),fontSize:_("labelFontSize"),fontStyle:_("labelFontStyle"),fontWeight:_("labelFontWeight"),limit:_("labelLimit")});userEncode=guideMark({type:"text",role:"legend-label",style:"guide-label",key:"value",from:valueRef,encode},userEncode.labels);encode={enter:{noBound:{value:!height},width:zero$jscomp$0,height:height?encoder(height):zero$jscomp$0,opacity:zero$jscomp$0},exit:{opacity:zero$jscomp$0},update:update={opacity:one,row:{signal:null},
column:{signal:null}}};_.isVertical(!0)?(_=`ceil(item.mark.items.length / ${ncols})`,update.row.signal=`${"datum.index"}%${_}`,update.column.signal=`floor(${"datum.index"} / ${_})`,_={field:["row","datum.index"]}):(update.row.signal=`floor(${"datum.index"} / ${ncols})`,update.column.signal=`${"datum.index"} % ${ncols}`,_={field:"datum.index"});update.column.signal=`(${columns})?${update.column.signal}:${"datum.index"}`;dataRef={facet:{data:dataRef,name:"value",groupby:"index"}};return guideGroup({role:"scope",
from:dataRef,encode:extendEncode(encode,entries,Skip),marks:[config,userEncode],name,interactive,sort:_})}function legendSymbolLayout(spec,config){spec=lookup$jscomp$0(spec,config);return{align:spec("gridAlign"),columns:spec.entryColumns(),center:{row:!0,column:!1},padding:{row:spec("rowPadding"),column:spec("columnPadding")}}}function legendTitle(spec,config,userEncode,dataRef){config=lookup$jscomp$0(spec,config);const encode={enter:{opacity:zero$jscomp$0},update:{opacity:one,x:{field:{group:"padding"}},
y:{field:{group:"padding"}}},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{orient:config("titleOrient"),_anchor:config("titleAnchor"),anchor:{signal:'item._anchor || ((item.orient \x3d\x3d\x3d "left" || item.orient \x3d\x3d\x3d "right") ? "middle" : "start")'},angle:{signal:'datum.vgrad \x26\x26 (item.orient \x3d\x3d\x3d "left" || item.orient \x3d\x3d\x3d "right") ? (item.orient \x3d\x3d\x3d "left" ? -90 : 90) : 0'},align:{signal:exprAlign},baseline:{signal:exprBaseline},text:spec.title,fill:config("titleColor"),
fillOpacity:config("titleOpacity"),font:config("titleFont"),fontSize:config("titleFontSize"),fontStyle:config("titleFontStyle"),fontWeight:config("titleFontWeight"),limit:config("titleLimit"),lineHeight:config("titleLineHeight")},{align:config("titleAlign"),baseline:config("titleBaseline")});return guideMark({type:"text",role:"legend-title",style:"guide-title",from:dataRef,encode},userEncode)}function clip$jscomp$0(clip,scope){let expr;vegaUtil.isObject(clip)&&(clip.signal?expr=clip.signal:clip.path?
expr="pathShape("+param$jscomp$0(clip.path)+")":clip.sphere&&(expr="geoShape("+param$jscomp$0(clip.sphere)+', {type: "Sphere"})'));return expr?scope.signalRef(expr):!!clip}function param$jscomp$0(value){return vegaUtil.isObject(value)&&value.signal?value.signal:vegaUtil.stringValue(value)}function getRole(spec){const role=spec.role||"";return role.indexOf("axis")&&role.indexOf("legend")&&role.indexOf("title")?"group"===spec.type?"scope":role||"mark":role}function definition(spec){return{marktype:spec.type,
name:spec.name||void 0,role:spec.role||getRole(spec),zindex:+spec.zindex||void 0,aria:spec.aria,description:spec.description}}function interactive(spec,scope){return spec&&spec.signal?scope.signalRef(spec.signal):!1===spec?!1:!0}function parseTransform(spec,scope){const def=vegaDataflow.definition(spec.type);def||vegaUtil.error("Unrecognized transform type: "+vegaUtil.stringValue(spec.type));var JSCompiler_inline_result=def.type.toLowerCase();var params=parseParameters(def,spec,scope);JSCompiler_inline_result=
new Entry(JSCompiler_inline_result,null,params,void 0);spec.signal&&scope.addSignal(spec.signal,scope.proxy(JSCompiler_inline_result));JSCompiler_inline_result.metadata=def.metadata||{};return JSCompiler_inline_result}function parseParameters(def,spec,scope){const params={},n=def.params.length;for(let i=0;i<n;++i){const pdef=def.params[i];params[pdef.name]=parseParameter$1(pdef,spec,scope)}return params}function parseParameter$1(def,spec,scope){const type=def.type,value=spec[def.name];if("index"===
type)return parseIndexParameter(def,spec,scope);if(void 0===value)def.required&&vegaUtil.error("Missing required "+vegaUtil.stringValue(spec.type)+" parameter: "+vegaUtil.stringValue(def.name));else return"param"===type?parseSubParameters(def,spec,scope):"projection"===type?scope.projectionRef(spec[def.name]):def.array&&!isSignal(value)?value.map(v=>parameterValue(def,v,scope)):parameterValue(def,value,scope)}function parameterValue(def,value,scope){const type=def.type;return isSignal(value)?"expr"===
type?vegaUtil.error("Expression references can not be signals."):"field"===type?scope.fieldRef(value):"compare"===type?scope.compareRef(value):scope.signalRef(value.signal):(def=def.expr||"field"===type)&&value&&value.expr?scope.exprRef(value.expr,value.as):def&&value&&value.field?fieldRef(value.field,value.as):"expr"===type?vegaFunctions.parseExpression(value,scope):"data"===type?ref$jscomp$0(scope.getData(value).values):"field"===type?fieldRef(value):"compare"===type?scope.compareRef(value):value}
function parseIndexParameter(def,spec,scope){vegaUtil.isString(spec.from)||vegaUtil.error('Lookup "from" parameter must be a string literal.');return scope.getData(spec.from).lookupRef(scope,spec.key)}function parseSubParameters(def,spec,scope){spec=spec[def.name];return def.array?(vegaUtil.isArray(spec)||vegaUtil.error("Expected an array of sub-parameters. Instead: "+vegaUtil.stringValue(spec)),spec.map(v=>parseSubParameter(def,v,scope))):parseSubParameter(def,spec,scope)}function parseSubParameter(def,
value,scope){const n=def.params.length;let pdef;for(let i=0;i<n;++i){pdef=def.params[i];for(const k in pdef.key)if(pdef.key[k]!==value[k]){pdef=null;break}if(pdef)break}pdef||vegaUtil.error("Unsupported parameter: "+vegaUtil.stringValue(value));def=vegaUtil.extend(parseParameters(pdef,value,scope),pdef.key);return ref$jscomp$0(scope.add(Params(def)))}function parseData(from,group,scope){let facet,key,dataRef,parent;if(!from)dataRef=ref$jscomp$0(scope.add(Collect(null,[{}])));else if(facet=from.facet)group||
vegaUtil.error("Only group marks can be faceted."),null!=facet.field?dataRef=parent=getDataRef(facet,scope):(from.data?parent=ref$jscomp$0(scope.getData(from.data).aggregate):(group=parseTransform(vegaUtil.extend({type:"aggregate",groupby:vegaUtil.array(facet.groupby)},facet.aggregate),scope),group.params.key=scope.keyRef(facet.groupby),group.params.pulse=getDataRef(facet,scope),dataRef=parent=ref$jscomp$0(scope.add(group))),key=scope.keyRef(facet.groupby,!0));dataRef||(dataRef=getDataRef(from,scope));
return{key,pulse:dataRef,parent}}function getDataRef(from,scope){return from.$ref?from:from.data&&from.data.$ref?from.data:ref$jscomp$0(scope.getData(from.data).output)}function DataScope(scope,input,output,values,aggr){this.scope=scope;this.input=input;this.output=output;this.values=values;this.aggregate=aggr;this.index={}}function fieldKey(field){return vegaUtil.isString(field)?field:null}function addSortField(scope,p,sort){const as=aggrField(sort.op,sort.field);let s;if(p.ops)for(let i=0,n=p.as.length;i<
n;++i){if(p.as[i]===as)return}else p.ops=["count"],p.fields=[null],p.as=["count"];sort.op&&(p.ops.push((s=sort.op.signal)?scope.signalRef(s):sort.op),p.fields.push(scope.fieldRef(sort.field)),p.as.push(as))}function cache$jscomp$0(scope,ds,name,optype,field,counts,index){name=ds[name]||(ds[name]={});var JSCompiler_inline_result=vegaUtil.isObject(counts)?("descending"===counts.order?"-":"+")+aggrField(counts.op,counts.field):"";let k=fieldKey(field);if(null!=k){scope=ds.scope;k+=JSCompiler_inline_result?
"|"+JSCompiler_inline_result:"";var v=name[k]}v||(v=counts?{field:keyFieldRef,pulse:ds.countsRef(scope,field,counts)}:{field:scope.fieldRef(field),pulse:ref$jscomp$0(ds.output)},JSCompiler_inline_result&&(v.sort=scope.sortRef(counts)),scope=scope.add(new Entry(optype,void 0,v,void 0)),index&&(ds.index[field]=scope),v=ref$jscomp$0(scope),null!=k&&(name[k]=v));return v}function parseFacet(spec,scope,group){var facet=spec.from.facet;const name=facet.name,data=getDataRef(facet,scope);let op;facet.name||
vegaUtil.error("Facet must have a name: "+vegaUtil.stringValue(facet));facet.data||vegaUtil.error("Facet must reference a data set: "+vegaUtil.stringValue(facet));facet.field?op=scope.add(PreFacet({field:scope.fieldRef(facet.field),pulse:data})):facet.groupby?op=scope.add(Facet({key:scope.keyRef(facet.groupby),group:ref$jscomp$0(scope.proxy(group.parent)),pulse:data})):vegaUtil.error("Facet must specify groupby or field: "+vegaUtil.stringValue(facet));scope=scope.fork();group=scope.add(Collect());
facet=scope.add(Sieve({pulse:ref$jscomp$0(group)}));scope.addData(name,new DataScope(scope,group,group,facet));scope.addSignal("parent",null);op.params.subflow={$subflow:scope.parse(spec).toRuntime()}}function parseSubflow(spec,scope,input){input=scope.add(PreFacet({pulse:input.pulse}));scope=scope.fork();scope.add(Sieve());scope.addSignal("parent",null);input.params.subflow={$subflow:scope.parse(spec).toRuntime()}}function parseTrigger(spec,scope,name){const remove=spec.remove,insert=spec.insert,
toggle=spec.toggle,modify=spec.modify,values=spec.values,op=scope.add(new Entry("operator",void 0,void 0,void 0));spec="if("+spec.trigger+',modify("'+name+'",'+[insert,remove,toggle,modify,values].map(_=>null==_?"null":_).join(",")+"),0)";scope=vegaFunctions.parseExpression(spec,scope);op.update=scope.$expr;op.params=scope.$params}function parseMark(spec,scope){var role=getRole(spec),group="group"===spec.type,facet=spec.from&&spec.from.facet;const overlap=spec.overlap;let layout=spec.layout||"scope"===
role||"frame"===role,ops,op,store,enc,name,layoutRef;const nested="mark"===role||layout||facet,input=parseData(spec.from,group,scope);op=scope.add(DataJoin({key:input.key||(spec.key?fieldRef(spec.key):void 0),pulse:input.pulse,clean:!group}));const joinRef=ref$jscomp$0(op);op=store=scope.add(Collect({pulse:joinRef}));op=scope.add(Mark({markdef:definition(spec),interactive:interactive(spec.interactive,scope),clip:clip$jscomp$0(spec.clip,scope),context:{$context:!0},groups:scope.lookup(),parent:scope.signals.parent?
scope.signalRef("parent"):null,index:scope.markpath(),pulse:ref$jscomp$0(op)}));var boundRef=ref$jscomp$0(op);op=enc=scope.add(Encode(parseEncode(spec.encode,spec.type,role,spec.style,scope,{mod:!1,pulse:boundRef})));op.params.parent=scope.encode();spec.transform&&spec.transform.forEach(_=>{_=parseTransform(_,scope);const md=_.metadata;(md.generates||md.changes)&&vegaUtil.error("Mark transforms should not generate new data.");md.nomod||(enc.params.mod=!0);_.params.pulse=ref$jscomp$0(op);scope.add(op=
_)});spec.sort&&(op=scope.add(SortItems({sort:scope.compareRef(spec.sort),pulse:ref$jscomp$0(op)})));role=ref$jscomp$0(op);if(facet||layout)layout=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,mark:boundRef,pulse:role})),layoutRef=ref$jscomp$0(layout);const bound=scope.add(Bound({mark:boundRef,pulse:layoutRef||role}));boundRef=ref$jscomp$0(bound);group&&(nested&&(ops=scope.operators,ops.pop(),layout&&ops.pop()),scope.pushState(role,layoutRef||boundRef,joinRef),
facet?parseFacet(spec,scope,input):nested?parseSubflow(spec,scope,input):scope.parse(spec),scope.popState(),nested&&(layout&&ops.push(layout),ops.push(bound)));overlap&&(boundRef=parseOverlap(overlap,boundRef,scope));group=scope.add(Render({pulse:boundRef}));facet=scope.add(Sieve({pulse:ref$jscomp$0(group)},void 0,scope.parent()));null!=spec.name&&(name=spec.name,scope.addData(name,new DataScope(scope,store,group,facet)),spec.on&&spec.on.forEach(on=>{(on.insert||on.remove||on.toggle)&&vegaUtil.error("Marks only support modify triggers.");
parseTrigger(on,scope,name)}))}function parseOverlap(overlap,source,scope){const method=overlap.method,bound=overlap.bound,sep=overlap.separation;source={separation:isSignal(sep)?scope.signalRef(sep.signal):sep,method:isSignal(method)?scope.signalRef(method.signal):method,pulse:source};overlap.order&&(source.sort=scope.compareRef({field:overlap.order}));bound&&(overlap=bound.tolerance,source.boundTolerance=isSignal(overlap)?scope.signalRef(overlap.signal):+overlap,source.boundScale=scope.scaleRef(bound.scale),
source.boundOrient=bound.orient);return ref$jscomp$0(scope.add(Overlap(source)))}function parseLegend(spec,scope){const config=scope.config.legend,encode=spec.encode||{},_=lookup$jscomp$0(spec,config),legendEncode=encode.legend||{},name=legendEncode.name||void 0,interactive=legendEncode.interactive,style=legendEncode.style,scales={};let scale=0,entryLayout,params;LegendScales.forEach(s=>spec[s]?(scales[s]=spec[s],scale=scale||spec[s]):0);scale||vegaUtil.error("Missing valid scale for legend.");var children=
legendType(spec,scope.scaleType(scale));const datum={title:null!=spec.title,scales,type:children,vgrad:"symbol"!==children&&_.isVertical()},dataRef=ref$jscomp$0(scope.add(Collect(null,[datum]))),entryRef=ref$jscomp$0(scope.add(LegendEntries(params={type:children,scale:scope.scaleRef(scale),count:scope.objectProperty(_("tickCount")),limit:scope.property(_("symbolLimit")),values:scope.objectProperty(spec.values),minstep:scope.property(spec.tickMinStep),formatType:scope.property(spec.formatType),formatSpecifier:scope.property(spec.format)})));
"gradient"===children?(children=[legendGradient(spec,scale,config,encode.gradient),legendGradientLabels(spec,config,encode.labels,entryRef)],params.count=params.count||scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`)):"discrete"===children?children=[legendGradientDiscrete(spec,scale,config,encode.gradient,entryRef),legendGradientLabels(spec,config,encode.labels,entryRef)]:(entryLayout=legendSymbolLayout(spec,config),children=[legendSymbolGroups(spec,config,encode,entryRef,deref(entryLayout.columns))],
params.size=sizeExpression(spec,scope,children[0].marks));children=[guideGroup({role:"legend-entry",from:dataRef,encode:{enter:{x:{value:0},y:{value:0}}},marks:children,layout:entryLayout,interactive})];datum.title&&children.push(legendTitle(spec,config,encode.title,dataRef));return parseMark(guideGroup({role:"legend",from:dataRef,encode:extendEncode(buildLegendEncode(_,spec,config),legendEncode,Skip),marks:children,aria:_("aria"),description:_("description"),zindex:_("zindex"),name,interactive,style}),
scope)}function legendType(spec,scaleType){let type=spec.type||"symbol";spec.type||1!==scaleCount(spec)||!spec.fill&&!spec.stroke||(type=vegaScale.isContinuous(scaleType)?"gradient":vegaScale.isDiscretizing(scaleType)?"discrete":"symbol");return"gradient"!==type?type:vegaScale.isDiscretizing(scaleType)?"discrete":"gradient"}function scaleCount(spec){return LegendScales.reduce((count,type)=>count+(spec[type]?1:0),0)}function buildLegendEncode(_,spec,config){const encode={enter:{},update:{}};addEncoders(encode,
{orient:_("orient"),offset:_("offset"),padding:_("padding"),titlePadding:_("titlePadding"),cornerRadius:_("cornerRadius"),fill:_("fillColor"),stroke:_("strokeColor"),strokeWidth:config.strokeWidth,strokeDash:config.strokeDash,x:_("legendX"),y:_("legendY"),format:spec.format,formatType:spec.formatType});return encode}function sizeExpression(spec,scope,marks){const size=deref(getChannel("size",spec,marks));spec=deref(getChannel("strokeWidth",spec,marks));(marks=getEncoding("fontSize",marks[1].encode))||
(marks=(marks=scope.config.style["guide-label"])&&marks.fontSize);marks=deref(marks);return vegaFunctions.parseExpression(`max(ceil(sqrt(${size})+${spec}),${marks})`,scope)}function getChannel(name,spec,marks){return spec[name]?`scale("${spec[name]}",datum)`:getEncoding(name,marks[0].encode)}function parseTitle(spec,scope){spec=vegaUtil.isString(spec)?{text:spec}:spec;const _=lookup$jscomp$0(spec,scope.config.title),encode=spec.encode||{};var userEncode=encode.group||{};const name=userEncode.name||
void 0,interactive=userEncode.interactive,style=userEncode.style,children=[],dataRef=ref$jscomp$0(scope.add(Collect(null,[{}])));children.push(buildTitle(spec,_,titleEncode(spec),dataRef));spec.subtitle&&children.push(buildSubTitle(spec,_,encode.subtitle,dataRef));spec={enter:{},update:{}};addEncoders(spec,{orient:_("orient"),anchor:_("anchor"),align:{signal:alignExpr},angle:{signal:'item.orient\x3d\x3d\x3d"left"?-90:item.orient\x3d\x3d\x3d"right"?90:0'},limit:_("limit"),frame:_("frame"),offset:_("offset")||
0,padding:_("subtitlePadding")});userEncode=extendEncode(spec,userEncode,Skip);return parseMark(guideGroup({role:"title",from:dataRef,encode:userEncode,marks:children,aria:_("aria"),description:_("description"),zindex:_("zindex"),name,interactive,style}),scope)}function titleEncode(spec){const encode=spec.encode;return encode&&encode.title||vegaUtil.extend({name:spec.name,interactive:spec.interactive,style:spec.style},encode)}function buildTitle(spec,_,userEncode,dataRef){var zero={value:0};zero=
{enter:{opacity:zero},update:{opacity:{value:1}},exit:{opacity:zero}};addEncoders(zero,{text:spec.text,align:{signal:"item.mark.group.align"},angle:{signal:"item.mark.group.angle"},limit:{signal:"item.mark.group.limit"},baseline:"top",dx:_("dx"),dy:_("dy"),fill:_("color"),font:_("font"),fontSize:_("fontSize"),fontStyle:_("fontStyle"),fontWeight:_("fontWeight"),lineHeight:_("lineHeight")},{align:_("align"),angle:_("angle"),baseline:_("baseline")});return guideMark({type:"text",role:"title-text",style:"group-title",
from:dataRef,encode:zero},userEncode)}function buildSubTitle(spec,_,userEncode,dataRef){var zero={value:0};zero={enter:{opacity:zero},update:{opacity:{value:1}},exit:{opacity:zero}};addEncoders(zero,{text:spec.subtitle,align:{signal:"item.mark.group.align"},angle:{signal:"item.mark.group.angle"},limit:{signal:"item.mark.group.limit"},baseline:"top",dx:_("dx"),dy:_("dy"),fill:_("subtitleColor"),font:_("subtitleFont"),fontSize:_("subtitleFontSize"),fontStyle:_("subtitleFontStyle"),fontWeight:_("subtitleFontWeight"),
lineHeight:_("subtitleLineHeight")},{align:_("align"),angle:_("angle"),baseline:_("baseline")});return guideMark({type:"text",role:"title-subtitle",style:"group-subtitle",from:dataRef,encode:zero},userEncode)}function parseData$1(data,scope){const transforms=[];data.transform&&data.transform.forEach(tx=>{transforms.push(parseTransform(tx,scope))});data.on&&data.on.forEach(on=>{parseTrigger(on,scope,data.name)});scope.addDataPipeline(data.name,analyze(data,scope,transforms))}function analyze(data,
scope,ops){const output=[];let source=null,modify=!1,generate=!1,upstream,n,t,m;data.values?isSignal(data.values)||hasSignal(data.format)?(output.push(load(scope,data)),output.push(source=collect())):output.push(source=collect({$ingest:data.values,$format:data.format})):data.url?hasSignal(data.url)||hasSignal(data.format)?(output.push(load(scope,data)),output.push(source=collect())):output.push(source=collect({$request:data.url,$format:data.format})):data.source&&(source=upstream=vegaUtil.array(data.source).map(d=>
ref$jscomp$0(scope.getData(d).output)),output.push(null));data=0;for(n=ops.length;data<n;++data)t=ops[data],m=t.metadata,source||m.source||output.push(source=collect()),output.push(t),m.generates&&(generate=!0),m.modifies&&!generate&&(modify=!0),m.source?source=t:m.changes&&(source=null);upstream&&(n=upstream.length-1,output[0]=Relay({derive:modify,pulse:n?upstream:upstream[0]}),(modify||n)&&output.splice(1,0,collect()));source||output.push(collect());output.push(Sieve({}));return output}function collect(values){values=
Collect({},values);values.metadata={source:!0};return values}function load(scope,data){return Load({url:data.url?scope.property(data.url):void 0,async:data.async?scope.property(data.async):void 0,values:data.values?scope.property(data.values):void 0,format:scope.objectProperty(data.format)})}function fallback(prop,config,axisConfig,style){let styleProp;if(config&&vegaUtil.hasOwnProperty(config,prop))return config[prop];if(vegaUtil.hasOwnProperty(axisConfig,prop))return axisConfig[prop];if(prop.startsWith("title")){switch(prop){case "titleColor":styleProp=
"fill";break;case "titleFont":case "titleFontSize":case "titleFontWeight":styleProp=prop[5].toLowerCase()+prop.slice(6)}return style["guide-title"][styleProp]}if(prop.startsWith("label")){switch(prop){case "labelColor":styleProp="fill";break;case "labelFont":case "labelFontSize":styleProp=prop[5].toLowerCase()+prop.slice(6)}return style["guide-label"][styleProp]}return null}function keys(objects){const map={};for(const obj of objects)if(obj)for(const key in obj)map[key]=1;return Object.keys(map)}
function axisDomain(spec,config,userEncode,dataRef){var _=lookup$jscomp$0(spec,config);config=spec.orient;let enter,update;const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:{opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_("domainColor"),strokeCap:_("domainCap"),strokeDash:_("domainDash"),strokeDashOffset:_("domainDashOffset"),strokeWidth:_("domainWidth"),strokeOpacity:_("domainOpacity")});_={scale:spec.scale,range:0};spec={scale:spec.scale,range:1};enter.x=update.x=
ifX(config,_,zero$jscomp$0);enter.x2=update.x2=ifX(config,spec);enter.y=update.y=ifY(config,_,zero$jscomp$0);enter.y2=update.y2=ifY(config,spec);return guideMark({type:"rule",role:"axis-domain",from:dataRef,encode},userEncode)}function axisGrid(spec,config,userEncode,dataRef,band){var _=lookup$jscomp$0(spec,config);config=spec.orient;var vscale=spec.gridScale;const sign=getSign(config,1,-1);a:{var JSCompiler_inline_result=spec.offset;if(1!==sign)if(vegaUtil.isObject(JSCompiler_inline_result)){for(var entry=
JSCompiler_inline_result=vegaUtil.extend({},JSCompiler_inline_result);null!=entry.mult;)if(vegaUtil.isObject(entry.mult))entry=entry.mult=vegaUtil.extend({},entry.mult);else{entry.mult=isSignal(sign)?{signal:`(${entry.mult}) * (${sign.signal})`}:entry.mult*sign;break a}entry.mult=sign}else JSCompiler_inline_result=isSignal(sign)?{signal:`(${sign.signal}) * (${JSCompiler_inline_result||0})`}:sign*(JSCompiler_inline_result||0)}const offset=JSCompiler_inline_result;let update;const encode={enter:JSCompiler_inline_result=
{opacity:zero$jscomp$0},update:update={opacity:one},exit:entry={opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_("gridColor"),strokeCap:_("gridCap"),strokeDash:_("gridDash"),strokeDashOffset:_("gridDashOffset"),strokeOpacity:_("gridOpacity"),strokeWidth:_("gridWidth")});spec={scale:spec.scale,field:"value",band:band.band,extra:band.extra,offset:band.offset,round:_("tickRound")};_=ifX(config,{signal:"height"},{signal:"width"});band=vscale?{scale:vscale,range:0,mult:sign,offset}:{value:0,offset};
vscale=vscale?{scale:vscale,range:1,mult:sign,offset}:vegaUtil.extend(_,{mult:sign,offset});JSCompiler_inline_result.x=update.x=ifX(config,spec,band);JSCompiler_inline_result.y=update.y=ifY(config,spec,band);JSCompiler_inline_result.x2=update.x2=ifY(config,vscale);JSCompiler_inline_result.y2=update.y2=ifX(config,vscale);entry.x=ifX(config,spec);entry.y=ifY(config,spec);return guideMark({type:"rule",role:"axis-grid",key:"value",from:dataRef,encode},userEncode)}function axisTicks(spec,config,userEncode,
dataRef,size,band){const _=lookup$jscomp$0(spec,config);config=spec.orient;const sign=getSign(config,-1,1);let enter,exit,update;const encode={enter:enter={opacity:zero$jscomp$0},update:update={opacity:one},exit:exit={opacity:zero$jscomp$0}};addEncoders(encode,{stroke:_("tickColor"),strokeCap:_("tickCap"),strokeDash:_("tickDash"),strokeDashOffset:_("tickDashOffset"),strokeOpacity:_("tickOpacity"),strokeWidth:_("tickWidth")});size=encoder(size);size.mult=sign;spec={scale:spec.scale,field:"value",band:band.band,
extra:band.extra,offset:band.offset,round:_("tickRound")};update.y=enter.y=ifX(config,zero$jscomp$0,spec);update.y2=enter.y2=ifX(config,size);exit.x=ifX(config,spec);update.x=enter.x=ifY(config,zero$jscomp$0,spec);update.x2=enter.x2=ifY(config,size);exit.y=ifY(config,spec);return guideMark({type:"rule",role:"axis-tick",key:"value",from:dataRef,encode},userEncode)}function flushExpr(scale,threshold,a,b,c){return{signal:'flush(range("'+scale+'"), scale("'+scale+'", datum.value), '+threshold+","+a+","+
b+","+c+")"}}function axisLabels(spec,config,userEncode,dataRef,size,band){config=lookup$jscomp$0(spec,config);const orient=spec.orient;spec=spec.scale;var sign=getSign(orient,-1,1),flush=deref(config("labelFlush")),flushOffset=deref(config("labelFlushOffset")),labelAlign=config("labelAlign"),labelBaseline=config("labelBaseline");let flushOn=0===flush||!!flush;var tickSize=encoder(size);tickSize.mult=sign;tickSize.offset=encoder(config("labelPadding")||0);tickSize.offset.mult=sign;sign={scale:spec,
field:"value",band:.5,offset:extendOffset(band.offset,config("labelOffset"))};band=flushOn?flushExpr(spec,flush,'"left"','"right"','"center"'):{value:"center"};size=isSignal(orient)?ifExpr(`${orient.signal} === '${"right"}'`,"left","right"):"right"===orient?{value:"left"}:{value:"right"};band=ifX(orient,band,size);size=ifX(orient,ifTop(orient,"bottom","top"),flushOn?flushExpr(spec,flush,'"top"','"bottom"','"middle"'):{value:"middle"});flush=flushExpr(spec,flush,`-(${flushOffset})`,flushOffset,0);
flushOn=flushOn&&flushOffset;tickSize={opacity:zero$jscomp$0,x:ifX(orient,sign,tickSize),y:ifY(orient,sign,tickSize)};tickSize={enter:tickSize,update:flushOffset={opacity:one,text:{field:"label"},x:tickSize.x,y:tickSize.y,align:band,baseline:size},exit:{opacity:zero$jscomp$0,x:tickSize.x,y:tickSize.y}};addEncoders(tickSize,{dx:!labelAlign&&flushOn?ifX(orient,flush):null,dy:!labelBaseline&&flushOn?ifY(orient,flush):null});addEncoders(tickSize,{angle:config("labelAngle"),fill:config("labelColor"),fillOpacity:config("labelOpacity"),
font:config("labelFont"),fontSize:config("labelFontSize"),fontWeight:config("labelFontWeight"),fontStyle:config("labelFontStyle"),limit:config("labelLimit"),lineHeight:config("labelLineHeight")},{align:labelAlign,baseline:labelBaseline});labelAlign=config("labelBound");labelBaseline=(labelBaseline=config("labelOverlap"))||labelAlign?{separation:config("labelSeparation"),method:labelBaseline,order:"datum.index",bound:labelAlign?{scale:spec,orient,tolerance:labelAlign}:null}:void 0;flushOffset.align!==
band&&(flushOffset.align=patch(flushOffset.align,band));flushOffset.baseline!==size&&(flushOffset.baseline=patch(flushOffset.baseline,size));return guideMark({type:"text",role:"axis-label",style:"guide-label",key:"value",from:dataRef,encode:tickSize,overlap:labelBaseline},userEncode)}function axisTitle(spec,config,userEncode,dataRef){config=lookup$jscomp$0(spec,config);const orient=spec.orient,sign=getSign(orient,-1,1);let enter,update;const encode={enter:enter={opacity:zero$jscomp$0,anchor:encoder(config("titleAnchor",
null)),align:{signal:alignExpr}},update:update=vegaUtil.extend({},enter,{opacity:one,text:encoder(spec.title)}),exit:{opacity:zero$jscomp$0}};spec={signal:`lerp(range("${spec.scale}"), ${anchorExpr(0,1,.5)})`};update.x=ifX(orient,spec);update.y=ifY(orient,spec);spec=isSignal(sign)?{signal:`(${sign.signal}) * ${90}`}:{value:90*sign};enter.angle=ifX(orient,zero$jscomp$0,spec);enter.baseline=ifX(orient,ifTop(orient,"bottom","top"),{value:"bottom"});update.angle=enter.angle;update.baseline=enter.baseline;
addEncoders(encode,{fill:config("titleColor"),fillOpacity:config("titleOpacity"),font:config("titleFont"),fontSize:config("titleFontSize"),fontStyle:config("titleFontStyle"),fontWeight:config("titleFontWeight"),limit:config("titleLimit"),lineHeight:config("titleLineHeight")},{align:config("titleAlign"),angle:config("titleAngle"),baseline:config("titleBaseline")});autoLayout(config,orient,encode,userEncode);encode.update.align=patch(encode.update.align,enter.align);encode.update.angle=patch(encode.update.angle,
enter.angle);encode.update.baseline=patch(encode.update.baseline,enter.baseline);return guideMark({type:"text",role:"axis-title",style:"guide-title",from:dataRef,encode},userEncode)}function autoLayout(_,orient,encode,userEncode){const auto=(value,dim)=>null!=value?(encode.update[dim]=patch(encoder(value),encode.update[dim]),!1):has(dim,userEncode)?!1:!0,autoY=auto(_("titleX"),"x");_=auto(_("titleY"),"y");encode.enter.auto=_===autoY?encoder(_):ifX(orient,encoder(_),encoder(autoY))}function parseScope(spec,
scope,preprocessed){const signals=vegaUtil.array(spec.signals),scales=vegaUtil.array(spec.scales);preprocessed||signals.forEach(_=>parseSignal(_,scope));vegaUtil.array(spec.projections).forEach(_=>{{const config=scope.config.projection||{},params={};for(const name in _)"name"!==name&&(params[name]=parseParameter(_[name],name,scope));for(const name in config)null==params[name]&&(params[name]=parseParameter(config[name],name,scope));scope.addProjection(_.name,params)}});scales.forEach(_=>{{const type=
_.type||"linear";vegaScale.isValidScaleType(type)||vegaUtil.error("Unrecognized scale type: "+vegaUtil.stringValue(type));scope.addScale(_.name,{type,domain:void 0})}});vegaUtil.array(spec.data).forEach(_=>parseData$1(_,scope));scales.forEach(_=>{{const params=scope.getScale(_.name).params;let key;params.domain=parseScaleDomain(_.domain,_,scope);null!=_.range&&(params.range=parseScaleRange(_,scope,params));if(null!=_.interpolate){var interpolate=_.interpolate,params$jscomp$0=params;params$jscomp$0.interpolate=
parseLiteral(interpolate.type||interpolate);null!=interpolate.gamma&&(params$jscomp$0.interpolateGamma=parseLiteral(interpolate.gamma))}null!=_.nice&&(interpolate=_.nice,interpolate=vegaUtil.isObject(interpolate)?{interval:parseLiteral(interpolate.interval),step:parseLiteral(interpolate.step)}:parseLiteral(interpolate),params.nice=interpolate);null!=_.bins&&(interpolate=_.bins,interpolate=interpolate.signal||vegaUtil.isArray(interpolate)?parseArray(interpolate,scope):scope.objectProperty(interpolate),
params.bins=interpolate);for(key in _)vegaUtil.hasOwnProperty(params,key)||"name"===key||(params[key]=parseLiteral(_[key],scope))}});(preprocessed||signals).forEach(_=>parseSignalUpdates(_,scope));vegaUtil.array(spec.axes).forEach(_=>{var config=scope.config,style=config.style,axis=config.axis,band="band"===scope.scaleType(_.scale)&&config.axisBand,orient=_.orient;if(isSignal(orient)){var or=keys([config.axisX,config.axisY]);var orientKeys=keys([config.axisTop,config.axisBottom,config.axisLeft,config.axisRight]);
var JSCompiler_inline_result={};for(key of or)JSCompiler_inline_result[key]=ifX(orient,fallback(key,config.axisX,axis,style),fallback(key,config.axisY,axis,style));or={};for(key of orientKeys){orientKeys=or;var JSCompiler_temp_const=key;var JSCompiler_inline_result$jscomp$0=orient.signal;var t=fallback(key,config.axisTop,axis,style),b=fallback(key,config.axisBottom,axis,style),l=fallback(key,config.axisLeft,axis,style),r=fallback(key,config.axisRight,axis,style);JSCompiler_inline_result$jscomp$0=
{signal:(null!=l?`${JSCompiler_inline_result$jscomp$0} === '${"left"}' ? (${toExpr(l)}) : `:"")+(null!=b?`${JSCompiler_inline_result$jscomp$0} === '${"bottom"}' ? (${toExpr(b)}) : `:"")+(null!=r?`${JSCompiler_inline_result$jscomp$0} === '${"right"}' ? (${toExpr(r)}) : `:"")+(null!=t?`${JSCompiler_inline_result$jscomp$0} === '${"top"}' ? (${toExpr(t)}) : `:"")+"(null)"};orientKeys[JSCompiler_temp_const]=JSCompiler_inline_result$jscomp$0}}else JSCompiler_inline_result="top"===orient||"bottom"===orient?
config.axisX:config.axisY,or=config["axis"+orient[0].toUpperCase()+orient.slice(1)];JSCompiler_inline_result=JSCompiler_inline_result||or||band?vegaUtil.extend({},axis,JSCompiler_inline_result,or,band):axis;var key=_.encode||{};config=key.axis||{};style=config.name||void 0;axis=config.interactive;band=config.style;JSCompiler_inline_result$jscomp$0=orient=lookup$jscomp$0(_,JSCompiler_inline_result);or=JSCompiler_inline_result$jscomp$0("tickBand");orientKeys=JSCompiler_inline_result$jscomp$0("tickOffset");
or?or.signal?(JSCompiler_temp_const={signal:`(${or.signal}) === 'extent' ? 1 : 0.5`},JSCompiler_inline_result$jscomp$0={signal:`(${or.signal}) === 'extent'`},vegaUtil.isObject(orientKeys)||(orientKeys={signal:`(${or.signal}) === 'extent' ? 0 : ${orientKeys}`})):"extent"===or?(JSCompiler_temp_const=1,JSCompiler_inline_result$jscomp$0=!0,orientKeys=0):(JSCompiler_temp_const=.5,JSCompiler_inline_result$jscomp$0=!1):(JSCompiler_temp_const=JSCompiler_inline_result$jscomp$0("bandPosition"),JSCompiler_inline_result$jscomp$0=
JSCompiler_inline_result$jscomp$0("tickExtra"));JSCompiler_temp_const={extra:JSCompiler_inline_result$jscomp$0,band:JSCompiler_temp_const,offset:orientKeys};JSCompiler_inline_result$jscomp$0={scale:_.scale,ticks:!!orient("ticks"),labels:!!orient("labels"),grid:!!orient("grid"),domain:!!orient("domain"),title:null!=_.title};or=ref$jscomp$0(scope.add(Collect({},[JSCompiler_inline_result$jscomp$0])));t=ref$jscomp$0(scope.add(AxisTicks({scale:scope.scaleRef(_.scale),extra:scope.property(JSCompiler_temp_const.extra),
count:scope.objectProperty(_.tickCount),values:scope.objectProperty(_.values),minstep:scope.property(_.tickMinStep),formatType:scope.property(_.formatType),formatSpecifier:scope.property(_.format)})));orientKeys=[];JSCompiler_inline_result$jscomp$0.grid&&orientKeys.push(axisGrid(_,JSCompiler_inline_result,key.grid,t,JSCompiler_temp_const));if(JSCompiler_inline_result$jscomp$0.ticks){var size=orient("tickSize");orientKeys.push(axisTicks(_,JSCompiler_inline_result,key.ticks,t,size,JSCompiler_temp_const))}JSCompiler_inline_result$jscomp$0.labels&&
(size=JSCompiler_inline_result$jscomp$0.ticks?size:0,orientKeys.push(axisLabels(_,JSCompiler_inline_result,key.labels,t,size,JSCompiler_temp_const)));JSCompiler_inline_result$jscomp$0.domain&&orientKeys.push(axisDomain(_,JSCompiler_inline_result,key.domain,or));JSCompiler_inline_result$jscomp$0.title&&orientKeys.push(axisTitle(_,JSCompiler_inline_result,key.title,or));size=orient;JSCompiler_inline_result={enter:{},update:{}};addEncoders(JSCompiler_inline_result,{orient:size("orient"),offset:size("offset")||
0,position:value$jscomp$0(_.position,0),titlePadding:size("titlePadding"),minExtent:size("minExtent"),maxExtent:size("maxExtent"),range:{signal:`abs(span(range("${_.scale}")))`},translate:size("translate"),format:_.format,formatType:_.formatType});_=JSCompiler_inline_result;return _=parseMark(guideGroup({role:"axis",from:or,encode:extendEncode(_,config,Skip),marks:orientKeys,aria:orient("aria"),description:orient("description"),zindex:orient("zindex"),name:style,interactive:axis,style:band}),scope)});
vegaUtil.array(spec.marks).forEach(_=>parseMark(_,scope));vegaUtil.array(spec.legends).forEach(_=>parseLegend(_,scope));spec.title&&parseTitle(spec.title,scope);scope.parseLambdas();return scope}function parseView(spec,scope){var config=scope.config;const root=ref$jscomp$0(scope.root=scope.add(new Entry("operator",void 0,void 0,void 0))),signals=collectSignals(spec,config);signals.forEach(_=>parseSignal(_,scope));scope.description=spec.description||config.description;scope.eventConfig=config.events;
scope.legends=scope.objectProperty(config.legend&&config.legend.layout);scope.locale=config.locale;config=scope.add(Collect());const encode=scope.add(Encode(parseEncode(extendEncode({enter:{x:{value:0},y:{value:0}},update:{width:{signal:"width"},height:{signal:"height"}}},spec.encode),"group","frame",spec.style,scope,{pulse:ref$jscomp$0(config)}))),parent=scope.add(ViewLayout({layout:scope.objectProperty(spec.layout),legends:scope.legends,autosize:scope.signalRef("autosize"),mark:root,pulse:ref$jscomp$0(encode)}));
scope.operators.pop();scope.pushState(ref$jscomp$0(encode),ref$jscomp$0(parent),null);parseScope(spec,scope,signals);scope.operators.push(parent);spec=scope.add(Bound({mark:root,pulse:ref$jscomp$0(parent)}));spec=scope.add(Render({pulse:ref$jscomp$0(spec)}));spec=scope.add(Sieve({pulse:ref$jscomp$0(spec)}));scope.addData("root",new DataScope(scope,config,config,spec));return scope}function signalObject(name,value){return value&&value.signal?{name,update:value.signal}:{name,value}}function collectSignals(spec,
config){const _=name=>value$jscomp$0(spec[name],config[name]),signals=[signalObject("background",_("background")),signalObject("autosize",parseAutosize(_("autosize"))),signalObject("padding",parsePadding(_("padding"))),signalObject("width",_("width")||0),signalObject("height",_("height")||0)],pre=signals.reduce((p,s)=>(p[s.name]=s,p),{}),map={};vegaUtil.array(spec.signals).forEach(s=>{vegaUtil.hasOwnProperty(pre,s.name)?s=vegaUtil.extend(pre[s.name],s):signals.push(s);map[s.name]=s});vegaUtil.array(config.signals).forEach(s=>
{vegaUtil.hasOwnProperty(map,s.name)||vegaUtil.hasOwnProperty(pre,s.name)||signals.push(s)});return signals}function Scope$1(config,options){this.config=config||{};this.options=options||{};this.bindings=[];this.field={};this.signals={};this.lambdas={};this.scales={};this.events={};this.data={};this.streams=[];this.updates=[];this.operators=[];this.locale=this.eventConfig=null;this._subid=this._id=0;this._nextsub=[0];this._parent=[];this._encode=[];this._lookup=[];this._markpath=[]}function Subscope(scope){this.config=
scope.config;this.options=scope.options;this.legends=scope.legends;this.field=Object.create(scope.field);this.signals=Object.create(scope.signals);this.lambdas=Object.create(scope.lambdas);this.scales=Object.create(scope.scales);this.events=Object.create(scope.events);this.data=Object.create(scope.data);this.streams=[];this.updates=[];this.operators=[];this._id=0;this._subid=++scope._nextsub[0];this._nextsub=scope._nextsub;this._parent=scope._parent.slice();this._encode=scope._encode.slice();this._lookup=
scope._lookup.slice();this._markpath=scope._markpath}function propertyLambda(spec){return(vegaUtil.isArray(spec)?arrayLambda:objectLambda)(spec)}function arrayLambda(array){const n=array.length;let code="[";for(let i=0;i<n;++i){const value=array[i];code+=(0<i?",":"")+(vegaUtil.isObject(value)?value.signal||propertyLambda(value):vegaUtil.stringValue(value))}return code+"]"}function objectLambda(obj){let code="{",i=0,key,value;for(key in obj)value=obj[key],code+=(1<++i?",":"")+vegaUtil.stringValue(key)+
":"+(vegaUtil.isObject(value)?value.signal||propertyLambda(value):vegaUtil.stringValue(value));return code+"}"}function defaults(){return{description:"Vega visualization",padding:0,autosize:"pad",background:null,events:{defaults:{allow:["wheel"]}},group:null,mark:null,arc:{fill:"#4c78a8"},area:{fill:"#4c78a8"},image:null,line:{stroke:"#4c78a8",strokeWidth:2},path:{stroke:"#4c78a8"},rect:{fill:"#4c78a8"},rule:{stroke:"#000"},shape:{stroke:"#4c78a8"},symbol:{fill:"#4c78a8",size:64},text:{fill:"#000",
font:"sans-serif",fontSize:11},trail:{fill:"#4c78a8",size:2},style:{"guide-label":{fill:"#000",font:"sans-serif",fontSize:10},"guide-title":{fill:"#000",font:"sans-serif",fontSize:11,fontWeight:"bold"},"group-title":{fill:"#000",font:"sans-serif",fontSize:13,fontWeight:"bold"},"group-subtitle":{fill:"#000",font:"sans-serif",fontSize:12},point:{size:30,strokeWidth:2,shape:"circle"},circle:{size:30,strokeWidth:2},square:{size:30,strokeWidth:2,shape:"square"},cell:{fill:"transparent",stroke:"#ddd"}},
title:{orient:"top",anchor:"middle",offset:4,subtitlePadding:3},axis:{minExtent:0,maxExtent:200,bandPosition:.5,domain:!0,domainWidth:1,domainColor:"#888",grid:!1,gridWidth:1,gridColor:"#ddd",labels:!0,labelAngle:0,labelLimit:180,labelOffset:0,labelPadding:2,ticks:!0,tickColor:"#888",tickOffset:0,tickRound:!0,tickSize:5,tickWidth:1,titlePadding:4},axisBand:{tickOffset:-.5},projection:{type:"mercator"},legend:{orient:"right",padding:0,gridAlign:"each",columnPadding:10,rowPadding:2,symbolDirection:"vertical",
gradientDirection:"vertical",gradientLength:200,gradientThickness:16,gradientStrokeColor:"#ddd",gradientStrokeWidth:0,gradientLabelOffset:2,labelAlign:"left",labelBaseline:"middle",labelLimit:160,labelOffset:4,labelOverlap:!0,symbolLimit:30,symbolType:"circle",symbolSize:100,symbolOffset:0,symbolStrokeWidth:1.5,symbolBaseFillColor:"transparent",symbolBaseStrokeColor:"#888",titleLimit:180,titleOrient:"top",titlePadding:5,layout:{offset:18,direction:"horizontal",left:{direction:"vertical"},right:{direction:"vertical"}}},
range:{category:{scheme:"tableau10"},ordinal:{scheme:"blues"},heatmap:{scheme:"yellowgreenblue"},ramp:{scheme:"blues"},diverging:{scheme:"blueorange",extent:[1,0]},symbol:"circle square triangle-up cross diamond triangle-right triangle-down triangle-left".split(" ")}}}const encoder=_=>vegaUtil.isObject(_)&&!vegaUtil.isArray(_)?vegaUtil.extend({},_):{value:_},scaleRef=scale=>vegaUtil.isString(scale)?vegaUtil.stringValue(scale):scale.signal?`(${scale.signal})`:field$jscomp$0(scale),_color=(type,x,y,
z)=>`(${type}(${[x,y,z].map(entry$jscomp$0).join(",")})+'')`,OUTER_INVALID=["value","update","init","react","bind"],keyFieldRef=fieldRef("key"),OP_VALUE_EXPR={code:"_.$value",ast:{type:"Identifier",value:"value"}},transform$jscomp$0=name=>(params,value,parent)=>new Entry(name,value,params||void 0,parent),Aggregate=transform$jscomp$0("aggregate"),AxisTicks=transform$jscomp$0("axisticks"),Bound=transform$jscomp$0("bound"),Collect=transform$jscomp$0("collect"),Compare=transform$jscomp$0("compare"),DataJoin=
transform$jscomp$0("datajoin"),Encode=transform$jscomp$0("encode"),Expression=transform$jscomp$0("expression"),Facet=transform$jscomp$0("facet"),Field=transform$jscomp$0("field"),Key=transform$jscomp$0("key"),LegendEntries=transform$jscomp$0("legendentries"),Load=transform$jscomp$0("load"),Mark=transform$jscomp$0("mark"),MultiExtent=transform$jscomp$0("multiextent"),MultiValues=transform$jscomp$0("multivalues"),Overlap=transform$jscomp$0("overlap"),Params=transform$jscomp$0("params"),PreFacet=transform$jscomp$0("prefacet"),
Projection=transform$jscomp$0("projection"),Proxy=transform$jscomp$0("proxy"),Relay=transform$jscomp$0("relay"),Render=transform$jscomp$0("render"),Scale=transform$jscomp$0("scale"),Sieve=transform$jscomp$0("sieve"),SortItems=transform$jscomp$0("sortitems"),ViewLayout=transform$jscomp$0("viewlayout"),Values=transform$jscomp$0("values");let FIELD_REF_ID=0;const MULTIDOMAIN_SORT_OPS={min:"min",max:"max",count:"sum"},LegendScales="size shape fill stroke strokeWidth strokeDash opacity".split(" "),Skip=
{name:1,style:1,interactive:1},zero$jscomp$0={value:0},one={value:1},alignExpr=anchorExpr(vegaUtil.stringValue("left"),vegaUtil.stringValue("right"),vegaUtil.stringValue("center")),baseline=anchorExpr('"top"','"bottom"','"middle"'),exprAlign=`datum.vgrad && ${'item.orient \x3d\x3d\x3d "right"'} ? (${anchorExpr('"right"','"left"','"center"')}) : (${'(item.orient \x3d\x3d\x3d "left" || item.orient \x3d\x3d\x3d "right")'} && !(datum.vgrad && ${'item.orient \x3d\x3d\x3d "left"'})) ? "left" : ${alignExpr}`,
exprBaseline=`${'(item.orient \x3d\x3d\x3d "left" || item.orient \x3d\x3d\x3d "right")'} ? (datum.vgrad ? (${'item.orient \x3d\x3d\x3d "right"'} ? "bottom" : "top") : ${baseline}) : "top"`;DataScope.fromEntries=function(scope,entries){const n=entries.length,values=entries[n-1],output=entries[n-2];let input=entries[0],aggr=null,i=1;input&&"load"===input.type&&(input=entries[1]);for(scope.add(entries[0]);i<n;++i)entries[i].params.pulse=ref$jscomp$0(entries[i-1]),scope.add(entries[i]),"aggregate"===
entries[i].type&&(aggr=entries[i]);return new DataScope(scope,input,output,values,aggr)};DataScope.prototype={countsRef(scope,field,sort){const cache=this.counts||(this.counts={}),k=fieldKey(field);if(null!=k){scope=this.scope;var v=cache[k]}v?sort&&sort.field&&addSortField(scope,v.agg.params,sort):(v={groupby:scope.fieldRef(field,"key"),pulse:ref$jscomp$0(this.output)},sort&&sort.field&&addSortField(scope,v,sort),sort=scope.add(Aggregate(v)),v=scope.add(Collect({pulse:ref$jscomp$0(sort)})),v={agg:sort,
ref:ref$jscomp$0(v)},null!=k&&(cache[k]=v));return v.ref},tuplesRef(){return ref$jscomp$0(this.values)},extentRef(scope,field){return cache$jscomp$0(scope,this,"extent","extent",field,!1)},domainRef(scope,field){return cache$jscomp$0(scope,this,"domain","values",field,!1)},valuesRef(scope,field,sort){return cache$jscomp$0(scope,this,"vals","values",field,sort||!0)},lookupRef(scope,field){return cache$jscomp$0(scope,this,"lookup","tupleindex",field,!1)},indataRef(scope,field){return cache$jscomp$0(scope,
this,"indata","tupleindex",field,!0,!0)}};const getSign=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifExpr(`${orient} === '${"left"}' || ${orient} === '${"top"}'`,a,b)):a="left"===orient||"top"===orient?a:b;return a},ifX=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifEnc(`${orient} === '${"top"}' || ${orient} === '${"bottom"}'`,a,b)):a="bottom"===orient||"top"===orient?a:b;return a},ifY=(orient,a,b)=>{isSignal(orient)?(orient=orient.signal,a=ifEnc(`${orient} !== '${"top"}' && ${orient} !== '${"bottom"}'`,
a,b)):a="bottom"===orient||"top"===orient?b:a;return a},ifTop=(orient,a,b)=>isSignal(orient)?ifExpr(`${orient.signal} === '${"top"}'`,a,b):"top"===orient?{value:a}:{value:b},ifEnc=(test,a,b)=>{a=null!=a?encoder(a):a;b=null!=b?encoder(b):b;if(null!=a&&1!==Object.keys(a).length||null!=b&&1!==Object.keys(b).length)return[vegaUtil.extend({test},a)].concat(b||[]);a=a?a.signal||vegaUtil.stringValue(a.value):null;b=b?b.signal||vegaUtil.stringValue(b.value):null;return{signal:`${test} ? (${a}) : (${b})`}},
ifExpr=(test,a,b)=>({signal:`${test} ? (${toExpr(a)}) : (${toExpr(b)})`}),toExpr=v=>isSignal(v)?v.signal:null==v?null:vegaUtil.stringValue(v),patch=(value,base)=>{const s=value.signal;return s&&s.endsWith("(null)")?{signal:s.slice(0,-6)+base.signal}:value};Scope$1.prototype=Subscope.prototype={parse(spec){return parseScope(spec,this)},fork(){return new Subscope(this)},isSubscope(){return 0<this._subid},toRuntime(){this.finish();return{description:this.description,operators:this.operators,streams:this.streams,
updates:this.updates,bindings:this.bindings,eventConfig:this.eventConfig,locale:this.locale}},id(){return(this._subid?this._subid+":":0)+this._id++},add(op){this.operators.push(op);op.id=this.id();op.refs&&(op.refs.forEach(ref=>{ref.$ref=op.id}),op.refs=null);return op},proxy(op){op=op instanceof Entry?ref$jscomp$0(op):op;return this.add(Proxy({value:op}))},addStream(stream){this.streams.push(stream);stream.id=this.id();return stream},addUpdate(update){this.updates.push(update);return update},finish(){function annotate(op,
name,type){op&&(op=op.data||(op.data={}),name=op[name]||(op[name]=[]),name.push(type))}let name$jscomp$0,ds;this.root&&(this.root.root=!0);for(name$jscomp$0 in this.signals)this.signals[name$jscomp$0].signal=name$jscomp$0;for(name$jscomp$0 in this.scales)this.scales[name$jscomp$0].scale=name$jscomp$0;for(name$jscomp$0 in this.data){ds=this.data[name$jscomp$0];annotate(ds.input,name$jscomp$0,"input");annotate(ds.output,name$jscomp$0,"output");annotate(ds.values,name$jscomp$0,"values");for(const field in ds.index)annotate(ds.index[field],
name$jscomp$0,"index:"+field)}return this},pushState(encode,parent,lookup){this._encode.push(ref$jscomp$0(this.add(Sieve({pulse:encode}))));this._parent.push(parent);this._lookup.push(lookup?ref$jscomp$0(this.proxy(lookup)):null);this._markpath.push(-1)},popState(){this._encode.pop();this._parent.pop();this._lookup.pop();this._markpath.pop()},parent(){return vegaUtil.peek(this._parent)},encode(){return vegaUtil.peek(this._encode)},lookup(){return vegaUtil.peek(this._lookup)},markpath(){const p=this._markpath;
return++p[p.length-1]},fieldRef(field,name){if(vegaUtil.isString(field))return fieldRef(field,name);field.signal||vegaUtil.error("Unsupported field reference: "+vegaUtil.stringValue(field));field=field.signal;var f=this.field[field];f||(f={name:this.signalRef(field)},name&&(f.as=name),this.field[field]=f=ref$jscomp$0(this.add(Field(f))));return f},compareRef(cmp){let signal=!1;const check=_=>isSignal(_)?(signal=!0,this.signalRef(_.signal)):_&&_.expr?(signal=!0,this.exprRef(_.expr)):_,fields=vegaUtil.array(cmp.field).map(check);
cmp=vegaUtil.array(cmp.order).map(check);return signal?ref$jscomp$0(this.add(Compare({fields,orders:cmp}))):{$compare:fields,$order:cmp}},keyRef(fields,flat){let signal=!1;const sig=this.signals;fields=vegaUtil.array(fields).map(_=>isSignal(_)?(signal=!0,ref$jscomp$0(sig[_.signal])):_);return signal?ref$jscomp$0(this.add(Key({fields,flat}))):keyRef(fields,flat)},sortRef(sort){if(!sort)return sort;const a=aggrField(sort.op,sort.field);sort=sort.order||"ascending";return sort.signal?ref$jscomp$0(this.add(Compare({fields:a,
orders:this.signalRef(sort.signal)}))):{$compare:a,$order:sort}},event(source,type){const key=source+":"+type;if(!this.events[key]){const id=this.id();this.streams.push({id,source,type});this.events[key]=id}return this.events[key]},hasOwnSignal(name){return vegaUtil.hasOwnProperty(this.signals,name)},addSignal(name,value){this.hasOwnSignal(name)&&vegaUtil.error("Duplicate signal name: "+vegaUtil.stringValue(name));value=value instanceof Entry?value:this.add(new Entry("operator",value,void 0,void 0));
return this.signals[name]=value},getSignal(name){this.signals[name]||vegaUtil.error("Unrecognized signal name: "+vegaUtil.stringValue(name));return this.signals[name]},signalRef(s){if(this.signals[s])return ref$jscomp$0(this.signals[s]);vegaUtil.hasOwnProperty(this.lambdas,s)||(this.lambdas[s]=this.add(new Entry("operator",null,void 0,void 0)));return ref$jscomp$0(this.lambdas[s])},parseLambdas(){const code=Object.keys(this.lambdas);for(let i=0,n=code.length;i<n;++i){var s=code[i];const e=vegaFunctions.parseExpression(s,
this);s=this.lambdas[s];s.params=e.$params;s.update=e.$expr}},property(spec){return spec&&spec.signal?this.signalRef(spec.signal):spec},objectProperty(spec){return spec&&vegaUtil.isObject(spec)?this.signalRef(spec.signal||propertyLambda(spec)):spec},exprRef(code,name){code={expr:vegaFunctions.parseExpression(code,this)};name&&(code.expr.$name=name);return ref$jscomp$0(this.add(Expression(code)))},addBinding(name,bind){this.bindings||vegaUtil.error("Nested signals do not support binding: "+vegaUtil.stringValue(name));
this.bindings.push(vegaUtil.extend({signal:name},bind))},addScaleProj(name,transform){vegaUtil.hasOwnProperty(this.scales,name)&&vegaUtil.error("Duplicate scale or projection name: "+vegaUtil.stringValue(name));this.scales[name]=this.add(transform)},addScale(name,params){this.addScaleProj(name,Scale(params))},addProjection(name,params){this.addScaleProj(name,Projection(params))},getScale(name){this.scales[name]||vegaUtil.error("Unrecognized scale name: "+vegaUtil.stringValue(name));return this.scales[name]},
scaleRef(name){return ref$jscomp$0(this.getScale(name))},scaleType(name){return this.getScale(name).params.type},projectionRef(name){return this.scaleRef(name)},projectionType(name){return this.scaleType(name)},addData(name,dataScope){vegaUtil.hasOwnProperty(this.data,name)&&vegaUtil.error("Duplicate data set name: "+vegaUtil.stringValue(name));return this.data[name]=dataScope},getData(name){this.data[name]||vegaUtil.error("Undefined data set name: "+vegaUtil.stringValue(name));return this.data[name]},
addDataPipeline(name,entries){vegaUtil.hasOwnProperty(this.data,name)&&vegaUtil.error("Duplicate data set name: "+vegaUtil.stringValue(name));return this.addData(name,DataScope.fromEntries(this,entries))}};exports.AxisDomainRole="axis-domain";exports.AxisGridRole="axis-grid";exports.AxisLabelRole="axis-label";exports.AxisRole="axis";exports.AxisTickRole="axis-tick";exports.AxisTitleRole="axis-title";exports.DataScope=DataScope;exports.FrameRole="frame";exports.LegendEntryRole="legend-entry";exports.LegendLabelRole=
"legend-label";exports.LegendRole="legend";exports.LegendSymbolRole="legend-symbol";exports.LegendTitleRole="legend-title";exports.MarkRole="mark";exports.Scope=Scope$1;exports.ScopeRole="scope";exports.config=defaults;exports.parse=function(spec,config,options){vegaUtil.isObject(spec)||vegaUtil.error("Input Vega specification must be an object.");config=vegaUtil.mergeConfig(defaults(),config,spec.config);return parseView(spec,new Scope$1(config,options)).toRuntime()};exports.signal=parseSignal;exports.signalUpdates=
parseSignalUpdates;exports.stream=parseStream;Object.defineProperty(exports,"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$vega_parser$build$vega_parser.js.map
