shadow$provide.module$node_modules$eth_sig_util$index=function(global,require,module,exports){function typedSignatureHash(typedData){const error=Error("Expect argument to be non-empty array");if("object"!==typeof typedData||!typedData.length)throw error;const data=typedData.map(function(e){return"bytes"===e.type?ethUtil.toBuffer(e.value):e.value}),types=typedData.map(function(e){return e.type}),schema=typedData.map(function(e){if(!e.name)throw error;return e.type+" "+e.name});return ethAbi.soliditySHA3(["bytes32",
"bytes32"],[ethAbi.soliditySHA3(Array(typedData.length).fill("string"),schema),ethAbi.soliditySHA3(types,data)])}function recoverPublicKey(hash,sig){sig=ethUtil.toBuffer(sig);sig=ethUtil.fromRpcSig(sig);return ethUtil.ecrecover(hash,sig.v,sig.r,sig.s)}function getPublicKeyFor(msgParams){var message=ethUtil.toBuffer(msgParams.data);message=ethUtil.hashPersonalMessage(message);return recoverPublicKey(message,msgParams.sig)}function padWithZeroes(number,length){for(number=""+number;number.length<length;)number=
"0"+number;return number}const ethUtil=require("module$node_modules$ethereumjs_util$dist$index"),ethAbi=require("module$node_modules$ethereumjs_abi$index");module.exports={concatSig:function(v,r,s){r=ethUtil.fromSigned(r);s=ethUtil.fromSigned(s);v=ethUtil.bufferToInt(v);r=padWithZeroes(ethUtil.toUnsigned(r).toString("hex"),64);s=padWithZeroes(ethUtil.toUnsigned(s).toString("hex"),64);v=ethUtil.stripHexPrefix(ethUtil.intToHex(v));return ethUtil.addHexPrefix(r.concat(s,v)).toString("hex")},normalize:function(input){if(input){"number"===
typeof input&&(input=ethUtil.toBuffer(input),input=ethUtil.bufferToHex(input));if("string"!==typeof input)throw Error("eth-sig-util.normalize() requires hex string or integer input. received "+(typeof input+": "+input));return ethUtil.addHexPrefix(input.toLowerCase())}},personalSign:function(privateKey,msgParams){msgParams=ethUtil.toBuffer(msgParams.data);msgParams=ethUtil.hashPersonalMessage(msgParams);privateKey=ethUtil.ecsign(msgParams,privateKey);return ethUtil.bufferToHex(this.concatSig(privateKey.v,
privateKey.r,privateKey.s))},recoverPersonalSignature:function(msgParams){msgParams=getPublicKeyFor(msgParams);msgParams=ethUtil.publicToAddress(msgParams);return ethUtil.bufferToHex(msgParams)},extractPublicKey:function(msgParams){return"0x"+getPublicKeyFor(msgParams).toString("hex")},typedSignatureHash:function(typedData){typedData=typedSignatureHash(typedData);return ethUtil.bufferToHex(typedData)},signTypedData:function(privateKey,msgParams){msgParams=typedSignatureHash(msgParams.data);privateKey=
ethUtil.ecsign(msgParams,privateKey);return ethUtil.bufferToHex(this.concatSig(privateKey.v,privateKey.r,privateKey.s))},recoverTypedSignature:function(msgParams){const msgHash=typedSignatureHash(msgParams.data);msgParams=recoverPublicKey(msgHash,msgParams.sig);msgParams=ethUtil.publicToAddress(msgParams);return ethUtil.bufferToHex(msgParams)}}}
//# sourceMappingURL=module$node_modules$eth_sig_util$index.js.map
