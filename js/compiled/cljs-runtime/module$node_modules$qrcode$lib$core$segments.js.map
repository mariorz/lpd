{
"version":3,
"file":"module$node_modules$qrcode$lib$core$segments.js",
"lineCount":9,
"mappings":"AAAAA,cAAA,CAAe,4CAAf,CAAiE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA4BzGC,QAASA,YAAY,CAACC,KAAD,CAAQC,IAAR,CAAcC,GAAd,CAAmB,CAItC,IAHA,IAAIC,SAAW,EAAf,CACIC,MAEJ,CAAsC,IAAtC,IAAQA,MAAR,CAAiBJ,KAAA,CAAMK,IAAN,CAAWH,GAAX,CAAjB,EAAA,CACEC,QAAA,CAASG,IAAT,CAAc,CACZC,KAAMH,MAAA,CAAO,CAAP,CADM,CAEZI,MAAOJ,MAAPI,CAAcA,KAFF,CAGNP,IAHM,CAIZQ,OAAQL,MAAA,CAAO,CAAP,CAARK,CAAkBA,MAJN,CAAd,CAQF,OAAON,SAb+B,CAuBxCO,QAASA,sBAAsB,CAACC,OAAD,CAAU,CACvC,IAAIC,QAAUb,WAAA,CAAYc,KAAZ,CAAkBC,OAAlB,CAA2BC,IAA3B,CAAgCD,OAAhC,CAAyCH,OAAzC,CAAd,CACIK,aAAejB,WAAA,CAAYc,KAAZ,CAAkBI,YAAlB,CAAgCF,IAAhC,CAAqCE,YAArC,CAAmDN,OAAnD,CAInB,IAAIO,KAAA,CAAMC,kBAAN,EAAJ,CAAgC,CAC9B,IAAAC;AAAWrB,WAAA,CAAYc,KAAZ,CAAkBQ,IAAlB,CAAwBN,IAAxB,CAA6BM,IAA7B,CAAmCV,OAAnC,CACXW,QAAA,CAAYvB,WAAA,CAAYc,KAAZ,CAAkBU,KAAlB,CAAyBR,IAAzB,CAA8BQ,KAA9B,CAAqCZ,OAArC,CAFkB,CAAhC,IAIES,SACA,CADWrB,WAAA,CAAYc,KAAZ,CAAkBW,UAAlB,CAA8BT,IAA9B,CAAmCM,IAAnC,CAAyCV,OAAzC,CACX,CAAAW,OAAA,CAAY,EAKd,OAFWV,QAAAa,CAAQC,MAARD,CAAeT,YAAfS,CAA6BL,QAA7BK,CAAuCH,OAAvCG,CAEJ,CACJE,IADI,CACC,QAAS,CAACC,EAAD,CAAKC,EAAL,CAAS,CACtB,MAAOD,GAAP,CAAUpB,KAAV,CAAkBqB,EAAlB,CAAqBrB,KADC,CADnB,CAAA,CAIJsB,GAJI,CAIA,QAAS,CAACC,GAAD,CAAM,CAClB,MAAO,CACLxB,KAAMwB,GAANxB,CAAUA,IADL,CAELN,KAAM8B,GAAN9B,CAAUA,IAFL,CAGLQ,OAAQsB,GAARtB,CAAYA,MAHP,CADW,CAJf,CAhBgC,CAqCzCuB,QAASA,qBAAqB,CAACvB,MAAD,CAASR,IAAT,CAAe,CAC3C,OAAQA,IAAR,EACE,KAAKc,IAAL,CAAUD,OAAV,CACE,MAAOmB,YAAA,CAAYC,aAAZ,CAA0BzB,MAA1B,CACT,MAAKM,IAAL,CAAUE,YAAV,CACE,MAAOkB,iBAAA,CAAiBD,aAAjB,CAA+BzB,MAA/B,CACT;KAAKM,IAAL,CAAUQ,KAAV,CACE,MAAOa,UAAA,CAAUF,aAAV,CAAwBzB,MAAxB,CACT,MAAKM,IAAL,CAAUM,IAAV,CACE,MAAOgB,SAAA,CAASH,aAAT,CAAuBzB,MAAvB,CARX,CAD2C,CAmB7C6B,QAASA,cAAc,CAACb,IAAD,CAAO,CAC5B,MAAOA,KAAA,CAAKc,MAAL,CAAY,QAAS,CAACC,GAAD,CAAMC,IAAN,CAAY,CACtC,IAAIC,QAA4B,CAAlB,EAAAF,GAAA,CAAI/B,MAAJ,CAAa,CAAb,CAAsB+B,GAAA,CAAIA,GAAJ,CAAQ/B,MAAR,CAAiB,CAAjB,CAAtB,CAA4C,IAC1D,IAAIiC,OAAJ,EAAeA,OAAf,CAAuBzC,IAAvB,GAAgCwC,IAAhC,CAAqCxC,IAArC,CAEE,MADAuC,IAAA,CAAIA,GAAJ,CAAQ/B,MAAR,CAAiB,CAAjB,CACO+B,CADajC,IACbiC,EADqBC,IACrBD,CAD0BjC,IAC1BiC,CAAAA,GAGTA,IAAA,CAAIlC,IAAJ,CAASmC,IAAT,CACA,OAAOD,IAR+B,CAAjC,CASJ,EATI,CADqB,CA8H9BG,QAASA,mBAAmB,CAACpC,IAAD,CAAOqC,SAAP,CAAkB,CAE5C,IAAIC,SAAW9B,IAAA,CAAK+B,kBAAL,CAAwBvC,IAAxB,CAEfN,UAAA,CAAOc,IAAA,CAAKgC,IAAL,CAAUH,SAAV,CAAqBC,QAArB,CAGP,IAAI5C,SAAJ,GAAac,IAAb,CAAkBM,IAAlB,EAA0BpB,SAA1B,CAA+B+C,GAA/B;AAAqCH,QAArC,CAA8CG,GAA9C,CACE,KAAUC,MAAJ,CAAU,GAAV,CAAgB1C,IAAhB,CAAuB,gCAAvB,CAC8BQ,IAAA,CAAKmC,QAAL,CAAcjD,SAAd,CAD9B,CAEJ,yBAFI,CAEwBc,IAAA,CAAKmC,QAAL,CAAcL,QAAd,CAFxB,CAAN,CAME5C,SAAJ,GAAac,IAAb,CAAkBQ,KAAlB,EAA4BL,KAAA,CAAMC,kBAAN,EAA5B,GACElB,SADF,CACSc,IADT,CACcM,IADd,CAIA,QAAQpB,SAAR,EACE,KAAKc,IAAL,CAAUD,OAAV,CACE,MAAO,KAAImB,WAAJ,CAAgB1B,IAAhB,CAET,MAAKQ,IAAL,CAAUE,YAAV,CACE,MAAO,KAAIkB,gBAAJ,CAAqB5B,IAArB,CAET,MAAKQ,IAAL,CAAUQ,KAAV,CACE,MAAO,KAAIa,SAAJ,CAAc7B,IAAd,CAET,MAAKQ,IAAL,CAAUM,IAAV,CACE,MAAO,KAAIgB,QAAJ,CAAa9B,IAAb,CAXX,CAlB4C,CAxO9C,IAAIQ,KAAOnB,OAAA,CAAQ,0CAAR,CAAX,CACIqC,YAAcrC,OAAA,CAAQ,kDAAR,CADlB;AAEIuC,iBAAmBvC,OAAA,CAAQ,uDAAR,CAFvB,CAGIyC,SAAWzC,OAAA,CAAQ,+CAAR,CAHf,CAIIwC,UAAYxC,OAAA,CAAQ,gDAAR,CAJhB,CAKIiB,MAAQjB,OAAA,CAAQ,2CAAR,CALZ,CAMIsB,MAAQtB,OAAA,CAAQ,2CAAR,CANZ,CAOIuD,SAAWvD,OAAA,CAAQ,yCAAR,CAiRfE,QAAA,CAAQsD,SAAR,CAAoBC,QAAmB,CAACC,KAAD,CAAQ,CAC7C,MAAOA,MAAA,CAAMf,MAAN,CAAa,QAAS,CAACC,GAAD,CAAMe,GAAN,CAAW,CACnB,QAAnB,GAAI,MAAOA,IAAX,CACEf,GAAA,CAAIlC,IAAJ,CAASqC,kBAAA,CAAmBY,GAAnB;AAAwB,IAAxB,CAAT,CADF,CAEWA,GAFX,CAEehD,IAFf,EAGEiC,GAAA,CAAIlC,IAAJ,CAASqC,kBAAA,CAAmBY,GAAnB,CAAuBhD,IAAvB,CAA6BgD,GAA7B,CAAiCtD,IAAjC,CAAT,CAGF,OAAOuC,IAP+B,CAAjC,CAQJ,EARI,CADsC,CAoB/C1C,QAAA,CAAQ0D,UAAR,CAAqBC,QAAoB,CAAClD,IAAD,CAAOmD,OAAP,CAAgB,CAGhCjC,IAAAA,KAFZf,qBAAAe,CAAsBlB,IAAtBkB,CAA4BP,KAAA,CAAMC,kBAAN,EAA5BM,CArKPkC,KAAAA,CAAQ,EACZ,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBnC,IAApB,CAAyBhB,MAAzB,CAAiCmD,CAAA,EAAjC,CAAsC,CACpC,IAAIL,IAAM9B,IAAA,CAAKmC,CAAL,CAEV,QAAQL,GAAR,CAAYtD,IAAZ,EACE,KAAKc,IAAL,CAAUD,OAAV,CACE6C,IAAA,CAAMrD,IAAN,CAAW,CAACiD,GAAD,CACT,CAAEhD,KAAMgD,GAANhD,CAAUA,IAAZ,CAAkBN,KAAMc,IAANd,CAAWgB,YAA7B,CAA2CR,OAAQ8C,GAAR9C,CAAYA,MAAvD,CADS,CAET,CAAEF,KAAMgD,GAANhD,CAAUA,IAAZ,CAAkBN,KAAMc,IAANd,CAAWoB,IAA7B,CAAmCZ,OAAQ8C,GAAR9C,CAAYA,MAA/C,CAFS,CAAX,CAIA,MACF,MAAKM,IAAL,CAAUE,YAAV,CACE0C,IAAA,CAAMrD,IAAN,CAAW,CAACiD,GAAD,CACT,CAAEhD,KAAMgD,GAANhD,CAAUA,IAAZ,CAAkBN,KAAMc,IAANd,CAAWoB,IAA7B,CAAmCZ,OAAQ8C,GAAR9C,CAAYA,MAA/C,CADS,CAAX,CAGA,MACF;KAAKM,IAAL,CAAUQ,KAAV,CACEoC,IAAA,CAAMrD,IAAN,CAAW,CAACiD,GAAD,CACT,CAAEhD,KAAMgD,GAANhD,CAAUA,IAAZ,CAAkBN,KAAMc,IAANd,CAAWoB,IAA7B,CAAmCZ,OA1IpCoD,QAAA,CAASC,kBAAA,CA0IuDP,GA1IvD,CA0I2DhD,IA1I3D,CAAT,CA0IoCE,CA1IFA,MA0IjC,CADS,CAAX,CAGA,MACF,MAAKM,IAAL,CAAUM,IAAV,CACEsC,IAAA,CAAMrD,IAAN,CAAW,CACT,CAAEC,KAAMgD,GAANhD,CAAUA,IAAZ,CAAkBN,KAAMc,IAANd,CAAWoB,IAA7B,CAAmCZ,OA/IpCoD,QAAA,CAASC,kBAAA,CA+IuDP,GA/IvD,CA+I2DhD,IA/I3D,CAAT,CA+IoCE,CA/IFA,MA+IjC,CADS,CAAX,CAlBJ,CAHoC,CA2ClCsD,IAAAA,CAAQ,EACRC,EAAAA,CAAQ,CAAC,MAAS,EAAV,CACRC,IAAAA,CAAc,CAAC,OAAD,CAElB,KAAK,IAAIL,WAAI,CAAb,CAAgBA,UAAhB,CApBOD,IAoBP,CAA0BlD,MAA1B,CAAkCmD,UAAA,EAAlC,CAAuC,CAIrC,IAHA,IAAIM,UArBCP,IAqBW,CAAMC,UAAN,CAAhB,CACIO,eAAiB,EADrB,CAGSC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,SAApB,CAA8BzD,MAA9B,CAAsC2D,CAAA,EAAtC,CAA2C,CACzC,IAAIC,KAAOH,SAAA,CAAUE,CAAV,CAAX,CACIE,IAAM,EAANA,CAAWV,UAAXU,CAAeF,CAEnBD,eAAA,CAAe7D,IAAf,CAAoBgE,GAApB,CACAP,KAAA,CAAMO,GAAN,CAAA,CAAa,CAAQD,IAAR,CAAcE,UAAW,CAAzB,CACbP;CAAA,CAAMM,GAAN,CAAA,CAAa,EAEb,KAAK,IAAIE,EAAI,CAAb,CAAgBA,CAAhB,CAAoBP,GAApB,CAAgCxD,MAAhC,CAAwC+D,CAAA,EAAxC,CAA6C,CAC3C,IAAIC,WAAaR,GAAA,CAAYO,CAAZ,CAEbT,KAAA,CAAMU,UAAN,CAAJ,EAAyBV,IAAA,CAAMU,UAAN,CAAzB,CAA2CJ,IAA3C,CAAgDpE,IAAhD,GAAyDoE,IAAzD,CAA8DpE,IAA9D,EACE+D,CAAA,CAAMS,UAAN,CAAA,CAAkBH,GAAlB,CAIA,CAHEtC,oBAAA,CAAqB+B,IAAA,CAAMU,UAAN,CAArB,CAAuCF,SAAvC,CAAmDF,IAAnD,CAAwD5D,MAAxD,CAAgE4D,IAAhE,CAAqEpE,IAArE,CAGF,CAFE+B,oBAAA,CAAqB+B,IAAA,CAAMU,UAAN,CAArB,CAAuCF,SAAvC,CAAkDF,IAAlD,CAAuDpE,IAAvD,CAEF,CAAA8D,IAAA,CAAMU,UAAN,CAAA,CAAkBF,SAAlB,EAA+BF,IAA/B,CAAoC5D,MALtC,GAOMsD,IAAA,CAAMU,UAAN,CAEJ,GAFuBV,IAAA,CAAMU,UAAN,CAEvB,CAFyCF,SAEzC,CAFqDF,IAErD,CAF0D5D,MAE1D,EAAAuD,CAAA,CAAMS,UAAN,CAAA,CAAkBH,GAAlB,CAAA,CAAyBtC,oBAAA,CAAqBqC,IAArB,CAA0B5D,MAA1B,CAAkC4D,IAAlC,CAAuCpE,IAAvC,CAAzB,CACE,CADF,CACMc,IAAA,CAAK2D,qBAAL,CAA2BL,IAA3B,CAAgCpE,IAAhC,CA+FgByD,OA/FhB,CAVR,CAH2C,CARJ,CA0B3CO,GAAA,CAAcE,cA9BuB,CAiCvC,IAAKK,CAAL;AAAS,CAAT,CAAYA,CAAZ,CAAgBP,GAAhB,CAA4BxD,MAA5B,CAAoC+D,CAAA,EAApC,CACER,CAAA,CAAMC,GAAA,CAAYO,CAAZ,CAAN,CAAA,CAAsB,GAAtB,CAA+B,CAuF7BG,QAAAA,CAAOxB,QAAA,CAASyB,SAAT,CApFGZ,CAoFH,CAA8B,OAA9B,CAAuC,KAAvC,CAEPa,KAAAA,CAAgB,EACpB,KAASjB,CAAT,CAAa,CAAb,CAAgBA,CAAhB,CAAoBe,OAApB,CAAyBlE,MAAzB,CAAkC,CAAlC,CAAqCmD,CAAA,EAArC,CACEiB,IAAA,CAAcvE,IAAd,CAxF0ByD,IAwFP,CAAYY,OAAA,CAAKf,CAAL,CAAZ,CAAnB,CAAwCS,IAAxC,CAGF,OAAOvE,QAAA,CAAQsD,SAAR,CAAkBd,aAAA,CAAcuC,IAAd,CAAlB,CAZgD,CAyBzD/E,QAAA,CAAQgF,QAAR,CAAmBC,QAAkB,CAACxE,IAAD,CAAO,CAC1C,MAAOT,QAAA,CAAQsD,SAAR,CACL1C,qBAAA,CAAsBH,IAAtB,CAA4BW,KAAA,CAAMC,kBAAN,EAA5B,CADK,CADmC,CAtU6D;",
"sources":["node_modules/qrcode/lib/core/segments.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$segments\"] = function(global,require,module,exports) {\nvar Mode = require('./mode')\nvar NumericData = require('./numeric-data')\nvar AlphanumericData = require('./alphanumeric-data')\nvar ByteData = require('./byte-data')\nvar KanjiData = require('./kanji-data')\nvar Regex = require('./regex')\nvar Utils = require('./utils')\nvar dijkstra = require('dijkstrajs')\n\n/**\n * Returns UTF8 byte length\n *\n * @param  {String} str Input string\n * @return {Number}     Number of byte\n */\nfunction getStringByteLength (str) {\n  return unescape(encodeURIComponent(str)).length\n}\n\n/**\n * Get a list of segments of the specified mode\n * from a string\n *\n * @param  {Mode}   mode Segment mode\n * @param  {String} str  String to process\n * @return {Array}       Array of object with segments data\n */\nfunction getSegments (regex, mode, str) {\n  var segments = []\n  var result\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    })\n  }\n\n  return segments\n}\n\n/**\n * Extracts a series of segments with the appropriate\n * modes from a string\n *\n * @param  {String} dataStr Input string\n * @return {Array}          Array of object with segments data\n */\nfunction getSegmentsFromString (dataStr) {\n  var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\n  var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\n  var byteSegs\n  var kanjiSegs\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\n    kanjiSegs = []\n  }\n\n  var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\n\n  return segs\n    .sort(function (s1, s2) {\n      return s1.index - s2.index\n    })\n    .map(function (obj) {\n      return {\n        data: obj.data,\n        mode: obj.mode,\n        length: obj.length\n      }\n    })\n}\n\n/**\n * Returns how many bits are needed to encode a string of\n * specified length with the specified mode\n *\n * @param  {Number} length String length\n * @param  {Mode} mode     Segment mode\n * @return {Number}        Bit length\n */\nfunction getSegmentBitsLength (length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length)\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length)\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length)\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length)\n  }\n}\n\n/**\n * Merges adjacent segments which have the same mode\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction mergeSegments (segs) {\n  return segs.reduce(function (acc, curr) {\n    var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data\n      return acc\n    }\n\n    acc.push(curr)\n    return acc\n  }, [])\n}\n\n/**\n * Generates a list of all possible nodes combination which\n * will be used to build a segments graph.\n *\n * Nodes are divided by groups. Each group will contain a list of all the modes\n * in which is possible to encode the given text.\n *\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\n * The group for '12345' will contain then 3 objects, one for each\n * possible encoding mode.\n *\n * Each node represents a possible segment.\n *\n * @param  {Array} segs Array of object with segments data\n * @return {Array}      Array of object with segments data\n */\nfunction buildNodes (segs) {\n  var nodes = []\n  for (var i = 0; i < segs.length; i++) {\n    var seg = segs[i]\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\n        ])\n        break\n      case Mode.KANJI:\n        nodes.push([seg,\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n        break\n      case Mode.BYTE:\n        nodes.push([\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\n        ])\n    }\n  }\n\n  return nodes\n}\n\n/**\n * Builds a graph from a list of nodes.\n * All segments in each node group will be connected with all the segments of\n * the next group and so on.\n *\n * At each connection will be assigned a weight depending on the\n * segment's byte length.\n *\n * @param  {Array} nodes    Array of object with segments data\n * @param  {Number} version QR Code version\n * @return {Object}         Graph of all possible segments\n */\nfunction buildGraph (nodes, version) {\n  var table = {}\n  var graph = {'start': {}}\n  var prevNodeIds = ['start']\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeGroup = nodes[i]\n    var currentNodeIds = []\n\n    for (var j = 0; j < nodeGroup.length; j++) {\n      var node = nodeGroup[j]\n      var key = '' + i + j\n\n      currentNodeIds.push(key)\n      table[key] = { node: node, lastCount: 0 }\n      graph[key] = {}\n\n      for (var n = 0; n < prevNodeIds.length; n++) {\n        var prevNodeId = prevNodeIds[n]\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] =\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\n\n          table[prevNodeId].lastCount += node.length\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\n\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds\n  }\n\n  for (n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]]['end'] = 0\n  }\n\n  return { map: graph, table: table }\n}\n\n/**\n * Builds a segment from a specified data and mode.\n * If a mode is not specified, the more suitable will be used.\n *\n * @param  {String} data             Input data\n * @param  {Mode | String} modesHint Data mode\n * @return {Segment}                 Segment\n */\nfunction buildSingleSegment (data, modesHint) {\n  var mode\n  var bestMode = Mode.getBestModeForData(data)\n\n  mode = Mode.from(modesHint, bestMode)\n\n  // Make sure data can be encoded\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' +\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\n  }\n\n  // Use Mode.BYTE if Kanji support is disabled\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data)\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data)\n\n    case Mode.KANJI:\n      return new KanjiData(data)\n\n    case Mode.BYTE:\n      return new ByteData(data)\n  }\n}\n\n/**\n * Builds a list of segments from an array.\n * Array can contain Strings or Objects with segment's info.\n *\n * For each item which is a string, will be generated a segment with the given\n * string and the more appropriate encoding mode.\n *\n * For each item which is an object, will be generated a segment with the given\n * data and mode.\n * Objects must contain at least the property \"data\".\n * If property \"mode\" is not present, the more suitable mode will be used.\n *\n * @param  {Array} array Array of objects with segments data\n * @return {Array}       Array of Segments\n */\nexports.fromArray = function fromArray (array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null))\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode))\n    }\n\n    return acc\n  }, [])\n}\n\n/**\n * Builds an optimized sequence of segments from a string,\n * which will produce the shortest possible bitstream.\n *\n * @param  {String} data    Input string\n * @param  {Number} version QR Code version\n * @return {Array}          Array of segments\n */\nexports.fromString = function fromString (data, version) {\n  var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n\n  var nodes = buildNodes(segs)\n  var graph = buildGraph(nodes, version)\n  var path = dijkstra.find_path(graph.map, 'start', 'end')\n\n  var optimizedSegs = []\n  for (var i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node)\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs))\n}\n\n/**\n * Splits a string in various segments with the modes which\n * best represent their content.\n * The produced segments are far from being optimized.\n * The output of this function is only used to estimate a QR Code version\n * which may contain the data.\n *\n * @param  {string} data Input string\n * @return {Array}       Array of segments\n */\nexports.rawSplit = function rawSplit (data) {\n  return exports.fromArray(\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\n  )\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","getSegments","regex","mode","str","segments","result","exec","push","data","index","length","getSegmentsFromString","dataStr","numSegs","Regex","NUMERIC","Mode","alphaNumSegs","ALPHANUMERIC","Utils","isKanjiModeEnabled","byteSegs","BYTE","kanjiSegs","KANJI","BYTE_KANJI","segs","concat","sort","s1","s2","map","obj","getSegmentBitsLength","NumericData","getBitsLength","AlphanumericData","KanjiData","ByteData","mergeSegments","reduce","acc","curr","prevSeg","buildSingleSegment","modesHint","bestMode","getBestModeForData","from","bit","Error","toString","dijkstra","fromArray","exports.fromArray","array","seg","fromString","exports.fromString","version","nodes","i","unescape","encodeURIComponent","table","graph","prevNodeIds","nodeGroup","currentNodeIds","j","node","key","lastCount","n","prevNodeId","getCharCountIndicator","path","find_path","optimizedSegs","rawSplit","exports.rawSplit"]
}
