shadow$provide.module$node_modules$pocket_js_core$src$pocket=function(global,require,module,exports){global=require("module$node_modules$pocket_js_core$src$models$index");const Blockchain=global.Blockchain,Dispatch=global.Dispatch,Relay=global.Relay,Report=global.Report;class Configuration{constructor(devID,blockchains,maxNodes,requestTimeOut){this.devID=devID;this.blockchains=blockchains;this.maxNodes=maxNodes||5;this.nodes=[];this.requestTimeOut=requestTimeOut||1E4;this.dispatch=null}nodesIsEmpty(){return null==
this.nodes||0==this.nodes.length?!0:!1}}class Pocket{constructor(opts){var blockchains=[];if(null==opts.devID||null==opts.networkName||null==opts.netIDs)return Error("Invalid number of arguments");if(Array.isArray(opts.netIDs))opts.netIDs.forEach(element=>{element=new Blockchain(opts.networkName,element);blockchains.push(element.toJSON())});else{var blockchain=new Blockchain(opts.networkName,opts.netIDs);blockchains.push(blockchain.toJSON())}this.configuration=new Configuration(opts.devID,blockchains,
opts.maxNodes||5,opts.requestTimeOut||1E4)}createRelay(blockchain,netID,data){return"string"==typeof data?new Relay(blockchain,netID,data,this.configuration):new Relay(blockchain,netID,JSON.stringify(data),this.configuration)}createReport(ip,message){return new Report(ip,message,this.configuration)}getDispatch(){null==this.dispatch&&(this.dispatch=new Dispatch(this.configuration));return this.dispatch}async getNode(netID,network){try{var nodes=[];if(this.configuration.nodesIsEmpty()){var response=
await this.retrieveNodes();if(1==response instanceof Error)throw response;this.configuration.nodes=response}this.configuration.nodes.forEach(node=>{node.isEqual(netID,network)&&nodes.push(node)});return 0>=nodes.length?null:nodes[Math.floor(Math.random()*nodes.length)]}catch(error){return null}}async sendReport(report,callback){try{if(null==report)throw Error("Report is null");if(!report.isValid())throw Error("One or more Report properties are empty.");var response=await report.send();if(0==response instanceof
Error)if(callback)callback(null,response);else return response;else if(callback)callback(response);else return response}catch(error){if(callback)callback(error);else return error}}async sendRelay(relay,callback){try{if(null==relay||null==relay.data){if(callback){callback(Error("Relay is null or data field is missing"));return}return Error("Relay is null or data field is missing")}if(!relay.isValid()){if(callback){callback(Error("Relay is missing a property, please verify all properties."));return}return Error("Relay is missing a property, please verify all properties.")}var node=
await this.getNode(relay.netID,relay.blockchain);if(null==node){if(callback){callback(Error("Node is empty."));return}return Error("Node is empty.")}var response=await node.sendRelay(relay);if(0==response instanceof Error)if(callback)callback(null,response);else return response;else if(callback)callback(response);else return response}catch(error){if(callback)callback(Error("Failed to send relay with error: "+error));else return Error("Failed to send relay with error: "+error)}}async retrieveNodes(callback){try{var nodes=
await this.getDispatch().retrieveServiceNodes();if(0==nodes instanceof Error&&0!=nodes.length)if(this.configuration.nodes=nodes,callback)callback(null,nodes);else return nodes;else if(callback)callback(Error("Failed to retrieve a list of nodes."),null);else return Error("Failed to retrieve a list of nodes.")}catch(error){if(callback)callback(Error("Failed to retrieve a list of nodes with error: "+error),null);else return Error("Failed to retrieve a list of nodes with error: "+error)}}}module.exports=
Pocket}
//# sourceMappingURL=module$node_modules$pocket_js_core$src$pocket.js.map
