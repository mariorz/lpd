shadow$provide.module$node_modules$ethereumjs_util$dist$index=function(global,require,module,exports){var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj};global=require("module$node_modules$ethereum_cryptography$keccak");var keccak224=global.keccak224,keccak384=global.keccak384,k256=global.keccak256,keccak512=global.keccak512,
secp256k1=require("module$node_modules$ethereumjs_util$dist$secp256k1_adapter"),assert=require("module$node_modules$assert$assert"),rlp=require("module$node_modules$rlp$dist$index"),BN=require("module$node_modules$bn_DOT_js$lib$bn"),createHash=require("module$node_modules$create_hash$browser"),Buffer=require("module$node_modules$safe_buffer$index").Buffer;Object.assign(exports,require("module$node_modules$ethjs_util$lib$index"));exports.MAX_INTEGER=new BN("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
16);exports.TWO_POW256=new BN("10000000000000000000000000000000000000000000000000000000000000000",16);exports.KECCAK256_NULL_S="c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";exports.SHA3_NULL_S=exports.KECCAK256_NULL_S;exports.KECCAK256_NULL=Buffer.from(exports.KECCAK256_NULL_S,"hex");exports.SHA3_NULL=exports.KECCAK256_NULL;exports.KECCAK256_RLP_ARRAY_S="1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";exports.SHA3_RLP_ARRAY_S=exports.KECCAK256_RLP_ARRAY_S;exports.KECCAK256_RLP_ARRAY=
Buffer.from(exports.KECCAK256_RLP_ARRAY_S,"hex");exports.SHA3_RLP_ARRAY=exports.KECCAK256_RLP_ARRAY;exports.KECCAK256_RLP_S="56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";exports.SHA3_RLP_S=exports.KECCAK256_RLP_S;exports.KECCAK256_RLP=Buffer.from(exports.KECCAK256_RLP_S,"hex");exports.SHA3_RLP=exports.KECCAK256_RLP;exports.BN=BN;exports.rlp=rlp;exports.secp256k1=secp256k1;exports.zeros=function(bytes){return Buffer.allocUnsafe(bytes).fill(0)};exports.zeroAddress=function(){var zeroAddress=
exports.zeros(20);return exports.bufferToHex(zeroAddress)};exports.setLengthLeft=exports.setLength=function(msg,length,right){var buf=exports.zeros(length);msg=exports.toBuffer(msg);return right?msg.length<length?(msg.copy(buf),buf):msg.slice(0,length):msg.length<length?(msg.copy(buf,length-msg.length),buf):msg.slice(-length)};exports.setLengthRight=function(msg,length){return exports.setLength(msg,length,!0)};exports.unpad=exports.stripZeros=function(a){a=exports.stripHexPrefix(a);for(var first=
a[0];0<a.length&&"0"===first.toString();)a=a.slice(1),first=a[0];return a};exports.toBuffer=function(v){if(!Buffer.isBuffer(v))if(Array.isArray(v))v=Buffer.from(v);else if("string"===typeof v)v=exports.isHexString(v)?Buffer.from(exports.padToEven(exports.stripHexPrefix(v)),"hex"):Buffer.from(v);else if("number"===typeof v)v=exports.intToBuffer(v);else if(null===v||void 0===v)v=Buffer.allocUnsafe(0);else if(BN.isBN(v))v=v.toArrayLike(Buffer);else if(v.toArray)v=Buffer.from(v.toArray());else throw Error("invalid type");
return v};exports.bufferToInt=function(buf){return(new BN(exports.toBuffer(buf))).toNumber()};exports.bufferToHex=function(buf){buf=exports.toBuffer(buf);return"0x"+buf.toString("hex")};exports.fromSigned=function(num){return(new BN(num)).fromTwos(256)};exports.toUnsigned=function(num){return Buffer.from(num.toTwos(256).toArray())};exports.keccak=function(a,bits){a=exports.toBuffer(a);bits||(bits=256);switch(bits){case 224:return keccak224(a);case 256:return k256(a);case 384:return keccak384(a);case 512:return keccak512(a);
default:throw Error("Invald algorithm: keccak"+bits);}};exports.keccak256=function(a){return exports.keccak(a)};exports.sha3=exports.keccak;exports.sha256=function(a){a=exports.toBuffer(a);return createHash("sha256").update(a).digest()};exports.ripemd160=function(a,padded){a=exports.toBuffer(a);a=createHash("rmd160").update(a).digest();return!0===padded?exports.setLength(a,32):a};exports.rlphash=function(a){return exports.keccak(rlp.encode(a))};exports.isValidPrivate=function(privateKey){return secp256k1.privateKeyVerify(privateKey)};
exports.isValidPublic=function(publicKey,sanitize){return 64===publicKey.length?secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]),publicKey])):sanitize?secp256k1.publicKeyVerify(publicKey):!1};exports.pubToAddress=exports.publicToAddress=function(pubKey,sanitize){pubKey=exports.toBuffer(pubKey);sanitize&&64!==pubKey.length&&(pubKey=secp256k1.publicKeyConvert(pubKey,!1).slice(1));assert(64===pubKey.length);return exports.keccak(pubKey).slice(-20)};var privateToPublic=exports.privateToPublic=
function(privateKey){privateKey=exports.toBuffer(privateKey);return secp256k1.publicKeyCreate(privateKey,!1).slice(1)};exports.importPublic=function(publicKey){publicKey=exports.toBuffer(publicKey);64!==publicKey.length&&(publicKey=secp256k1.publicKeyConvert(publicKey,!1).slice(1));return publicKey};exports.ecsign=function(msgHash,privateKey){msgHash=secp256k1.sign(msgHash,privateKey);privateKey={};privateKey.r=msgHash.signature.slice(0,32);privateKey.s=msgHash.signature.slice(32,64);privateKey.v=
msgHash.recovery+27;return privateKey};exports.hashPersonalMessage=function(message){var prefix=exports.toBuffer("Ethereum Signed Message:\n"+message.length.toString());return exports.keccak(Buffer.concat([prefix,message]))};exports.ecrecover=function(msgHash,v,r,s){r=Buffer.concat([exports.setLength(r,32),exports.setLength(s,32)],64);v-=27;if(0!==v&&1!==v)throw Error("Invalid signature v value");msgHash=secp256k1.recover(msgHash,r,v);return secp256k1.publicKeyConvert(msgHash,!1).slice(1)};exports.toRpcSig=
function(v,r,s){if(27!==v&&28!==v)throw Error("Invalid recovery id");return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r,32),exports.setLengthLeft(s,32),exports.toBuffer(v-27)]))};exports.fromRpcSig=function(sig){sig=exports.toBuffer(sig);if(65!==sig.length)throw Error("Invalid signature length");var v=sig[64];27>v&&(v+=27);return{v,r:sig.slice(0,32),s:sig.slice(32,64)}};exports.privateToAddress=function(privateKey){return exports.publicToAddress(privateToPublic(privateKey))};exports.isValidAddress=
function(address){return/^0x[0-9a-fA-F]{40}$/.test(address)};exports.isZeroAddress=function(address){return exports.zeroAddress()===exports.addHexPrefix(address)};exports.toChecksumAddress=function(address){address=exports.stripHexPrefix(address).toLowerCase();for(var hash=exports.keccak(address).toString("hex"),ret="0x",i=0;i<address.length;i++)ret=8<=parseInt(hash[i],16)?ret+address[i].toUpperCase():ret+address[i];return ret};exports.isValidChecksumAddress=function(address){return exports.isValidAddress(address)&&
exports.toChecksumAddress(address)===address};exports.generateAddress=function(from,nonce){from=exports.toBuffer(from);nonce=new BN(nonce);nonce=nonce.isZero()?null:Buffer.from(nonce.toArray());return exports.rlphash([from,nonce]).slice(-20)};exports.isPrecompiled=function(address){address=exports.unpad(address);return 1===address.length&&1<=address[0]&&8>=address[0]};exports.addHexPrefix=function(str){return"string"!==typeof str?str:exports.isHexPrefixed(str)?str:"0x"+str};exports.isValidSignature=
function(v,r,s,homestead){var SECP256K1_N_DIV_2=new BN("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0",16),SECP256K1_N=new BN("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",16);if(32!==r.length||32!==s.length||27!==v&&28!==v)return!1;r=new BN(r);s=new BN(s);return r.isZero()||r.gt(SECP256K1_N)||s.isZero()||s.gt(SECP256K1_N)||!1===homestead&&1===(new BN(s)).cmp(SECP256K1_N_DIV_2)?!1:!0};exports.baToJSON=function(ba){if(Buffer.isBuffer(ba))return"0x"+ba.toString("hex");
if(ba instanceof Array){for(var array=[],i=0;i<ba.length;i++)array.push(exports.baToJSON(ba[i]));return array}};exports.defineProperties=function(self,fields,data){self.raw=[];self._fields=[];self.toJSON=function(label){if(label){var obj={};self._fields.forEach(function(field){obj[field]="0x"+self[field].toString("hex")});return obj}return exports.baToJSON(this.raw)};self.serialize=function(){return rlp.encode(self.raw)};fields.forEach(function(field,i){function getter(){return self.raw[i]}function setter(v){v=
exports.toBuffer(v);"00"!==v.toString("hex")||field.allowZero||(v=Buffer.allocUnsafe(0));field.allowLess&&field.length?(v=exports.stripZeros(v),assert(field.length>=v.length,"The field "+field.name+" must not have more "+field.length+" bytes")):field.allowZero&&0===v.length||!field.length||assert(field.length===v.length,"The field "+field.name+" must have byte length of "+field.length);self.raw[i]=v}self._fields.push(field.name);Object.defineProperty(self,field.name,{enumerable:!0,configurable:!0,
get:getter,set:setter});field.default&&(self[field.name]=field.default);field.alias&&Object.defineProperty(self,field.alias,{enumerable:!1,configurable:!0,set:setter,get:getter})});if(data)if("string"===typeof data&&(data=Buffer.from(exports.stripHexPrefix(data),"hex")),Buffer.isBuffer(data)&&(data=rlp.decode(data)),Array.isArray(data)){if(data.length>self._fields.length)throw Error("wrong number of fields in data");data.forEach(function(d,i){self[self._fields[i]]=exports.toBuffer(d)})}else if("object"===
("undefined"===typeof data?"undefined":_typeof(data))){var keys=Object.keys(data);fields.forEach(function(field){-1!==keys.indexOf(field.name)&&(self[field.name]=data[field.name]);-1!==keys.indexOf(field.alias)&&(self[field.alias]=data[field.alias])})}else throw Error("invalid data");}}
//# sourceMappingURL=module$node_modules$ethereumjs_util$dist$index.js.map
