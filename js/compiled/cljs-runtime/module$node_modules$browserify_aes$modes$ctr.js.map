{
"version":3,
"file":"module$node_modules$browserify_aes$modes$ctr.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAe,4CAAf,CAAiE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACzG,IAAIC,IAAMH,OAAA,CAAQ,sCAAR,CAAV,CACII,OAASJ,OAAA,CAAQ,uCAAR,CAATI,CAAgCA,MADpC,CAEIC,OAASL,OAAA,CAAQ,2CAAR,CASbE,QAAA,CAAQI,OAAR,CAAkBC,QAAS,CAACC,IAAD,CAAOC,KAAP,CAAc,CACvC,IAAIC,SAAWC,IAAA,CAAKC,IAAL,CAAUH,KAAV,CAAgBI,MAAhB,CAFDC,EAEC,CAAf,CACIC,MAAQP,IAARO,CAAaC,MAAbD,CAAoBF,MACxBL,KAAA,CAAKQ,MAAL,CAAcZ,MAAA,CAAOa,MAAP,CAAc,CAC1BT,IAD0B,CACrBQ,MADqB,CAE1BZ,MAAA,CAAOc,WAAP,CANYJ,EAMZ,CAAmBJ,QAAnB,CAF0B,CAAd,CAId,KAAK,IAAIS,EAAI,CAAb,CAAgBA,CAAhB,CAAoBT,QAApB,CAA8BS,CAAA,EAA9B,CAAmC,CACdX,IAAAA,IAAAA,IAdrB,KAAIY;AAAMZ,GAAA,CAAKa,OAAL,CAAaC,eAAb,CAA6Bd,GAA7B,CAAkCe,KAAlC,CACVlB,OAAA,CAAOG,GAAP,CAAYe,KAAZ,CACA,IAAA,CAAOH,YAaDI,aAAAA,CAAST,KAATS,CAVQV,EAURU,CAAiBL,CACrBX,KAAA,CAAKQ,MAAL,CAAYS,aAAZ,CAA0BL,GAAA,CAAI,CAAJ,CAA1B,CAAkCI,YAAlC,CAA2C,CAA3C,CACAhB,KAAA,CAAKQ,MAAL,CAAYS,aAAZ,CAA0BL,GAAA,CAAI,CAAJ,CAA1B,CAAkCI,YAAlC,CAA2C,CAA3C,CACAhB,KAAA,CAAKQ,MAAL,CAAYS,aAAZ,CAA0BL,GAAA,CAAI,CAAJ,CAA1B,CAAkCI,YAAlC,CAA2C,CAA3C,CACAhB,KAAA,CAAKQ,MAAL,CAAYS,aAAZ,CAA0BL,GAAA,CAAI,CAAJ,CAA1B,CAAkCI,YAAlC,CAA2C,EAA3C,CANiC,CAQ/BE,QAAAA,CAAMlB,IAAA,CAAKQ,MAAL,CAAYW,KAAZ,CAAkB,CAAlB,CAAqBlB,KAArB,CAA2BI,MAA3B,CACVL,KAAA,CAAKQ,MAAL,CAAcR,IAAA,CAAKQ,MAAL,CAAYW,KAAZ,CAAkBlB,KAAlB,CAAwBI,MAAxB,CACd,OAAOV,IAAA,CAAIM,KAAJ,CAAWiB,QAAX,CAjBgC,CAZgE;",
"sources":["node_modules/browserify-aes/modes/ctr.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$browserify_aes$modes$ctr\"] = function(global,require,module,exports) {\nvar xor = require('buffer-xor')\nvar Buffer = require('safe-buffer').Buffer\nvar incr32 = require('../incr32')\n\nfunction getBlock (self) {\n  var out = self._cipher.encryptBlockRaw(self._prev)\n  incr32(self._prev)\n  return out\n}\n\nvar blockSize = 16\nexports.encrypt = function (self, chunk) {\n  var chunkNum = Math.ceil(chunk.length / blockSize)\n  var start = self._cache.length\n  self._cache = Buffer.concat([\n    self._cache,\n    Buffer.allocUnsafe(chunkNum * blockSize)\n  ])\n  for (var i = 0; i < chunkNum; i++) {\n    var out = getBlock(self)\n    var offset = start + i * blockSize\n    self._cache.writeUInt32BE(out[0], offset + 0)\n    self._cache.writeUInt32BE(out[1], offset + 4)\n    self._cache.writeUInt32BE(out[2], offset + 8)\n    self._cache.writeUInt32BE(out[3], offset + 12)\n  }\n  var pad = self._cache.slice(0, chunk.length)\n  self._cache = self._cache.slice(chunk.length)\n  return xor(chunk, pad)\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","xor","Buffer","incr32","encrypt","exports.encrypt","self","chunk","chunkNum","Math","ceil","length","blockSize","start","_cache","concat","allocUnsafe","i","out","_cipher","encryptBlockRaw","_prev","offset","writeUInt32BE","pad","slice"]
}
