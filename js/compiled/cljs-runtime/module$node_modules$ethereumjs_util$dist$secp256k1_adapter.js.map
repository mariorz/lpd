{
"version":3,
"file":"module$node_modules$ethereumjs_util$dist$secp256k1_adapter.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/ethereumjs-util/dist/secp256k1-adapter.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$ethereumjs_util$dist$secp256k1_adapter\"] = function(global,require,module,exports) {\nvar Buffer = require('buffer').Buffer;\n'use strict';\n\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\n\nvar secp256k1v3 = require('./secp256k1-lib/index');\nvar der = require('./secp256k1-lib/der');\n\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */\nvar privateKeyVerify = function privateKeyVerify(privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */\nvar privateKeyExport = function privateKeyExport(privateKey, compressed) {\n  // privateKeyExport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\nvar privateKeyImport = function privateKeyImport(privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n\n  throw new Error(\"couldn't import from DER format\");\n};\n\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar privateKeyNegate = function privateKeyNegate(privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar privateKeyModInverse = function privateKeyModInverse(privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nvar privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\nvar privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyCreate = function publicKeyCreate(privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyConvert = function publicKeyConvert(publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nvar publicKeyVerify = function publicKeyVerify(publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureNormalize = function signatureNormalize(signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureExport = function signatureExport(signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureImport = function signatureImport(signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */\nvar signatureImportLax = function signatureImportLax(signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n\n  var sigObj = der.signatureImportLax(signature);\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n\n  return secp256k1v3.signatureImport(sigObj);\n};\n\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */\nvar sign = function sign(message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n\n  var signOptions = void 0;\n\n  if (options) {\n    signOptions = {};\n\n    if (options.data === null) {\n      throw new TypeError('options.data should be a Buffer');\n    }\n\n    if (options.data) {\n      // validate option.data length\n      if (options.data.length !== 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n\n      signOptions.data = new Uint8Array(options.data);\n    }\n\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n\n    if (options.noncefn) {\n      //  convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n\n        var buffer = Buffer.from('');\n\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n\n        return Uint8Array.from(buffer);\n      };\n    }\n  }\n\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */\nvar verify = function verify(message, signature, publicKey) {\n  // note: secp256k1 v4 verify method has a different argument order\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar recover = function recover(message, signature, recid, compressed) {\n  // note: secp256k1 v4 recover method has a different argument order\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\nvar ecdh = function ecdh(publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\n\n/**\n * Compute an EC Diffie-Hellman secret and return public key as result\n * @method ecdhUnsafe\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\nvar ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  }\n\n  // ensure valid privateKey length\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};\n\nmodule.exports = {\n  privateKeyVerify: privateKeyVerify,\n  privateKeyExport: privateKeyExport,\n  privateKeyImport: privateKeyImport,\n  privateKeyNegate: privateKeyNegate,\n  privateKeyModInverse: privateKeyModInverse,\n  privateKeyTweakAdd: privateKeyTweakAdd,\n  privateKeyTweakMul: privateKeyTweakMul,\n\n  publicKeyCreate: publicKeyCreate,\n  publicKeyConvert: publicKeyConvert,\n  publicKeyVerify: publicKeyVerify,\n  publicKeyTweakAdd: publicKeyTweakAdd,\n  publicKeyTweakMul: publicKeyTweakMul,\n  publicKeyCombine: publicKeyCombine,\n\n  signatureNormalize: signatureNormalize,\n  signatureExport: signatureExport,\n  signatureImport: signatureImport,\n  signatureImportLax: signatureImportLax,\n\n  sign: sign,\n  verify: verify,\n  recover: recover,\n\n  ecdh: ecdh,\n  ecdhUnsafe: ecdhUnsafe\n};\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","secp256k1","secp256k1v3","der","privateKeyVerify","privateKey","length","Uint8Array","from","privateKeyExport","compressed","RangeError","publicKey","privateKeyImport","Error","privateKeyNegate","privateKeyModInverse","privateKeyTweakAdd","tweak","privateKeyTweakMul","publicKeyCreate","publicKeyConvert","publicKeyVerify","publicKeyTweakAdd","publicKeyTweakMul","publicKeyCombine","publicKeys","keys","forEach","push","signatureNormalize","signature","signatureExport","signatureImport","signatureImportLax","sigObj","sign","message","options","TypeError","signOptions","data","noncefn","signOptions.noncefn","algo","attempt","bufferAlgo","bufferData","buffer","sig","ecdsaSign","recovery","recid","verify","ecdsaVerify","recover","ecdsaRecover","ecdh","ecdhUnsafe"]
}
