shadow$provide.module$node_modules$web3_provider_engine$subproviders$hooked_wallet=function(global,require,module,exports){function HookedWalletSubprovider(opts){this.nonceLock=Semaphore(1);opts.getAccounts&&(this.getAccounts=opts.getAccounts);opts.processTransaction&&(this.processTransaction=opts.processTransaction);opts.processMessage&&(this.processMessage=opts.processMessage);opts.processPersonalMessage&&(this.processPersonalMessage=opts.processPersonalMessage);opts.processTypedMessage&&(this.processTypedMessage=
opts.processTypedMessage);this.approveTransaction=opts.approveTransaction||this.autoApprove;this.approveMessage=opts.approveMessage||this.autoApprove;this.approvePersonalMessage=opts.approvePersonalMessage||this.autoApprove;this.approveDecryptMessage=opts.approveDecryptMessage||this.autoApprove;this.approveEncryptionPublicKey=opts.approveEncryptionPublicKey||this.autoApprove;this.approveTypedMessage=opts.approveTypedMessage||this.autoApprove;opts.signTransaction&&(this.signTransaction=opts.signTransaction||
mustProvideInConstructor("signTransaction"));opts.signMessage&&(this.signMessage=opts.signMessage||mustProvideInConstructor("signMessage"));opts.signPersonalMessage&&(this.signPersonalMessage=opts.signPersonalMessage||mustProvideInConstructor("signPersonalMessage"));opts.decryptMessage&&(this.decryptMessage=opts.decryptMessage||mustProvideInConstructor("decryptMessage"));opts.encryptionPublicKey&&(this.encryptionPublicKey=opts.encryptionPublicKey||mustProvideInConstructor("encryptionPublicKey"));
opts.signTypedMessage&&(this.signTypedMessage=opts.signTypedMessage||mustProvideInConstructor("signTypedMessage"));opts.recoverPersonalSignature&&(this.recoverPersonalSignature=opts.recoverPersonalSignature);opts.publishTransaction&&(this.publishTransaction=opts.publishTransaction);this.estimateGas=opts.estimateGas||this.estimateGas;this.getGasPrice=opts.getGasPrice||this.getGasPrice}function toLowerCase(string){return string.toLowerCase()}function resemblesAddress(string){string=ethUtil.addHexPrefix(string);
return ethUtil.isValidAddress(string)}function resemblesData(string){const fixed=ethUtil.addHexPrefix(string);return!ethUtil.isValidAddress(fixed)&&isValidHex(string)}function isValidHex(data){return"string"!==typeof data||"0x"!==data.slice(0,2)?!1:data.slice(2).match(hexRegex)}function mustProvideInConstructor(methodName){return function(params,cb){cb(Error('ProviderEngine - HookedWalletSubprovider - Must provide "'+methodName+'" fn in constructor options'))}}const waterfall=require("module$node_modules$async$waterfall"),
parallel=require("module$node_modules$async$parallel");global=require("module$node_modules$util$util").inherits;const ethUtil=require("module$node_modules$ethereumjs_util$dist$index"),sigUtil=require("module$node_modules$eth_sig_util$index"),extend=require("module$node_modules$xtend$immutable"),Semaphore=require("module$node_modules$semaphore$lib$semaphore");exports=require("module$node_modules$web3_provider_engine$subproviders$subprovider");const estimateGas=require("module$node_modules$web3_provider_engine$util$estimate_gas"),
hexRegex=/^[0-9A-Fa-f]+$/g;module.exports=HookedWalletSubprovider;global(HookedWalletSubprovider,exports);HookedWalletSubprovider.prototype.handleRequest=function(payload,next,end){const self=this;self._parityRequests={};self._parityRequestCount=0;let txParams,msgParams,extraParams,message,address$jscomp$0;switch(payload.method){case "eth_coinbase":self.getAccounts(function(err,accounts){if(err)return end(err);end(null,accounts[0]||null)});break;case "eth_accounts":self.getAccounts(function(err,accounts){if(err)return end(err);
end(null,accounts)});break;case "eth_sendTransaction":txParams=payload.params[0];waterfall([cb=>self.validateTransaction(txParams,cb),cb=>self.processTransaction(txParams,cb)],end);break;case "eth_signTransaction":txParams=payload.params[0];waterfall([cb=>self.validateTransaction(txParams,cb),cb=>self.processSignTransaction(txParams,cb)],end);break;case "eth_sign":address$jscomp$0=payload.params[0];message=payload.params[1];extraParams=payload.params[2]||{};msgParams=extend(extraParams,{from:address$jscomp$0,
data:message});waterfall([cb=>self.validateMessage(msgParams,cb),cb=>self.processMessage(msgParams,cb)],end);break;case "personal_sign":return function(){const first=payload.params[0];resemblesData(payload.params[1])&&resemblesAddress(first)?(console.warn("The eth_personalSign method requires params ordered [message, address]. This was previously handled incorrectly, and has been corrected automatically. Please switch this param order for smooth behavior in the future."),address$jscomp$0=payload.params[0],
message=payload.params[1]):(message=payload.params[0],address$jscomp$0=payload.params[1]);extraParams=payload.params[2]||{};msgParams=extend(extraParams,{from:address$jscomp$0,data:message});waterfall([cb=>self.validatePersonalMessage(msgParams,cb),cb=>self.processPersonalMessage(msgParams,cb)],end)}();case "eth_decryptMessage":return function(){const first=payload.params[0];resemblesData(payload.params[1])&&resemblesAddress(first)?(console.warn("The eth_decryptMessage method requires params ordered [message, address]. This was previously handled incorrectly, and has been corrected automatically. Please switch this param order for smooth behavior in the future."),
address$jscomp$0=payload.params[0],message=payload.params[1]):(message=payload.params[0],address$jscomp$0=payload.params[1]);extraParams=payload.params[2]||{};msgParams=extend(extraParams,{from:address$jscomp$0,data:message});waterfall([cb=>self.validateDecryptMessage(msgParams,cb),cb=>self.processDecryptMessage(msgParams,cb)],end)}();case "encryption_public_key":return function(){const address=payload.params[0];waterfall([cb=>self.validateEncryptionPublicKey(address,cb),cb=>self.processEncryptionPublicKey(address,
cb)],end)}();case "personal_ecRecover":return function(){message=payload.params[0];let signature=payload.params[1];extraParams=payload.params[2]||{};msgParams=extend(extraParams,{sig:signature,data:message});self.recoverPersonalSignature(msgParams,end)}();case "eth_signTypedData":case "eth_signTypedData_v3":case "eth_signTypedData_v4":return function(){const first=payload.params[0],second=payload.params[1];resemblesAddress(first)?(address$jscomp$0=first,message=second):(message=first,address$jscomp$0=
second);extraParams=payload.params[2]||{};msgParams=extend(extraParams,{from:address$jscomp$0,data:message});waterfall([cb=>self.validateTypedMessage(msgParams,cb),cb=>self.processTypedMessage(msgParams,cb)],end)}();case "parity_postTransaction":txParams=payload.params[0];self.parityPostTransaction(txParams,end);break;case "parity_postSign":address$jscomp$0=payload.params[0];message=payload.params[1];self.parityPostSign(address$jscomp$0,message,end);break;case "parity_checkRequest":self.parityCheckRequest(payload.params[0],
end);break;case "parity_defaultAccount":self.getAccounts(function(err,accounts){if(err)return end(err);end(null,accounts[0]||null)});break;default:next()}};HookedWalletSubprovider.prototype.getAccounts=function(cb){cb(null,[])};HookedWalletSubprovider.prototype.processTransaction=function(txParams,cb$jscomp$0){const self=this;waterfall([cb=>self.approveTransaction(txParams,cb),(didApprove,cb)=>self.checkApproval("transaction",didApprove,cb),cb=>self.finalizeAndSubmitTx(txParams,cb)],cb$jscomp$0)};
HookedWalletSubprovider.prototype.processSignTransaction=function(txParams,cb$jscomp$0){const self=this;waterfall([cb=>self.approveTransaction(txParams,cb),(didApprove,cb)=>self.checkApproval("transaction",didApprove,cb),cb=>self.finalizeTx(txParams,cb)],cb$jscomp$0)};HookedWalletSubprovider.prototype.processMessage=function(msgParams,cb$jscomp$0){const self=this;waterfall([cb=>self.approveMessage(msgParams,cb),(didApprove,cb)=>self.checkApproval("message",didApprove,cb),cb=>self.signMessage(msgParams,
cb)],cb$jscomp$0)};HookedWalletSubprovider.prototype.processPersonalMessage=function(msgParams,cb$jscomp$0){const self=this;waterfall([cb=>self.approvePersonalMessage(msgParams,cb),(didApprove,cb)=>self.checkApproval("message",didApprove,cb),cb=>self.signPersonalMessage(msgParams,cb)],cb$jscomp$0)};HookedWalletSubprovider.prototype.processDecryptMessage=function(msgParams,cb$jscomp$0){const self=this;waterfall([cb=>self.approveDecryptMessage(msgParams,cb),(didApprove,cb)=>self.checkApproval("decryptMessage",
didApprove,cb),cb=>self.decryptMessage(msgParams,cb)],cb$jscomp$0)};HookedWalletSubprovider.prototype.processEncryptionPublicKey=function(msgParams,cb$jscomp$0){const self=this;waterfall([cb=>self.approveEncryptionPublicKey(msgParams,cb),(didApprove,cb)=>self.checkApproval("encryptionPublicKey",didApprove,cb),cb=>self.encryptionPublicKey(msgParams,cb)],cb$jscomp$0)};HookedWalletSubprovider.prototype.processTypedMessage=function(msgParams,cb$jscomp$0){const self=this;waterfall([cb=>self.approveTypedMessage(msgParams,
cb),(didApprove,cb)=>self.checkApproval("message",didApprove,cb),cb=>self.signTypedMessage(msgParams,cb)],cb$jscomp$0)};HookedWalletSubprovider.prototype.autoApprove=function(txParams,cb){cb(null,!0)};HookedWalletSubprovider.prototype.checkApproval=function(type,didApprove,cb){cb(didApprove?null:Error("User denied "+type+" signature."))};HookedWalletSubprovider.prototype.parityPostTransaction=function(txParams,cb){const self=this,reqId=`0x${self._parityRequestCount.toString(16)}`;self._parityRequestCount++;
self.emitPayload({method:"eth_sendTransaction",params:[txParams]},function(error,res){self._parityRequests[reqId]=error?{error}:res.result});cb(null,reqId)};HookedWalletSubprovider.prototype.parityPostSign=function(address,message,cb){const self=this,reqId=`0x${self._parityRequestCount.toString(16)}`;self._parityRequestCount++;self.emitPayload({method:"eth_sign",params:[address,message]},function(error,res){self._parityRequests[reqId]=error?{error}:res.result});cb(null,reqId)};HookedWalletSubprovider.prototype.parityCheckRequest=
function(reqId,cb){reqId=this._parityRequests[reqId]||null;if(!reqId)return cb(null,null);if(reqId.error)return cb(reqId.error);cb(null,reqId)};HookedWalletSubprovider.prototype.recoverPersonalSignature=function(msgParams,cb){let senderHex;try{senderHex=sigUtil.recoverPersonalSignature(msgParams)}catch(err){return cb(err)}cb(null,senderHex)};HookedWalletSubprovider.prototype.validateTransaction=function(txParams,cb){if(void 0===txParams.from)return cb(Error("Undefined address - from address required to sign transaction."));
this.validateSender(txParams.from,function(err,senderIsValid){if(err)return cb(err);if(!senderIsValid)return cb(Error(`Unknown address - unable to sign transaction for this address: "${txParams.from}"`));cb()})};HookedWalletSubprovider.prototype.validateMessage=function(msgParams,cb){if(void 0===msgParams.from)return cb(Error("Undefined address - from address required to sign message."));this.validateSender(msgParams.from,function(err,senderIsValid){if(err)return cb(err);if(!senderIsValid)return cb(Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
cb()})};HookedWalletSubprovider.prototype.validatePersonalMessage=function(msgParams,cb){if(void 0===msgParams.from)return cb(Error("Undefined address - from address required to sign personal message."));if(void 0===msgParams.data)return cb(Error("Undefined message - message required to sign personal message."));if(!isValidHex(msgParams.data))return cb(Error("HookedWalletSubprovider - validateMessage - message was not encoded as hex."));this.validateSender(msgParams.from,function(err,senderIsValid){if(err)return cb(err);
if(!senderIsValid)return cb(Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));cb()})};HookedWalletSubprovider.prototype.validateDecryptMessage=function(msgParams,cb){if(void 0===msgParams.from)return cb(Error("Undefined address - from address required to decrypt message."));if(void 0===msgParams.data)return cb(Error("Undefined message - message required to decrypt message."));if(!isValidHex(msgParams.data))return cb(Error("HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex."));
this.validateSender(msgParams.from,function(err,senderIsValid){if(err)return cb(err);if(!senderIsValid)return cb(Error(`Unknown address - unable to decrypt message for this address: "${msgParams.from}"`));cb()})};HookedWalletSubprovider.prototype.validateEncryptionPublicKey=function(address,cb){this.validateSender(address,function(err,senderIsValid){if(err)return cb(err);if(!senderIsValid)return cb(Error(`Unknown address - unable to obtain encryption public key for this address: "${address}"`));cb()})};
HookedWalletSubprovider.prototype.validateTypedMessage=function(msgParams,cb){if(void 0===msgParams.from)return cb(Error("Undefined address - from address required to sign typed data."));if(void 0===msgParams.data)return cb(Error("Undefined data - message required to sign typed data."));this.validateSender(msgParams.from,function(err,senderIsValid){if(err)return cb(err);if(!senderIsValid)return cb(Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));cb()})};HookedWalletSubprovider.prototype.validateSender=
function(senderAddress,cb){if(!senderAddress)return cb(null,!1);this.getAccounts(function(err,accounts){if(err)return cb(err);err=-1!==accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase());cb(null,err)})};HookedWalletSubprovider.prototype.finalizeAndSubmitTx=function(txParams,cb){const self=this;self.nonceLock.take(function(){waterfall([self.fillInTxExtras.bind(self,txParams),self.signTransaction.bind(self),self.publishTransaction.bind(self)],function(err,txHash){self.nonceLock.leave();if(err)return cb(err);
cb(null,txHash)})})};HookedWalletSubprovider.prototype.finalizeTx=function(txParams,cb){const self=this;self.nonceLock.take(function(){waterfall([self.fillInTxExtras.bind(self,txParams),self.signTransaction.bind(self)],function(err,signedTx){self.nonceLock.leave();if(err)return cb(err);cb(null,{raw:signedTx,tx:txParams})})})};HookedWalletSubprovider.prototype.publishTransaction=function(rawTx,cb){this.emitPayload({method:"eth_sendRawTransaction",params:[rawTx]},function(err,res){if(err)return cb(err);
cb(null,res.result)})};HookedWalletSubprovider.prototype.estimateGas=function(txParams,cb){estimateGas(this.engine,txParams,cb)};HookedWalletSubprovider.prototype.getGasPrice=function(cb){this.emitPayload({method:"eth_gasPrice",params:[]},function(err,res){if(err)return cb(err);cb(null,res.result)})};HookedWalletSubprovider.prototype.fillInTxExtras=function(txParams,cb){const address=txParams.from,tasks={};void 0===txParams.gasPrice&&(tasks.gasPrice=this.getGasPrice.bind(this));void 0===txParams.nonce&&
(tasks.nonce=this.emitPayload.bind(this,{method:"eth_getTransactionCount",params:[address,"pending"]}));void 0===txParams.gas&&(tasks.gas=this.estimateGas.bind(this,{from:txParams.from,to:txParams.to,value:txParams.value,data:txParams.data,gas:txParams.gas,gasPrice:txParams.gasPrice,nonce:txParams.nonce}));parallel(tasks,function(err,taskResults){if(err)return cb(err);err={};taskResults.gasPrice&&(err.gasPrice=taskResults.gasPrice);taskResults.nonce&&(err.nonce=taskResults.nonce.result);taskResults.gas&&
(err.gas=taskResults.gas);cb(null,extend(txParams,err))})}}
//# sourceMappingURL=module$node_modules$web3_provider_engine$subproviders$hooked_wallet.js.map
