{
"version":3,
"file":"module$node_modules$json_rpc_engine$src$createAsyncMiddleware.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAe,6DAAf,CAAkF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAmB1HD,MAAA,CAAOC,OAAP,CAAiBC,QAA+B,CAACC,eAAD,CAAkB,CAChE,MAAO,CAACC,GAAD,CAAMC,GAAN,CAAWC,IAAX,CAAiBC,GAAjB,CAAA,EAAyB,CAK9B,IAAIC,kBACJ,OAAMC,YAAc,IAAIC,OAAJ,CAAaC,OAAD,EAAa,CAC3CH,kBAAA,CAAqBG,OADsB,CAAzB,CANU,KAU1BC,qBAV0B,CAUHC,aAa3BV,gBAAA,CAAgBC,GAAhB,CAAqBC,GAArB,CAXkBS,KAAM,EAANA,EAAY,CAE5BD,aAAA,CAAgB,CAAA,CAEhBP,KAAA,CAAMS,QAAD,EAAc,CACjBH,qBAAA,CAAwBG,QACxBP,mBAAA,EAFiB,CAAnB,CAIA,OAAMC,WARsB,CAW9B,CAAA,CACGO,IADH,CACQ,KAAM,EAAN,EAAY,CACZH,aAAJ,EACE,MAAMJ,WACN;AAAAG,qBAAA,CAAsB,IAAtB,CAFF,EAIEL,GAAA,CAAI,IAAJ,CALc,CADpB,CAAA,CASGU,KATH,CASUC,KAAD,EAAW,CACZN,qBAAJ,CACEA,qBAAA,CAAsBM,KAAtB,CADF,CAGEX,GAAA,CAAIW,KAAJ,CAJc,CATpB,CAvB8B,CADgC,CAnBwD;",
"sources":["node_modules/json-rpc-engine/src/createAsyncMiddleware.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$json_rpc_engine$src$createAsyncMiddleware\"] = function(global,require,module,exports) {\n/**\n * JsonRpcEngine only accepts callback-based middleware directly.\n * createAsyncMiddleware exists to enable consumers to pass in async middleware\n * functions.\n *\n * Async middleware have no \"end\" function. Instead, they \"end\" if they return\n * without calling \"next\". Rather than passing in explicit return handlers,\n * async middleware can simply await \"next\", and perform operations on the\n * response object when execution resumes.\n *\n * To accomplish this, createAsyncMiddleware passes the async middleware a\n * wrapped \"next\" function. That function calls the internal JsonRpcEngine\n * \"next\" function with a return handler that resolves a promise when called.\n *\n * The return handler will always be called. Its resolution of the promise\n * enables the control flow described above.\n */\n\nmodule.exports = function createAsyncMiddleware (asyncMiddleware) {\n  return (req, res, next, end) => {\n\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise\n    const nextPromise = new Promise((resolve) => {\n      resolveNextPromise = resolve\n    })\n\n    let returnHandlerCallback, nextWasCalled\n\n    const asyncNext = async () => {\n\n      nextWasCalled = true\n\n      next((callback) => { // eslint-disable-line callback-return\n        returnHandlerCallback = callback\n        resolveNextPromise()\n      })\n      await nextPromise\n    }\n\n    asyncMiddleware(req, res, asyncNext)\n      .then(async () => {\n        if (nextWasCalled) {\n          await nextPromise // we must wait until the return handler is called\n          returnHandlerCallback(null)\n        } else {\n          end(null)\n        }\n      })\n      .catch((error) => {\n        if (returnHandlerCallback) {\n          returnHandlerCallback(error)\n        } else {\n          end(error)\n        }\n      })\n  }\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","module.exports","asyncMiddleware","req","res","next","end","resolveNextPromise","nextPromise","Promise","resolve","returnHandlerCallback","nextWasCalled","asyncNext","callback","then","catch","error"]
}
