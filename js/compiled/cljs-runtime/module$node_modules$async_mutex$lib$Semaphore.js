shadow$provide.module$node_modules$async_mutex$lib$Semaphore=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});var tslib_1=require("module$node_modules$tslib$tslib");global=function(){function Semaphore(_maxConcurrency){this._maxConcurrency=_maxConcurrency;this._queue=[];if(0>=_maxConcurrency)throw Error("semaphore must be initialized to a positive value");this._value=_maxConcurrency}Semaphore.prototype.acquire=function(){var _this=this,locked=this.isLocked(),
ticket=new Promise(function(r){return _this._queue.push(r)});locked||this._dispatch();return ticket};Semaphore.prototype.runExclusive=function(callback){return tslib_1.__awaiter(this,void 0,void 0,function(){var _a,value,release;return tslib_1.__generator(this,function(_b){switch(_b.label){case 0:return[4,this.acquire()];case 1:_a=_b.sent(),value=_a[0],release=_a[1],_b.label=2;case 2:return _b.trys.push([2,,4,5]),[4,callback(value)];case 3:return[2,_b.sent()];case 4:return release(),[7];case 5:return[2]}})})};
Semaphore.prototype.isLocked=function(){return 0>=this._value};Semaphore.prototype.release=function(){if(1<this._maxConcurrency)throw Error("this method is unavailabel on semaphores with concurrency \x3e 1; use the scoped release returned by acquire instead");if(this._currentReleaser){var releaser=this._currentReleaser;this._currentReleaser=void 0;releaser()}};Semaphore.prototype._dispatch=function(){var _this=this,nextConsumer=this._queue.shift();if(nextConsumer){var released=!1;this._currentReleaser=
function(){released||(released=!0,_this._value++,_this._dispatch())};nextConsumer([this._value--,this._currentReleaser])}};return Semaphore}();exports.default=global}
//# sourceMappingURL=module$node_modules$async_mutex$lib$Semaphore.js.map
