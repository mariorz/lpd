shadow$provide.module$node_modules$ethereumjs_util$dist$secp256k1_lib$index=function(global,require,module,exports){var Buffer=require("module$node_modules$buffer$index").Buffer;"use strict";var BN=require("module$node_modules$bn_DOT_js$lib$bn"),ec=new (require("module$node_modules$elliptic$lib$elliptic").ec)("secp256k1"),ecparams=ec.curve;exports.privateKeyExport=function(privateKey,compressed){privateKey=new BN(privateKey);if(0<=privateKey.ucmp(ecparams.n))throw Error("couldn't export to DER format");
privateKey=ec.g.mul(privateKey);return toPublicKey(privateKey.getX(),privateKey.getY(),compressed)};exports.privateKeyModInverse=function(privateKey){privateKey=new BN(privateKey);if(0<=privateKey.ucmp(ecparams.n)||privateKey.isZero())throw Error("private key range is invalid");return privateKey.invm(ecparams.n).toArrayLike(Buffer,"be",32)};exports.signatureImport=function(sigObj){var r=new BN(sigObj.r);0<=r.ucmp(ecparams.n)&&(r=new BN(0));sigObj=new BN(sigObj.s);0<=sigObj.ucmp(ecparams.n)&&(sigObj=
new BN(0));return Buffer.concat([r.toArrayLike(Buffer,"be",32),sigObj.toArrayLike(Buffer,"be",32)])};exports.ecdhUnsafe=function(publicKey,privateKey,compressed){publicKey=ec.keyFromPublic(publicKey);privateKey=new BN(privateKey);if(0<=privateKey.ucmp(ecparams.n)||privateKey.isZero())throw Error("scalar was invalid (zero or overflow)");privateKey=publicKey.pub.mul(privateKey);return toPublicKey(privateKey.getX(),privateKey.getY(),compressed)};var toPublicKey=function(x,y,compressed){compressed?(compressed=
Buffer.alloc(33),compressed[0]=y.isOdd()?3:2,x.toArrayLike(Buffer,"be",32).copy(compressed,1)):(compressed=Buffer.alloc(65),compressed[0]=4,x.toArrayLike(Buffer,"be",32).copy(compressed,1),y.toArrayLike(Buffer,"be",32).copy(compressed,33));return compressed}}
//# sourceMappingURL=module$node_modules$ethereumjs_util$dist$secp256k1_lib$index.js.map
