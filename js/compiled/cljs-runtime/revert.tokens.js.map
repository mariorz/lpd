{"version":3,"sources":["revert/tokens.cljs"],"mappings":";AASA,AAAA,AAAMA,AACHC,AAAOC,AAAYC;AADtB,AAEE,AAAA,AAAK,AAACE,AACA,AAAA,AAAS,AAACC,AAAM,AAAA,AAAAC,AAACC;AAAD,AAAS,AAACC,AAAE,AAACC,AAA0BT,AAC3B,AAACS,AAA0B,AAAA,AAAAH;AAC/B,AAACI,AAAKT,AAC9B,AAACU,AAAQ,AAACC,AAAkBV,AAC5B,AAAA,AAACW;AALP,AAAA,AAAAV,AAMYW;AANZ,AAAAX,AAMqBY;AANrB,AAMyB,AAAA,AAACF;;AAN1B,AAAA,AAAAV;;;;AASF,AAAA,AAAMa,AACHC,AAAchB;AADjB,AAEE,AAAI,AAAA,AAAMgB;AACRA;;AACA,AAAMjB,AAAO,AAAA,AACC,AAACI,AAAIH,AACA,AAACW,AAA0BK;AAF9C,AAGE,AAAAC,AAAIlB;AAAJ,AAAA,AAAAkB;AAAAA;;AAAWD;;;;AAKjB,AAAA,AAAME,AACHC,AAAQC,AAASC;AADpB,AAEE,AAAMC,AAAoB,AAAChB,AAAOiB,AAAM,AAACC,AAAKL;AACxCM,AAAI,AAAI,AAACC,AAAOJ,AACV,AAAA,AAACV,AACD,AAACe,AAAOC,AACA,AAAA,AAAAC,AAACC;AAAD,AAAM,AAACC,AACA,AAAAF,AAAC1B,AAAIgB,AACL,AAAAU,AAAC/B,AAAgBuB,AAAaD;AAChCE;AAPzB,AAQE,AAAI,AAAGG;AACL,AAAA,AAACb;;AACDa;;;AAGN,AAAA,AAAMO,AACHC,AAAOZ;AADV,AAEE,AAAMa,AAAc,AAACV,AAAKS;AACpBE,AAAW,AAAA,AAACjB,AAAoBe,AAAaZ;AAC7Ce,AAAW,AAAA,AAAClB,AAAoBe,AAAaZ;AAFnD,AAAA,AAAA,AAAA,AAGSc,AACAC","names":["revert.tokens/symbol->price","symbol","token-infos","vs-price","e163330","cljs.core.get","cljs.core/first","p1__163326#","cljs.core.filter","cljs.core._EQ_","clojure.string/upper-case","cljs.core/vals","cljs.core.keyword","clojure.string/lower-case","revert.utils/bn","js/Error","err","revert.tokens/token-symbol","token-address","or__4126__auto__","revert.tokens/rewards-in-currency","rewards","currency","token-prices","rewarded-currencies","cljs.core/some?","cljs.core/keys","res","cljs.core/empty?","cljs.core.reduce","bignumber.core/+","p1__163360#","cljs.core.map","bignumber.core/*","revert.tokens/tokens-at-prices","tokens","reward-tokens","tokens-usd","tokens-eth"],"sourcesContent":["(ns revert.tokens\n  (:require\n   [clojure.string :as string]\n   [bignumber.core :as bn]\n   [revert.utils :as u]))\n\n\n\n\n(defn symbol->price\n  [symbol token-infos vs-price]\n  (try (get\n        (:prices (first (filter #(= (clojure.string/upper-case symbol)\n                                    (clojure.string/upper-case (:symbol %)))\n                                (vals token-infos))))\n        (keyword (string/lower-case vs-price))\n        (u/bn 0.0))\n       (catch js/Error err (u/bn 0.0))))\n\n\n(defn token-symbol\n  [token-address token-infos]\n  (if (nil? token-address)\n    token-address\n    (let [symbol (:symbol\n                  (get token-infos\n                       (clojure.string/lower-case token-address)))]\n      (or symbol token-address))))\n\n\n\n\n(defn rewards-in-currency\n  [rewards currency token-prices]\n  (let [rewarded-currencies (filter some? (keys rewards))\n        res (if (empty? rewarded-currencies)\n              (u/bn 0.00)\n              (reduce bn/+\n                      (map #(bn/*\n                             (get rewards %)\n                             (symbol->price % token-prices currency))\n                           rewarded-currencies)))]\n    (if (. res isNaN)\n      (u/bn 0.00)\n      res)))\n\n\n(defn tokens-at-prices\n  [tokens token-prices]\n  (let [reward-tokens (keys tokens)\n        tokens-usd (rewards-in-currency tokens \"usd\" token-prices)\n        tokens-eth (rewards-in-currency tokens \"eth\" token-prices)]\n    {\"USD\" tokens-usd\n     \"ETH\" tokens-eth}))\n"]}