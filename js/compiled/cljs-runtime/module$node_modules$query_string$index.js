shadow$provide.module$node_modules$query_string$index=function(global,require,module,exports){function encoderForArrayFormat(options){switch(options.arrayFormat){case "index":return key=>(result,value)=>{const index=result.length;return void 0===value||options.skipNull&&null===value||options.skipEmptyString&&""===value?result:null===value?[...result,[encode(key,options),"[",index,"]"].join("")]:[...result,[encode(key,options),"[",encode(index,options),"]\x3d",encode(value,options)].join("")]};case "bracket":return key=>
(result,value)=>void 0===value||options.skipNull&&null===value||options.skipEmptyString&&""===value?result:null===value?[...result,[encode(key,options),"[]"].join("")]:[...result,[encode(key,options),"[]\x3d",encode(value,options)].join("")];case "comma":case "separator":return key=>(result,value)=>null===value||void 0===value||0===value.length?result:0===result.length?[[encode(key,options),"\x3d",encode(value,options)].join("")]:[[result,encode(value,options)].join(options.arrayFormatSeparator)];
default:return key=>(result,value)=>void 0===value||options.skipNull&&null===value||options.skipEmptyString&&""===value?result:null===value?[...result,encode(key,options)]:[...result,[encode(key,options),"\x3d",encode(value,options)].join("")]}}function parserForArrayFormat(options){let result;switch(options.arrayFormat){case "index":return(key,value,accumulator)=>{result=/\[(\d*)\]$/.exec(key);key=key.replace(/\[\d*\]$/,"");result?(void 0===accumulator[key]&&(accumulator[key]={}),accumulator[key][result[1]]=
value):accumulator[key]=value};case "bracket":return(key,value,accumulator)=>{result=/(\[\])$/.exec(key);key=key.replace(/\[\]$/,"");accumulator[key]=result?void 0===accumulator[key]?[value]:[].concat(accumulator[key],value):value};case "comma":case "separator":return(key,value,accumulator)=>{value="string"===typeof value&&-1<value.split("").indexOf(options.arrayFormatSeparator)?value.split(options.arrayFormatSeparator).map(item=>decode(item,options)):null===value?value:decode(value,options);accumulator[key]=
value};default:return(key,value,accumulator)=>{accumulator[key]=void 0===accumulator[key]?value:[].concat(accumulator[key],value)}}}function validateArrayFormatSeparator(value){if("string"!==typeof value||1!==value.length)throw new TypeError("arrayFormatSeparator must be single character string");}function encode(value,options){return options.encode?options.strict?strictUriEncode(value):encodeURIComponent(value):value}function decode(value,options){return options.decode?decodeComponent(value):value}
function keysSorter(input){return Array.isArray(input)?input.sort():"object"===typeof input?keysSorter(Object.keys(input)).sort((a,b)=>Number(a)-Number(b)).map(key=>input[key]):input}function removeHash(input){const hashStart=input.indexOf("#");-1!==hashStart&&(input=input.slice(0,hashStart));return input}function extract(input){input=removeHash(input);const queryStart=input.indexOf("?");return-1===queryStart?"":input.slice(queryStart+1)}function parseValue(value,options){options.parseNumbers&&!Number.isNaN(Number(value))&&
"string"===typeof value&&""!==value.trim()?value=Number(value):!options.parseBooleans||null===value||"true"!==value.toLowerCase()&&"false"!==value.toLowerCase()||(value="true"===value.toLowerCase());return value}function parse(input,options){options=Object.assign({decode:!0,sort:!0,arrayFormat:"none",arrayFormatSeparator:",",parseNumbers:!1,parseBooleans:!1},options);validateArrayFormatSeparator(options.arrayFormatSeparator);const formatter=parserForArrayFormat(options),ret=Object.create(null);if("string"!==
typeof input)return ret;input=input.trim().replace(/^[?#&]/,"");if(!input)return ret;for(const param of input.split("\x26")){let [key,value]=splitOnFirst(options.decode?param.replace(/\+/g," "):param,"\x3d");value=void 0===value?null:["comma","separator"].includes(options.arrayFormat)?value:decode(value,options);formatter(decode(key,options),value,ret)}for(const key of Object.keys(ret))if(input=ret[key],"object"===typeof input&&null!==input)for(const k of Object.keys(input))input[k]=parseValue(input[k],
options);else ret[key]=parseValue(input,options);return!1===options.sort?ret:(!0===options.sort?Object.keys(ret).sort():Object.keys(ret).sort(options.sort)).reduce((result,key)=>{const value=ret[key];value&&"object"===typeof value&&!Array.isArray(value)?result[key]=keysSorter(value):result[key]=value;return result},Object.create(null))}const strictUriEncode=require("module$node_modules$strict_uri_encode$index"),decodeComponent=require("module$node_modules$decode_uri_component$index"),splitOnFirst=
require("module$node_modules$split_on_first$index");exports.extract=extract;exports.parse=parse;exports.stringify=(object,options)=>{if(!object)return"";options=Object.assign({encode:!0,strict:!0,arrayFormat:"none",arrayFormatSeparator:","},options);validateArrayFormatSeparator(options.arrayFormatSeparator);var shouldFilter=key=>{var JSCompiler_temp;if(JSCompiler_temp=options.skipNull)JSCompiler_temp=object[key],JSCompiler_temp=null===JSCompiler_temp||void 0===JSCompiler_temp;return JSCompiler_temp||
options.skipEmptyString&&""===object[key]};const formatter=encoderForArrayFormat(options),objectCopy={};for(const key of Object.keys(object))shouldFilter(key)||(objectCopy[key]=object[key]);shouldFilter=Object.keys(objectCopy);!1!==options.sort&&shouldFilter.sort(options.sort);return shouldFilter.map(key=>{const value=object[key];return void 0===value?"":null===value?encode(key,options):Array.isArray(value)?value.reduce(formatter(key),[]).join("\x26"):encode(key,options)+"\x3d"+encode(value,options)}).filter(x=>
0<x.length).join("\x26")};exports.parseUrl=(input,options)=>{options=Object.assign({decode:!0},options);const [url,hash]=splitOnFirst(input,"#");return Object.assign({url:url.split("?")[0]||"",query:parse(extract(input),options)},options&&options.parseFragmentIdentifier&&hash?{fragmentIdentifier:decode(hash,options)}:{})};exports.stringifyUrl=(input,options)=>{options=Object.assign({encode:!0,strict:!0},options);const url=removeHash(input.url).split("?")[0]||"";var queryFromUrl=exports.extract(input.url);
queryFromUrl=exports.parse(queryFromUrl,{sort:!1});queryFromUrl=Object.assign(queryFromUrl,input.query);(queryFromUrl=exports.stringify(queryFromUrl,options))&&(queryFromUrl=`?${queryFromUrl}`);{var JSCompiler_inline_result=input.url;let hash="";const hashStart=JSCompiler_inline_result.indexOf("#");-1!==hashStart&&(hash=JSCompiler_inline_result.slice(hashStart));JSCompiler_inline_result=hash}input.fragmentIdentifier&&(JSCompiler_inline_result=`#${encode(input.fragmentIdentifier,options)}`);return`${url}${queryFromUrl}${JSCompiler_inline_result}`}}
//# sourceMappingURL=module$node_modules$query_string$index.js.map
