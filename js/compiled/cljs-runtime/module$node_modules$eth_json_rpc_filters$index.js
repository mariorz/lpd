shadow$provide.module$node_modules$eth_json_rpc_filters$index=function(global,require,module,exports){function toFilterCreationMiddleware(createFilterFn){return toAsyncRpcMiddleware(async(...args)=>{args=await createFilterFn(...args);return intToHex(args.id)})}function toAsyncRpcMiddleware(asyncFn){return createAsyncMiddleware(async(req,res)=>{req=await asyncFn.apply(null,req.params);res.result=req})}function mutexMiddlewareWrapper({mutex}){return middleware=>async(req,res,next,end)=>{(await mutex.acquire())();
middleware(req,res,next,end)}}function objValues(obj,fn){fn=[];for(let key in obj)fn.push(obj[key]);return fn}const Mutex=require("module$node_modules$await_semaphore$index").Mutex,createAsyncMiddleware=require("module$node_modules$json_rpc_engine$src$createAsyncMiddleware"),createJsonRpcMiddleware=require("module$node_modules$eth_json_rpc_middleware$scaffold"),LogFilter=require("module$node_modules$eth_json_rpc_filters$log_filter"),BlockFilter=require("module$node_modules$eth_json_rpc_filters$block_filter"),
TxFilter=require("module$node_modules$eth_json_rpc_filters$tx_filter"),{intToHex,hexToInt}=require("module$node_modules$eth_json_rpc_filters$hexUtils");module.exports=function({blockTracker,provider}){async function newLogFilter(params){params=new LogFilter({provider,params});await installFilter(params);return params}async function newBlockFilter(){const filter=new BlockFilter({provider});await installFilter(filter);return filter}async function newPendingTransactionFilter(){const filter=new TxFilter({provider});
await installFilter(filter);return filter}async function getFilterChanges(filterIndexHex){filterIndexHex=hexToInt(filterIndexHex);const filter=filters[filterIndexHex];if(!filter)throw Error(`No filter for index "${filterIndexHex}"`);return filter.getChangesAndClear()}async function getFilterLogs(filterIndexHex){filterIndexHex=hexToInt(filterIndexHex);const filter=filters[filterIndexHex];if(!filter)throw Error(`No filter for index "${filterIndexHex}"`);return results="log"===filter.type?filter.getAllResults():
[]}async function uninstallFilterHandler(filterIndexHex){filterIndexHex=hexToInt(filterIndexHex);const result=!!filters[filterIndexHex];result&&await uninstallFilter(filterIndexHex);return result}async function installFilter(filter){const prevFilterCount=objValues(filters).length,currentBlock=await blockTracker.getLatestBlock();await filter.initialize({currentBlock});filterIndex$jscomp$0++;filters[filterIndex$jscomp$0]=filter;filter.id=filterIndex$jscomp$0;filter.idHex=intToHex(filterIndex$jscomp$0);
filter=objValues(filters).length;updateBlockTrackerSubs({prevFilterCount,newFilterCount:filter});return filterIndex$jscomp$0}async function uninstallFilter(filterIndex){const prevFilterCount=objValues(filters).length;delete filters[filterIndex];filterIndex=objValues(filters).length;updateBlockTrackerSubs({prevFilterCount,newFilterCount:filterIndex})}async function uninstallAllFilters(){const prevFilterCount=objValues(filters).length;filters={};updateBlockTrackerSubs({prevFilterCount,newFilterCount:0})}
function updateBlockTrackerSubs({prevFilterCount,newFilterCount}){if(0===prevFilterCount&&0<newFilterCount)blockTracker.on("sync",filterUpdater);else 0<prevFilterCount&&0===newFilterCount&&blockTracker.removeListener("sync",filterUpdater)}let filterIndex$jscomp$0=0,filters={};const mutex=new Mutex;var waitForFree=mutexMiddlewareWrapper({mutex});waitForFree=createJsonRpcMiddleware({eth_newFilter:waitForFree(toFilterCreationMiddleware(newLogFilter)),eth_newBlockFilter:waitForFree(toFilterCreationMiddleware(newBlockFilter)),
eth_newPendingTransactionFilter:waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),eth_uninstallFilter:waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),eth_getFilterChanges:waitForFree(toAsyncRpcMiddleware(getFilterChanges)),eth_getFilterLogs:waitForFree(toAsyncRpcMiddleware(getFilterLogs))});const filterUpdater=async({oldBlock,newBlock})=>{if(0!==filters.length){var releaseLock=await mutex.acquire();try{await Promise.all(objValues(filters).map(async filter=>{try{await filter.update({oldBlock,
newBlock})}catch(err){console.error(err)}}))}catch(err){console.error(err)}releaseLock()}};waitForFree.newLogFilter=newLogFilter;waitForFree.newBlockFilter=newBlockFilter;waitForFree.newPendingTransactionFilter=newPendingTransactionFilter;waitForFree.uninstallFilter=uninstallFilterHandler;waitForFree.getFilterChanges=getFilterChanges;waitForFree.getFilterLogs=getFilterLogs;waitForFree.destroy=()=>{uninstallAllFilters()};return waitForFree}}
//# sourceMappingURL=module$node_modules$eth_json_rpc_filters$index.js.map
