shadow$provide.module$node_modules$ethereumjs_abi$lib$index=function(global,require,module,exports){function elementaryName(name){return name.startsWith("int[")?"int256"+name.slice(3):"int"===name?"int256":name.startsWith("uint[")?"uint256"+name.slice(4):"uint"===name?"uint256":name.startsWith("fixed[")?"fixed128x128"+name.slice(5):"fixed"===name?"fixed128x128":name.startsWith("ufixed[")?"ufixed128x128"+name.slice(6):"ufixed"===name?"ufixed128x128":name}function parseTypeN(type){return parseInt(/^\D+(\d+)$/.exec(type)[1],
10)}function parseTypeNxM(type){type=/^\D+(\d+)x(\d+)$/.exec(type);return[parseInt(type[1],10),parseInt(type[2],10)]}function parseTypeArray(type){return(type=type.match(/(.*)\[(.*?)\]$/))?""===type[2]?"dynamic":parseInt(type[2],10):null}function parseNumber(arg){var type=typeof arg;if("string"===type)return utils.isHexPrefixed(arg)?new BN(utils.stripHexPrefix(arg),16):new BN(arg,10);if("number"===type)return new BN(arg);if(arg.toArray)return arg;throw Error("Argument is not a number");}function parseSignature(sig){sig=
/^(\w+)\((.*)\)$/.exec(sig);if(3!==sig.length)throw Error("Invalid method signature");var args=/^(.+)\):\((.+)$/.exec(sig[2]);if(null!==args&&3===args.length)return{method:sig[1],args:args[1].split(","),retargs:args[2].split(",")};args=sig[2].split(",");1===args.length&&""===args[0]&&(args=[]);return{method:sig[1],args}}function encodeSingle(type,arg){var i;if("address"===type)return encodeSingle("uint160",parseNumber(arg));if("bool"===type)return encodeSingle("uint8",arg?1:0);if("string"===type)return encodeSingle("bytes",
Buffer.from(arg,"utf8"));if(isArray(type)){if("undefined"===typeof arg.length)throw Error("Not an array?");var size=parseTypeArray(type);if("dynamic"!==size&&0!==size&&arg.length>size)throw Error("Elements exceed array size: "+size);var num=[];type=type.slice(0,type.lastIndexOf("["));"string"===typeof arg&&(arg=JSON.parse(arg));for(i in arg)num.push(encodeSingle(type,arg[i]));"dynamic"===size&&(size=encodeSingle("uint256",arg.length),num.unshift(size));return Buffer.concat(num)}if("bytes"===type)return arg=
Buffer.from(arg),num=Buffer.concat([encodeSingle("uint256",arg.length),arg]),0!==arg.length%32&&(num=Buffer.concat([num,utils.zeros(32-arg.length%32)])),num;if(type.startsWith("bytes")){size=parseTypeN(type);if(1>size||32<size)throw Error("Invalid bytes\x3cN\x3e width: "+size);return utils.setLengthRight(arg,32)}if(type.startsWith("uint")){size=parseTypeN(type);if(size%8||8>size||256<size)throw Error("Invalid uint\x3cN\x3e width: "+size);num=parseNumber(arg);if(num.bitLength()>size)throw Error("Supplied uint exceeds width: "+
size+" vs "+num.bitLength());if(0>num)throw Error("Supplied uint is negative");return num.toArrayLike(Buffer,"be",32)}if(type.startsWith("int")){size=parseTypeN(type);if(size%8||8>size||256<size)throw Error("Invalid int\x3cN\x3e width: "+size);num=parseNumber(arg);if(num.bitLength()>size)throw Error("Supplied int exceeds width: "+size+" vs "+num.bitLength());return num.toTwos(256).toArrayLike(Buffer,"be",32)}if(type.startsWith("ufixed")){size=parseTypeNxM(type);num=parseNumber(arg);if(0>num)throw Error("Supplied ufixed is negative");
return encodeSingle("uint256",num.mul((new BN(2)).pow(new BN(size[1]))))}if(type.startsWith("fixed"))return size=parseTypeNxM(type),encodeSingle("int256",parseNumber(arg).mul((new BN(2)).pow(new BN(size[1]))));throw Error("Unsupported or invalid type: "+type);}function decodeSingle(parsedType,data,offset){"string"===typeof parsedType&&(parsedType=parseType(parsedType));var i;if("address"===parsedType.name)return decodeSingle(parsedType.rawType,data,offset).toArrayLike(Buffer,"be",20).toString("hex");
if("bool"===parsedType.name)return decodeSingle(parsedType.rawType,data,offset).toString()===(new BN(1)).toString();if("string"===parsedType.name)return parsedType=decodeSingle(parsedType.rawType,data,offset),Buffer.from(parsedType,"utf8").toString();if(parsedType.isArray){var ret=[];var size=parsedType.size;"dynamic"===parsedType.size&&(offset=decodeSingle("uint256",data,offset).toNumber(),size=decodeSingle("uint256",data,offset).toNumber(),offset+=32);for(i=0;i<size;i++){var decoded=decodeSingle(parsedType.subArray,
data,offset);ret.push(decoded);offset+=parsedType.subArray.memoryUsage}return ret}if("bytes"===parsedType.name)return offset=decodeSingle("uint256",data,offset).toNumber(),size=decodeSingle("uint256",data,offset).toNumber(),data.slice(offset+32,offset+32+size);if(parsedType.name.startsWith("bytes"))return data.slice(offset,offset+parsedType.size);if(parsedType.name.startsWith("uint")){data=new BN(data.slice(offset,offset+32),16,"be");if(data.bitLength()>parsedType.size)throw Error("Decoded int exceeds width: "+
parsedType.size+" vs "+data.bitLength());return data}if(parsedType.name.startsWith("int")){data=(new BN(data.slice(offset,offset+32),16,"be")).fromTwos(256);if(data.bitLength()>parsedType.size)throw Error("Decoded uint exceeds width: "+parsedType.size+" vs "+data.bitLength());return data}if(parsedType.name.startsWith("ufixed")){size=(new BN(2)).pow(new BN(parsedType.size[1]));data=decodeSingle("uint256",data,offset);if(!data.mod(size).isZero())throw Error("Decimals not supported yet");return data.div(size)}if(parsedType.name.startsWith("fixed")){size=
(new BN(2)).pow(new BN(parsedType.size[1]));data=decodeSingle("int256",data,offset);if(!data.mod(size).isZero())throw Error("Decimals not supported yet");return data.div(size)}throw Error("Unsupported or invalid type: "+parsedType.name);}function parseType(type){if(isArray(type)){var size=parseTypeArray(type);var subArray=type.slice(0,type.lastIndexOf("["));subArray=parseType(subArray);size={isArray:!0,name:type,size,memoryUsage:"dynamic"===size?32:subArray.memoryUsage*size,subArray}}else{switch(type){case "address":size=
"uint160";break;case "bool":size="uint8";break;case "string":size="bytes"}size={rawType:size,name:type,memoryUsage:32};if(type.startsWith("bytes")&&"bytes"!==type||type.startsWith("uint")||type.startsWith("int"))size.size=parseTypeN(type);else if(type.startsWith("ufixed")||type.startsWith("fixed"))size.size=parseTypeNxM(type);if(type.startsWith("bytes")&&"bytes"!==type&&(1>size.size||32<size.size))throw Error("Invalid bytes\x3cN\x3e width: "+size.size);if((type.startsWith("uint")||type.startsWith("int"))&&
(size.size%8||8>size.size||256<size.size))throw Error("Invalid int/uint\x3cN\x3e width: "+size.size);}return size}function isArray(type){return type.lastIndexOf("]")===type.length-1}function stringify(type,value){return type.startsWith("address")||type.startsWith("bytes")?"0x"+value.toString("hex"):value.toString()}function isNumeric(c){return"0"<=c&&"9">=c}var Buffer=require("module$node_modules$buffer$index").Buffer;const utils=require("module$node_modules$ethereumjs_util$dist$index"),BN=require("module$node_modules$bn_DOT_js$lib$bn");
var ABI=function(){};ABI.eventID=function(name,types){name=name+"("+types.map(elementaryName).join(",")+")";return utils.keccak256(Buffer.from(name))};ABI.methodID=function(name,types){return ABI.eventID(name,types).slice(0,4)};ABI.rawEncode=function(types,values){var output=[],data=[],headLength=0;types.forEach(function(type){isArray(type)?(type=parseTypeArray(type),headLength="dynamic"!==type?headLength+32*type:headLength+32):headLength+=32});for(var i=0;i<types.length;i++){var type$jscomp$0=elementaryName(types[i]),
cur=encodeSingle(type$jscomp$0,values[i]);"string"===type$jscomp$0||"bytes"===type$jscomp$0||"dynamic"===parseTypeArray(type$jscomp$0)?(output.push(encodeSingle("uint256",headLength)),data.push(cur),headLength+=cur.length):output.push(cur)}return Buffer.concat(output.concat(data))};ABI.rawDecode=function(types,data){var ret=[];data=Buffer.from(data);for(var offset=0,i=0;i<types.length;i++){var type=elementaryName(types[i]);type=parseType(type,data,offset);var decoded=decodeSingle(type,data,offset);
offset+=type.memoryUsage;ret.push(decoded)}return ret};ABI.simpleEncode=function(method){var args=Array.prototype.slice.call(arguments).slice(1),sig=parseSignature(method);if(args.length!==sig.args.length)throw Error("Argument count mismatch");return Buffer.concat([ABI.methodID(sig.method,sig.args),ABI.rawEncode(sig.args,args)])};ABI.simpleDecode=function(method,data){method=parseSignature(method);if(!method.retargs)throw Error("No return values in method");return ABI.rawDecode(method.retargs,data)};
ABI.stringify=function(types,values){var ret=[],i;for(i in types){var type=types[i],value=values[i];value=/^[^\[]+\[.*\]$/.test(type)?value.map(function(item){return stringify(type,item)}).join(", "):stringify(type,value);ret.push(value)}return ret};ABI.solidityHexValue=function(type,value,bitsize){if(isArray(type)){var subType=type.replace(/\[.*?\]/,"");if(!isArray(subType)&&(bitsize=parseTypeArray(type),"dynamic"!==bitsize&&0!==bitsize&&value.length>bitsize))throw Error("Elements exceed array size: "+
bitsize);value=value.map(function(v){return ABI.solidityHexValue(subType,v,256)});return Buffer.concat(value)}if("bytes"===type)return value;if("string"===type)return Buffer.from(value,"utf8");if("bool"===type)return bitsize=Array((bitsize||8)/4).join("0"),Buffer.from(value?bitsize+"1":bitsize+"0","hex");if("address"===type)return type=20,bitsize&&(type=bitsize/8),utils.setLengthLeft(value,type);if(type.startsWith("bytes")){type=parseTypeN(type);if(1>type||32<type)throw Error("Invalid bytes\x3cN\x3e width: "+
type);return utils.setLengthRight(value,type)}if(type.startsWith("uint")){type=parseTypeN(type);if(type%8||8>type||256<type)throw Error("Invalid uint\x3cN\x3e width: "+type);value=parseNumber(value);if(value.bitLength()>type)throw Error("Supplied uint exceeds width: "+type+" vs "+value.bitLength());return value.toArrayLike(Buffer,"be",(bitsize||type)/8)}if(type.startsWith("int")){type=parseTypeN(type);if(type%8||8>type||256<type)throw Error("Invalid int\x3cN\x3e width: "+type);value=parseNumber(value);
if(value.bitLength()>type)throw Error("Supplied int exceeds width: "+type+" vs "+value.bitLength());bitsize=bitsize||type;return value.toTwos(type).toArrayLike(Buffer,"be",bitsize/8)}throw Error("Unsupported or invalid type: "+type);};ABI.solidityPack=function(types,values){if(types.length!==values.length)throw Error("Number of types are not matching the values");for(var ret=[],i=0;i<types.length;i++){var type=elementaryName(types[i]);ret.push(ABI.solidityHexValue(type,values[i],null))}return Buffer.concat(ret)};
ABI.soliditySHA3=function(types,values){return utils.keccak256(ABI.solidityPack(types,values))};ABI.soliditySHA256=function(types,values){return utils.sha256(ABI.solidityPack(types,values))};ABI.solidityRIPEMD160=function(types,values){return utils.ripemd160(ABI.solidityPack(types,values),!0)};ABI.fromSerpent=function(sig){for(var ret=[],i=0;i<sig.length;i++){var type=sig[i];if("s"===type)ret.push("bytes");else if("b"===type){type="bytes";for(i+=1;i<sig.length&&isNumeric(sig[i]);)type+=sig[i]-0,i++;
--i;ret.push(type)}else if("i"===type)ret.push("int256");else if("a"===type)ret.push("int256[]");else throw Error("Unsupported or invalid type: "+type);}return ret};ABI.toSerpent=function(types){for(var ret=[],i=0;i<types.length;i++){var type=types[i];if("bytes"===type)ret.push("s");else if(type.startsWith("bytes"))ret.push("b"+parseTypeN(type));else if("int256"===type)ret.push("i");else if("int256[]"===type)ret.push("a");else throw Error("Unsupported or invalid type: "+type);}return ret.join("")};
module.exports=ABI}
//# sourceMappingURL=module$node_modules$ethereumjs_abi$lib$index.js.map
