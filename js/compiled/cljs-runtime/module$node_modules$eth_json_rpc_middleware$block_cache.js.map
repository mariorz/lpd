{
"version":3,
"file":"module$node_modules$eth_json_rpc_middleware$block_cache.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/eth-json-rpc-middleware/block-cache.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$eth_json_rpc_middleware$block_cache\"] = function(global,require,module,exports) {\nconst cacheUtils = require('./cache-utils.js')\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e']\n\nmodule.exports = createBlockCacheMiddleware\n\n\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const { blockTracker } = opts\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified')\n\n  // create caching strategies\n  const blockCache = new BlockCacheStrategy()\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache,\n  }\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next()\n    }\n    // check type and matching strategy\n    const type = cacheUtils.cacheTypeForPayload(req)\n    const strategy = strategies[type]\n    // If there's no strategy in place, pass it down the chain.\n    if (!strategy) {\n      return next()\n    }\n    // If the strategy can't cache this request, ignore it.\n    if (!strategy.canCacheRequest(req)) {\n      return next()\n    }\n\n    // get block reference (number or keyword)\n    let blockTag = cacheUtils.blockTagForPayload(req)\n    if (!blockTag) blockTag = 'latest'\n\n    // get exact block number\n    let requestedBlockNumber\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00'\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock()\n      // clear all cache before latest block\n      blockCache.clearBefore(latestBlockNumber)\n      requestedBlockNumber = latestBlockNumber\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag\n    }\n\n    // end on a hit, continue on a miss\n    const cacheResult = await strategy.get(req, requestedBlockNumber)\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next()\n      // add result to cache\n      await strategy.set(req, requestedBlockNumber, res.result)\n    } else {\n      // fill in result from cache\n      res.result = cacheResult\n    }\n  })\n}\n\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  \n  constructor () {\n    this.cache = {}\n  }\n\n  getBlockCacheForPayload (payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16)\n    let blockCache = this.cache[blockNumber]\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache = {}\n      this.cache[blockNumber] = newCache\n      blockCache = newCache\n    }\n    return blockCache\n  }\n\n  async get (payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    if (!blockCache) return\n    // lookup payload in block cache\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    const cached = blockCache[identifier]\n    // may be undefined\n    return cached\n  }\n\n  async set (payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result)\n    if (!canCache) return\n    // set the value in the cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    blockCache[identifier] = result\n  }\n\n  canCacheRequest (payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false\n    }\n    // check blockTag\n    const blockTag = cacheUtils.blockTagForPayload(payload)\n    if (blockTag === 'pending') {\n      return false\n    }\n    // can be cached\n    return true\n  }\n\n  canCacheResult (payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return\n    // check if transactions have block reference before caching\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false\n      }\n    }\n    // otherwise true\n    return true\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore (oldBlockHex){\n    const self = this\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16)\n    // clear old caches\n    Object.keys(self.cache)\n      .map(Number)\n      .filter(num => num < oldBlockNumber)\n      .forEach(num => delete self.cache[num])\n  }\n\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","cacheUtils","createAsyncMiddleware","emptyValues","undefined","createBlockCacheMiddleware","opts","blockTracker","Error","blockCache","BlockCacheStrategy","strategies","perma","block","fork","req","res","next","skipCache","type","cacheTypeForPayload","strategy","canCacheRequest","blockTag","blockTagForPayload","requestedBlockNumber","latestBlockNumber","getLatestBlock","clearBefore","cacheResult","get","set","result","constructor","cache","getBlockCacheForPayload","payload","blockNumberHex","blockNumber","Number","parseInt","newCache","identifier","cached","cacheIdentifierForPayload","canCache","canCacheResult","includes","method","blockHash","oldBlockHex","self","oldBlockNumber","Object","keys","map","filter","num","forEach"]
}
