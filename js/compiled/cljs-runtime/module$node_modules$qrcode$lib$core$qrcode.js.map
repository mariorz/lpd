{
"version":3,
"file":"module$node_modules$qrcode$lib$core$qrcode.js",
"lineCount":14,
"mappings":"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",
"sources":["node_modules/qrcode/lib/core/qrcode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$qrcode\"] = function(global,require,module,exports) {\nvar BufferUtil = require('../utils/buffer')\nvar Utils = require('./utils')\nvar ECLevel = require('./error-correction-level')\nvar BitBuffer = require('./bit-buffer')\nvar BitMatrix = require('./bit-matrix')\nvar AlignmentPattern = require('./alignment-pattern')\nvar FinderPattern = require('./finder-pattern')\nvar MaskPattern = require('./mask-pattern')\nvar ECCode = require('./error-correction-code')\nvar ReedSolomonEncoder = require('./reed-solomon-encoder')\nvar Version = require('./version')\nvar FormatInfo = require('./format-info')\nvar Mode = require('./mode')\nvar Segments = require('./segments')\nvar isArray = require('isarray')\n\n/**\n * QRCode for JavaScript\n *\n * modified by Ryan Day for nodejs support\n * Copyright (c) 2011 Ryan Day\n *\n * Licensed under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n *\n//---------------------------------------------------------------------\n// QRCode for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//   http://www.opensource.org/licenses/mit-license.php\n//\n// The word \"QR Code\" is registered trademark of\n// DENSO WAVE INCORPORATED\n//   http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n*/\n\n/**\n * Add finder patterns bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupFinderPattern (matrix, version) {\n  var size = matrix.size\n  var pos = FinderPattern.getPositions(version)\n\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0]\n    var col = pos[i][1]\n\n    for (var r = -1; r <= 7; r++) {\n      if (row + r <= -1 || size <= row + r) continue\n\n      for (var c = -1; c <= 7; c++) {\n        if (col + c <= -1 || size <= col + c) continue\n\n        if ((r >= 0 && r <= 6 && (c === 0 || c === 6)) ||\n          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||\n          (r >= 2 && r <= 4 && c >= 2 && c <= 4)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add timing pattern bits to matrix\n *\n * Note: this function must be called before {@link setupAlignmentPattern}\n *\n * @param  {BitMatrix} matrix Modules matrix\n */\nfunction setupTimingPattern (matrix) {\n  var size = matrix.size\n\n  for (var r = 8; r < size - 8; r++) {\n    var value = r % 2 === 0\n    matrix.set(r, 6, value, true)\n    matrix.set(6, r, value, true)\n  }\n}\n\n/**\n * Add alignment patterns bits to matrix\n *\n * Note: this function must be called after {@link setupTimingPattern}\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupAlignmentPattern (matrix, version) {\n  var pos = AlignmentPattern.getPositions(version)\n\n  for (var i = 0; i < pos.length; i++) {\n    var row = pos[i][0]\n    var col = pos[i][1]\n\n    for (var r = -2; r <= 2; r++) {\n      for (var c = -2; c <= 2; c++) {\n        if (r === -2 || r === 2 || c === -2 || c === 2 ||\n          (r === 0 && c === 0)) {\n          matrix.set(row + r, col + c, true, true)\n        } else {\n          matrix.set(row + r, col + c, false, true)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Add version info bits to matrix\n *\n * @param  {BitMatrix} matrix  Modules matrix\n * @param  {Number}    version QR Code version\n */\nfunction setupVersionInfo (matrix, version) {\n  var size = matrix.size\n  var bits = Version.getEncodedBits(version)\n  var row, col, mod\n\n  for (var i = 0; i < 18; i++) {\n    row = Math.floor(i / 3)\n    col = i % 3 + size - 8 - 3\n    mod = ((bits >> i) & 1) === 1\n\n    matrix.set(row, col, mod, true)\n    matrix.set(col, row, mod, true)\n  }\n}\n\n/**\n * Add format info bits to matrix\n *\n * @param  {BitMatrix} matrix               Modules matrix\n * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level\n * @param  {Number}    maskPattern          Mask pattern reference value\n */\nfunction setupFormatInfo (matrix, errorCorrectionLevel, maskPattern) {\n  var size = matrix.size\n  var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern)\n  var i, mod\n\n  for (i = 0; i < 15; i++) {\n    mod = ((bits >> i) & 1) === 1\n\n    // vertical\n    if (i < 6) {\n      matrix.set(i, 8, mod, true)\n    } else if (i < 8) {\n      matrix.set(i + 1, 8, mod, true)\n    } else {\n      matrix.set(size - 15 + i, 8, mod, true)\n    }\n\n    // horizontal\n    if (i < 8) {\n      matrix.set(8, size - i - 1, mod, true)\n    } else if (i < 9) {\n      matrix.set(8, 15 - i - 1 + 1, mod, true)\n    } else {\n      matrix.set(8, 15 - i - 1, mod, true)\n    }\n  }\n\n  // fixed module\n  matrix.set(size - 8, 8, 1, true)\n}\n\n/**\n * Add encoded data bits to matrix\n *\n * @param  {BitMatrix} matrix Modules matrix\n * @param  {Buffer}    data   Data codewords\n */\nfunction setupData (matrix, data) {\n  var size = matrix.size\n  var inc = -1\n  var row = size - 1\n  var bitIndex = 7\n  var byteIndex = 0\n\n  for (var col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col--\n\n    while (true) {\n      for (var c = 0; c < 2; c++) {\n        if (!matrix.isReserved(row, col - c)) {\n          var dark = false\n\n          if (byteIndex < data.length) {\n            dark = (((data[byteIndex] >>> bitIndex) & 1) === 1)\n          }\n\n          matrix.set(row, col - c, dark)\n          bitIndex--\n\n          if (bitIndex === -1) {\n            byteIndex++\n            bitIndex = 7\n          }\n        }\n      }\n\n      row += inc\n\n      if (row < 0 || size <= row) {\n        row -= inc\n        inc = -inc\n        break\n      }\n    }\n  }\n}\n\n/**\n * Create encoded codewords from data input\n *\n * @param  {Number}   version              QR Code version\n * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level\n * @param  {ByteData} data                 Data input\n * @return {Buffer}                        Buffer containing encoded codewords\n */\nfunction createData (version, errorCorrectionLevel, segments) {\n  // Prepare data buffer\n  var buffer = new BitBuffer()\n\n  segments.forEach(function (data) {\n    // prefix data with mode indicator (4 bits)\n    buffer.put(data.mode.bit, 4)\n\n    // Prefix data with character count indicator.\n    // The character count indicator is a string of bits that represents the\n    // number of characters that are being encoded.\n    // The character count indicator must be placed after the mode indicator\n    // and must be a certain number of bits long, depending on the QR version\n    // and data mode\n    // @see {@link Mode.getCharCountIndicator}.\n    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version))\n\n    // add binary data sequence to buffer\n    data.write(buffer)\n  })\n\n  // Calculate required number of bits\n  var totalCodewords = Utils.getSymbolTotalCodewords(version)\n  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8\n\n  // Add a terminator.\n  // If the bit string is shorter than the total number of required bits,\n  // a terminator of up to four 0s must be added to the right side of the string.\n  // If the bit string is more than four bits shorter than the required number of bits,\n  // add four 0s to the end.\n  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {\n    buffer.put(0, 4)\n  }\n\n  // If the bit string is fewer than four bits shorter, add only the number of 0s that\n  // are needed to reach the required number of bits.\n\n  // After adding the terminator, if the number of bits in the string is not a multiple of 8,\n  // pad the string on the right with 0s to make the string's length a multiple of 8.\n  while (buffer.getLengthInBits() % 8 !== 0) {\n    buffer.putBit(0)\n  }\n\n  // Add pad bytes if the string is still shorter than the total number of required bits.\n  // Extend the buffer to fill the data capacity of the symbol corresponding to\n  // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)\n  // and 00010001 (0x11) alternately.\n  var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8\n  for (var i = 0; i < remainingByte; i++) {\n    buffer.put(i % 2 ? 0x11 : 0xEC, 8)\n  }\n\n  return createCodewords(buffer, version, errorCorrectionLevel)\n}\n\n/**\n * Encode input data with Reed-Solomon and return codewords with\n * relative error correction bits\n *\n * @param  {BitBuffer} bitBuffer            Data to encode\n * @param  {Number}    version              QR Code version\n * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level\n * @return {Buffer}                         Buffer containing encoded codewords\n */\nfunction createCodewords (bitBuffer, version, errorCorrectionLevel) {\n  // Total codewords for this QR code version (Data + Error correction)\n  var totalCodewords = Utils.getSymbolTotalCodewords(version)\n\n  // Total number of error correction codewords\n  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel)\n\n  // Total number of data codewords\n  var dataTotalCodewords = totalCodewords - ecTotalCodewords\n\n  // Total number of blocks\n  var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel)\n\n  // Calculate how many blocks each group should contain\n  var blocksInGroup2 = totalCodewords % ecTotalBlocks\n  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2\n\n  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)\n\n  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)\n  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1\n\n  // Number of EC codewords is the same for both groups\n  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1\n\n  // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount\n  var rs = new ReedSolomonEncoder(ecCount)\n\n  var offset = 0\n  var dcData = new Array(ecTotalBlocks)\n  var ecData = new Array(ecTotalBlocks)\n  var maxDataSize = 0\n  var buffer = BufferUtil.from(bitBuffer.buffer)\n\n  // Divide the buffer into the required number of blocks\n  for (var b = 0; b < ecTotalBlocks; b++) {\n    var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2\n\n    // extract a block of data from buffer\n    dcData[b] = buffer.slice(offset, offset + dataSize)\n\n    // Calculate EC codewords for this data block\n    ecData[b] = rs.encode(dcData[b])\n\n    offset += dataSize\n    maxDataSize = Math.max(maxDataSize, dataSize)\n  }\n\n  // Create final data\n  // Interleave the data and error correction codewords from each block\n  var data = BufferUtil.alloc(totalCodewords)\n  var index = 0\n  var i, r\n\n  // Add data codewords\n  for (i = 0; i < maxDataSize; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      if (i < dcData[r].length) {\n        data[index++] = dcData[r][i]\n      }\n    }\n  }\n\n  // Apped EC codewords\n  for (i = 0; i < ecCount; i++) {\n    for (r = 0; r < ecTotalBlocks; r++) {\n      data[index++] = ecData[r][i]\n    }\n  }\n\n  return data\n}\n\n/**\n * Build QR Code symbol\n *\n * @param  {String} data                 Input string\n * @param  {Number} version              QR Code version\n * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level\n * @param  {MaskPattern} maskPattern     Mask pattern\n * @return {Object}                      Object containing symbol data\n */\nfunction createSymbol (data, version, errorCorrectionLevel, maskPattern) {\n  var segments\n\n  if (isArray(data)) {\n    segments = Segments.fromArray(data)\n  } else if (typeof data === 'string') {\n    var estimatedVersion = version\n\n    if (!estimatedVersion) {\n      var rawSegments = Segments.rawSplit(data)\n\n      // Estimate best version that can contain raw splitted segments\n      estimatedVersion = Version.getBestVersionForData(rawSegments,\n        errorCorrectionLevel)\n    }\n\n    // Build optimized segments\n    // If estimated version is undefined, try with the highest version\n    segments = Segments.fromString(data, estimatedVersion || 40)\n  } else {\n    throw new Error('Invalid data')\n  }\n\n  // Get the min version that can contain data\n  var bestVersion = Version.getBestVersionForData(segments,\n      errorCorrectionLevel)\n\n  // If no version is found, data cannot be stored\n  if (!bestVersion) {\n    throw new Error('The amount of data is too big to be stored in a QR Code')\n  }\n\n  // If not specified, use min version as default\n  if (!version) {\n    version = bestVersion\n\n  // Check if the specified version can contain the data\n  } else if (version < bestVersion) {\n    throw new Error('\\n' +\n      'The chosen QR Code version cannot contain this amount of data.\\n' +\n      'Minimum version required to store current data is: ' + bestVersion + '.\\n'\n    )\n  }\n\n  var dataBits = createData(version, errorCorrectionLevel, segments)\n\n  // Allocate matrix buffer\n  var moduleCount = Utils.getSymbolSize(version)\n  var modules = new BitMatrix(moduleCount)\n\n  // Add function modules\n  setupFinderPattern(modules, version)\n  setupTimingPattern(modules)\n  setupAlignmentPattern(modules, version)\n\n  // Add temporary dummy bits for format info just to set them as reserved.\n  // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}\n  // since the masking operation must be performed only on the encoding region.\n  // These blocks will be replaced with correct values later in code.\n  setupFormatInfo(modules, errorCorrectionLevel, 0)\n\n  if (version >= 7) {\n    setupVersionInfo(modules, version)\n  }\n\n  // Add data codewords\n  setupData(modules, dataBits)\n\n  if (isNaN(maskPattern)) {\n    // Find best mask pattern\n    maskPattern = MaskPattern.getBestMask(modules,\n      setupFormatInfo.bind(null, modules, errorCorrectionLevel))\n  }\n\n  // Apply mask pattern\n  MaskPattern.applyMask(maskPattern, modules)\n\n  // Replace format info bits with correct values\n  setupFormatInfo(modules, errorCorrectionLevel, maskPattern)\n\n  return {\n    modules: modules,\n    version: version,\n    errorCorrectionLevel: errorCorrectionLevel,\n    maskPattern: maskPattern,\n    segments: segments\n  }\n}\n\n/**\n * QR Code\n *\n * @param {String | Array} data                 Input data\n * @param {Object} options                      Optional configurations\n * @param {Number} options.version              QR Code version\n * @param {String} options.errorCorrectionLevel Error correction level\n * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis\n */\nexports.create = function create (data, options) {\n  if (typeof data === 'undefined' || data === '') {\n    throw new Error('No input text')\n  }\n\n  var errorCorrectionLevel = ECLevel.M\n  var version\n  var mask\n\n  if (typeof options !== 'undefined') {\n    // Use higher error correction level as default\n    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M)\n    version = Version.from(options.version)\n    mask = MaskPattern.from(options.maskPattern)\n\n    if (options.toSJISFunc) {\n      Utils.setToSJISFunction(options.toSJISFunc)\n    }\n  }\n\n  return createSymbol(data, version, errorCorrectionLevel, mask)\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","setupFormatInfo","matrix","errorCorrectionLevel","maskPattern","size","bits","FormatInfo","getEncodedBits","i","mod","set","createData","version","segments","buffer","BitBuffer","forEach","data","put","mode","bit","getLength","Mode","getCharCountIndicator","write","totalCodewords","Utils","getSymbolTotalCodewords","ecTotalCodewords","ECCode","getTotalCodewordsCount","dataTotalCodewordsBits","getLengthInBits","putBit","remainingByte","createCodewords","bitBuffer","dataTotalCodewords","ecTotalBlocks","getBlocksCount","blocksInGroup1","dataCodewordsInGroup1","Math","floor","dataCodewordsInGroup2","ecCount","totalCodewordsInGroup1","rs","ReedSolomonEncoder","offset","dcData","Array","ecData","maxDataSize","BufferUtil","from","b","dataSize","slice","encode","max","alloc","index","r","length","ECLevel","BitMatrix","AlignmentPattern","FinderPattern","MaskPattern","Version","Segments","isArray","create","exports.create","options","Error","M","mask","toSJISFunc","setToSJISFunction","fromArray","estimatedVersion","rawSegments","rawSplit","getBestVersionForData","fromString","bestVersion","dataBits","moduleCount","getSymbolSize","modules","pos","getPositions","row","col","c","value","inc","bitIndex","byteIndex","isReserved","dark","isNaN","getBestMask","bind","applyMask"]
}
