{
"version":3,
"file":"module$node_modules$string_decoder$index.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/string_decoder/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$string_decoder$index\"] = function(global,require,module,exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","passThroughWrite","buffer","toString","encoding","utf16DetectIncompleteChar","charLength","charReceived","length","base64DetectIncompleteChar","Buffer","isBufferEncoding","isEncoding","toLowerCase","StringDecoder","exports.StringDecoder","replace","Error","surrogateSize","detectIncompleteChar","write","charBuffer","prototype","StringDecoder.prototype.write","charStr","available","copy","slice","charCode","charCodeAt","end","size","substring","StringDecoder.prototype.detectIncompleteChar","i","c","StringDecoder.prototype.end","res","enc"]
}
