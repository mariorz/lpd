{
"version":3,
"file":"module$node_modules$qrcode$lib$core$galois_field.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAe,gDAAf,CAAqE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CACzGC,MAAAA,CAAaH,OAAA,CAAQ,wDAAR,CAEjB,KAAII,UAAYD,MAAA,CAAWE,KAAX,CAAiB,GAAjB,CAAhB,CACIC,UAAYH,MAAA,CAAWE,KAAX,CAAiB,GAAjB,CASdE,UAAoB,EAAG,CAEvB,IADA,IAAIC,EAAI,CAAR,CACSC,EAAI,CAAb,CAAoB,GAApB,CAAgBA,CAAhB,CAAyBA,CAAA,EAAzB,CACEL,SAAA,CAAUK,CAAV,CAOA,CAPeD,CAOf,CANAF,SAAA,CAAUE,CAAV,CAMA,CANeC,CAMf,CAJAD,CAIA,GAJM,CAIN,CAAIA,CAAJ,CAAQ,GAAR,GACEA,CADF,EACO,GADP,CASF,KAAKC,CAAL,CAAS,GAAT,CAAkB,GAAlB,CAAcA,CAAd,CAAuBA,CAAA,EAAvB,CACEL,SAAA,CAAUK,CAAV,CAAA,CAAeL,SAAA,CAAUK,CAAV,CAAc,GAAd,CApBM,CAAvBF,CAAA,EA8BFL,QAAA,CAAQQ,GAAR,CAAcC,QAAa,CAACC,CAAD,CAAI,CAC7B,GAAQ,CAAR,CAAIA,CAAJ,CAAW,KAAUC,MAAJ,CAAU,MAAV,CAAmBD,CAAnB,CAAuB,GAAvB,CAAN,CACX,MAAON,UAAA,CAAUM,CAAV,CAFsB,CAW/BV,QAAA,CAAQY,GAAR,CAAcC,QAAa,CAACH,CAAD,CAAI,CAC7B,MAAOR,UAAA,CAAUQ,CAAV,CADsB,CAW/BV;OAAA,CAAQc,GAAR,CAAcC,QAAa,CAACT,CAAD,CAAIU,CAAJ,CAAO,CAChC,MAAU,EAAV,GAAIV,CAAJ,EAAqB,CAArB,GAAeU,CAAf,CAA+B,CAA/B,CAIOd,SAAA,CAAUE,SAAA,CAAUE,CAAV,CAAV,CAAyBF,SAAA,CAAUY,CAAV,CAAzB,CALyB,CAjE2E;",
"sources":["node_modules/qrcode/lib/core/galois-field.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$qrcode$lib$core$galois_field\"] = function(global,require,module,exports) {\nvar BufferUtil = require('../utils/buffer')\n\nvar EXP_TABLE = BufferUtil.alloc(512)\nvar LOG_TABLE = BufferUtil.alloc(256)\n/**\n * Precompute the log and anti-log tables for faster computation later\n *\n * For each possible value in the galois field 2^8, we will pre-compute\n * the logarithm and anti-logarithm (exponential) of this value\n *\n * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}\n */\n;(function initTables () {\n  var x = 1\n  for (var i = 0; i < 255; i++) {\n    EXP_TABLE[i] = x\n    LOG_TABLE[x] = i\n\n    x <<= 1 // multiply by 2\n\n    // The QR code specification says to use byte-wise modulo 100011101 arithmetic.\n    // This means that when a number is 256 or larger, it should be XORed with 0x11D.\n    if (x & 0x100) { // similar to x >= 256, but a lot faster (because 0x100 == 256)\n      x ^= 0x11D\n    }\n  }\n\n  // Optimization: double the size of the anti-log table so that we don't need to mod 255 to\n  // stay inside the bounds (because we will mainly use this table for the multiplication of\n  // two GF numbers, no more).\n  // @see {@link mul}\n  for (i = 255; i < 512; i++) {\n    EXP_TABLE[i] = EXP_TABLE[i - 255]\n  }\n}())\n\n/**\n * Returns log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.log = function log (n) {\n  if (n < 1) throw new Error('log(' + n + ')')\n  return LOG_TABLE[n]\n}\n\n/**\n * Returns anti-log value of n inside Galois Field\n *\n * @param  {Number} n\n * @return {Number}\n */\nexports.exp = function exp (n) {\n  return EXP_TABLE[n]\n}\n\n/**\n * Multiplies two number inside Galois Field\n *\n * @param  {Number} x\n * @param  {Number} y\n * @return {Number}\n */\nexports.mul = function mul (x, y) {\n  if (x === 0 || y === 0) return 0\n\n  // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized\n  // @see {@link initTables}\n  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","BufferUtil","EXP_TABLE","alloc","LOG_TABLE","initTables","x","i","log","exports.log","n","Error","exp","exports.exp","mul","exports.mul","y"]
}
