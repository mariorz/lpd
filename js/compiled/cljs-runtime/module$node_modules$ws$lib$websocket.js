shadow$provide.module$node_modules$ws$lib$websocket=function(global,require,module,exports){function initAsClient(address,protocols,options){options=Object.assign({protocolVersion:protocolVersions[1],perMessageDeflate:!0},options,{createConnection:void 0,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:void 0,auth:void 0,host:void 0,path:void 0,port:void 0});if(-1===protocolVersions.indexOf(options.protocolVersion))throw new RangeError(`Unsupported protocol version: ${options.protocolVersion} `+
`(supported versions: ${protocolVersions.join(", ")})`);this._isServer=!1;if("object"===typeof address&&void 0!==address.href){var parsedUrl=address;this.url=address.href}else parsedUrl=url.parse(address),this.url=address;const isUnixSocket="ws+unix:"===parsedUrl.protocol;if(!(parsedUrl.host||isUnixSocket&&parsedUrl.pathname))throw Error(`Invalid URL: ${this.url}`);const isSecure="wss:"===parsedUrl.protocol||"https:"===parsedUrl.protocol,key=crypto.randomBytes(16).toString("base64");address=isSecure?
https:http;const path=parsedUrl.search?`${parsedUrl.pathname||"/"}${parsedUrl.search}`:parsedUrl.pathname||"/";options.createConnection=isSecure?tlsConnect:netConnect;options.port=parsedUrl.port||(isSecure?443:80);options.host=parsedUrl.hostname.startsWith("[")?parsedUrl.hostname.slice(1,-1):parsedUrl.hostname;options.headers=Object.assign({"Sec-WebSocket-Version":options.protocolVersion,"Sec-WebSocket-Key":key,Connection:"Upgrade",Upgrade:"websocket"},options.headers);options.path=path;if(options.perMessageDeflate){var perMessageDeflate=
new PerMessageDeflate(!0!==options.perMessageDeflate?options.perMessageDeflate:{},!1);options.headers["Sec-WebSocket-Extensions"]=extension.format({[PerMessageDeflate.extensionName]:perMessageDeflate.offer()})}protocols&&(options.headers["Sec-WebSocket-Protocol"]=protocols);options.origin&&(13>options.protocolVersion?options.headers["Sec-WebSocket-Origin"]=options.origin:options.headers.Origin=options.origin);if(parsedUrl.auth)options.auth=parsedUrl.auth;else if(parsedUrl.username||parsedUrl.password)options.auth=
`${parsedUrl.username}:${parsedUrl.password}`;isUnixSocket&&(parsedUrl=path.split(":"),null==options.agent&&57>process.versions.modules?options._socketPath=parsedUrl[0]:options.socketPath=parsedUrl[0],options.path=parsedUrl[1]);var req=this._req=address.get(options);options.handshakeTimeout&&req.setTimeout(options.handshakeTimeout,()=>abortHandshake(this,req,"Opening handshake has timed out"));req.on("error",err=>{this._req.aborted||(req=this._req=null,this.readyState=WebSocket.CLOSING,this.emit("error",
err),this.emitClose())});req.on("response",res=>{this.emit("unexpected-response",req,res)||abortHandshake(this,req,`Unexpected server response: ${res.statusCode}`)});req.on("upgrade",(res,socket,head)=>{this.emit("upgrade",res);if(this.readyState===WebSocket.CONNECTING){req=this._req=null;var digest=crypto.createHash("sha1").update(key+constants.GUID,"binary").digest("base64");if(res.headers["sec-websocket-accept"]!==digest)abortHandshake(this,socket,"Invalid Sec-WebSocket-Accept header");else{digest=
res.headers["sec-websocket-protocol"];var protList=(protocols||"").split(/, */),protError;!protocols&&digest?protError="Server sent a subprotocol but none was requested":protocols&&!digest?protError="Server sent no subprotocol":digest&&-1===protList.indexOf(digest)&&(protError="Server sent an invalid subprotocol");if(protError)abortHandshake(this,socket,protError);else{digest&&(this.protocol=digest);if(perMessageDeflate)try{const extensions=extension.parse(res.headers["sec-websocket-extensions"]);
extensions[PerMessageDeflate.extensionName]&&(perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]),this._extensions[PerMessageDeflate.extensionName]=perMessageDeflate)}catch(err){abortHandshake(this,socket,"Invalid Sec-WebSocket-Extensions header");return}this.setSocket(socket,head,0)}}}})}function netConnect(options){options.path=options.socketPath||options._socketPath||void 0;return net.connect(options)}function tlsConnect(options){options.path=options.socketPath||options._socketPath||
void 0;options.servername=options.servername||options.host;return tls.connect(options)}function abortHandshake(websocket,stream,message){websocket.readyState=WebSocket.CLOSING;message=Error(message);Error.captureStackTrace(message,abortHandshake);stream.setHeader?(stream.abort(),stream.once("abort",websocket.emitClose.bind(websocket)),websocket.emit("error",message)):(stream.destroy(message),stream.once("error",websocket.emit.bind(websocket,"error")),stream.once("close",websocket.emitClose.bind(websocket)))}
function receiverOnConclude(code,reason){const websocket=this[kWebSocket];websocket._socket.removeListener("data",socketOnData);websocket._socket.resume();websocket._closeFrameReceived=!0;websocket._closeMessage=reason;websocket._closeCode=code;1005===code?websocket.close():websocket.close(code,reason)}function receiverOnDrain(){this[kWebSocket]._socket.resume()}function receiverOnError(err){const websocket=this[kWebSocket];websocket._socket.removeListener("data",socketOnData);websocket.readyState=
WebSocket.CLOSING;websocket._closeCode=err[constants.kStatusCode];websocket.emit("error",err);websocket._socket.destroy()}function receiverOnFinish(){this[kWebSocket].emitClose()}function receiverOnMessage(data){this[kWebSocket].emit("message",data)}function receiverOnPing(data){const websocket=this[kWebSocket];websocket.pong(data,!websocket._isServer,constants.NOOP);websocket.emit("ping",data)}function receiverOnPong(data){this[kWebSocket].emit("pong",data)}function socketOnClose(){const websocket=
this[kWebSocket];this.removeListener("close",socketOnClose);this.removeListener("end",socketOnEnd);websocket.readyState=WebSocket.CLOSING;websocket._socket.read();websocket._receiver.end();this.removeListener("data",socketOnData);this[kWebSocket]=void 0;clearTimeout(websocket._closeTimer);websocket._receiver._writableState.finished||websocket._receiver._writableState.errorEmitted?websocket.emitClose():(websocket._receiver.on("error",receiverOnFinish),websocket._receiver.on("finish",receiverOnFinish))}
function socketOnData(chunk){this[kWebSocket]._receiver.write(chunk)||this.pause()}function socketOnEnd(){const websocket=this[kWebSocket];websocket.readyState=WebSocket.CLOSING;websocket._receiver.end();this.end()}function socketOnError(){const websocket=this[kWebSocket];this.removeListener("error",socketOnError);this.on("error",constants.NOOP);websocket&&(websocket.readyState=WebSocket.CLOSING,this.destroy())}var process=require("module$node_modules$process$browser");"use strict";global=require("module$node_modules$events$events");
const crypto=require("module$node_modules$crypto_browserify$index"),https=require("module$node_modules$https_browserify$index"),http=require("module$node_modules$stream_http$index"),net=require("shadow$empty"),tls=require("shadow$empty"),url=require("module$node_modules$url$url"),PerMessageDeflate=require("module$node_modules$ws$lib$permessage_deflate");exports=require("module$node_modules$ws$lib$event_target");const extension=require("module$node_modules$ws$lib$extension"),constants=require("module$node_modules$ws$lib$constants"),
Receiver=require("module$node_modules$ws$lib$receiver"),Sender=require("module$node_modules$ws$lib$sender"),readyStates=["CONNECTING","OPEN","CLOSING","CLOSED"],kWebSocket=constants.kWebSocket,protocolVersions=[8,13];class WebSocket extends global{constructor(address,protocols,options){super();this.readyState=WebSocket.CONNECTING;this.protocol="";this._binaryType=constants.BINARY_TYPES[0];this._closeFrameSent=this._closeFrameReceived=!1;this._closeMessage="";this._closeTimer=null;this._closeCode=
1006;this._extensions={};this._isServer=!0;this._socket=this._sender=this._receiver=null;null!==address&&(Array.isArray(protocols)?protocols=protocols.join(", "):"object"===typeof protocols&&null!==protocols&&(options=protocols,protocols=void 0),initAsClient.call(this,address,protocols,options))}get CONNECTING(){return WebSocket.CONNECTING}get CLOSING(){return WebSocket.CLOSING}get CLOSED(){return WebSocket.CLOSED}get OPEN(){return WebSocket.OPEN}get binaryType(){return this._binaryType}set binaryType(type){0>
constants.BINARY_TYPES.indexOf(type)||(this._binaryType=type,this._receiver&&(this._receiver._binaryType=type))}get bufferedAmount(){return this._socket?(this._socket.bufferSize||0)+this._sender._bufferedBytes:0}get extensions(){return Object.keys(this._extensions).join()}setSocket(socket,head,maxPayload){maxPayload=new Receiver(this._binaryType,this._extensions,maxPayload);this._sender=new Sender(socket,this._extensions);this._receiver=maxPayload;this._socket=socket;maxPayload[kWebSocket]=this;socket[kWebSocket]=
this;maxPayload.on("conclude",receiverOnConclude);maxPayload.on("drain",receiverOnDrain);maxPayload.on("error",receiverOnError);maxPayload.on("message",receiverOnMessage);maxPayload.on("ping",receiverOnPing);maxPayload.on("pong",receiverOnPong);socket.setTimeout(0);socket.setNoDelay();0<head.length&&socket.unshift(head);socket.on("close",socketOnClose);socket.on("data",socketOnData);socket.on("end",socketOnEnd);socket.on("error",socketOnError);this.readyState=WebSocket.OPEN;this.emit("open")}emitClose(){this.readyState=
WebSocket.CLOSED;this._socket&&(this._extensions[PerMessageDeflate.extensionName]&&this._extensions[PerMessageDeflate.extensionName].cleanup(),this._receiver.removeAllListeners());this.emit("close",this._closeCode,this._closeMessage)}close(code,data){if(this.readyState!==WebSocket.CLOSED){if(this.readyState===WebSocket.CONNECTING)return abortHandshake(this,this._req,"WebSocket was closed before the connection was established");this.readyState===WebSocket.CLOSING?this._closeFrameSent&&this._closeFrameReceived&&
this._socket.end():(this.readyState=WebSocket.CLOSING,this._sender.close(code,data,!this._isServer,err=>{err||(this._closeFrameSent=!0,this._socket.writable&&(this._closeFrameReceived&&this._socket.end(),this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),3E4)))}))}}ping(data,mask,cb){"function"===typeof data?(cb=data,data=mask=void 0):"function"===typeof mask&&(cb=mask,mask=void 0);if(this.readyState!==WebSocket.OPEN){data=Error(`WebSocket is not open: readyState ${this.readyState} `+
`(${readyStates[this.readyState]})`);if(cb)return cb(data);throw data;}"number"===typeof data&&(data=data.toString());void 0===mask&&(mask=!this._isServer);this._sender.ping(data||constants.EMPTY_BUFFER,mask,cb)}pong(data,mask,cb){"function"===typeof data?(cb=data,data=mask=void 0):"function"===typeof mask&&(cb=mask,mask=void 0);if(this.readyState!==WebSocket.OPEN){data=Error(`WebSocket is not open: readyState ${this.readyState} `+`(${readyStates[this.readyState]})`);if(cb)return cb(data);throw data;
}"number"===typeof data&&(data=data.toString());void 0===mask&&(mask=!this._isServer);this._sender.pong(data||constants.EMPTY_BUFFER,mask,cb)}send(data,options,cb){"function"===typeof options&&(cb=options,options={});if(this.readyState!==WebSocket.OPEN){data=Error(`WebSocket is not open: readyState ${this.readyState} `+`(${readyStates[this.readyState]})`);if(cb)return cb(data);throw data;}"number"===typeof data&&(data=data.toString());options=Object.assign({binary:"string"!==typeof data,mask:!this._isServer,
compress:!0,fin:!0},options);this._extensions[PerMessageDeflate.extensionName]||(options.compress=!1);this._sender.send(data||constants.EMPTY_BUFFER,options,cb)}terminate(){if(this.readyState!==WebSocket.CLOSED){if(this.readyState===WebSocket.CONNECTING)return abortHandshake(this,this._req,"WebSocket was closed before the connection was established");this._socket&&(this.readyState=WebSocket.CLOSING,this._socket.destroy())}}}readyStates.forEach((readyState,i)=>{WebSocket[readyStates[i]]=i});["open",
"error","close","message"].forEach(method=>{Object.defineProperty(WebSocket.prototype,`on${method}`,{get(){const listeners=this.listeners(method);for(var i=0;i<listeners.length;i++)if(listeners[i]._listener)return listeners[i]._listener},set(listener){const listeners=this.listeners(method);for(var i=0;i<listeners.length;i++)listeners[i]._listener&&this.removeListener(method,listeners[i]);this.addEventListener(method,listener)}})});WebSocket.prototype.addEventListener=exports.addEventListener;WebSocket.prototype.removeEventListener=
exports.removeEventListener;module.exports=WebSocket}
//# sourceMappingURL=module$node_modules$ws$lib$websocket.js.map
