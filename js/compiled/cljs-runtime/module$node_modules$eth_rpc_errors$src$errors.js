shadow$provide.module$node_modules$eth_rpc_errors$src$errors=function(global,require,module,exports){function getEthJsonRpcError(code,opts){var $jscomp$destructuring$var8=$jscomp.makeIterator(validateOpts(opts));opts=$jscomp$destructuring$var8.next().value;$jscomp$destructuring$var8=$jscomp$destructuring$var8.next().value;return new EthereumRpcError(code,opts||getMessageFromCode(code),$jscomp$destructuring$var8)}function getEthProviderError(code,opts){var $jscomp$destructuring$var9=$jscomp.makeIterator(validateOpts(opts));
opts=$jscomp$destructuring$var9.next().value;$jscomp$destructuring$var9=$jscomp$destructuring$var9.next().value;return new EthereumProviderError(code,opts||getMessageFromCode(code),$jscomp$destructuring$var9)}function validateOpts(opts){if(opts){if("string"===typeof opts)return[opts];if("object"===typeof opts&&!Array.isArray(opts))return[opts.message,opts.data]}return[]}global=require("module$node_modules$eth_rpc_errors$src$classes");var EthereumRpcError=global.EthereumRpcError,EthereumProviderError=
global.EthereumProviderError,getMessageFromCode=require("module$node_modules$eth_rpc_errors$src$utils").getMessageFromCode,ERROR_CODES=require("module$node_modules$eth_rpc_errors$src$errorCodes_json");module.exports={rpc:{parse:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.parse,opts)},invalidRequest:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.invalidRequest,opts)},invalidParams:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.invalidParams,opts)},methodNotFound:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.methodNotFound,
opts)},internal:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.internal,opts)},server:function(opts){if(!opts||"object"!==typeof opts||Array.isArray(opts))throw Error("Ethereum RPC Server errors must provide single object argument.");var code=opts.code;if(!Number.isInteger(code)||-32005<code||-32099>code)throw Error('"code" must be an integer such that: -32099 \x3c\x3d code \x3c\x3d -32005');return getEthJsonRpcError(code,opts)},invalidInput:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.invalidInput,
opts)},resourceNotFound:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.resourceNotFound,opts)},resourceUnavailable:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.resourceUnavailable,opts)},transactionRejected:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.transactionRejected,opts)},methodNotSupported:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.methodNotSupported,opts)},limitExceeded:function(opts){return getEthJsonRpcError(ERROR_CODES.rpc.limitExceeded,opts)}},
provider:{userRejectedRequest:function(opts){return getEthProviderError(ERROR_CODES.provider.userRejectedRequest,opts)},unauthorized:function(opts){return getEthProviderError(ERROR_CODES.provider.unauthorized,opts)},unsupportedMethod:function(opts){return getEthProviderError(ERROR_CODES.provider.unsupportedMethod,opts)},disconnected:function(opts){return getEthProviderError(ERROR_CODES.provider.disconnected,opts)},chainDisconnected:function(opts){return getEthProviderError(ERROR_CODES.provider.chainDisconnected,
opts)},custom:function(opts){if(!opts||"object"!==typeof opts||Array.isArray(opts))throw Error("Ethereum Provider custom errors must provide single object argument.");var code=opts.code,message=opts.message;opts=opts.data;if(!message||"string"!==typeof message)throw Error('"message" must be a nonempty string');return new EthereumProviderError(code,message,opts)}}}}
//# sourceMappingURL=module$node_modules$eth_rpc_errors$src$errors.js.map
